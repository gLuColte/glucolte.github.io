<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Modern Knowledgebases · glucolte</title>
  <meta name="description" content="notes • principles • systems">
  <link rel="stylesheet" href="/assets/style.css">
  <link rel="stylesheet" href="/assets/study.css">
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/favicon.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Modern Knowledgebases | glucolte</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Modern Knowledgebases" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="notes • principles • systems" />
<meta property="og:description" content="notes • principles • systems" />
<link rel="canonical" href="http://localhost:4000/study/aiKnowledgebases" />
<meta property="og:url" content="http://localhost:4000/study/aiKnowledgebases" />
<meta property="og:site_name" content="glucolte" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Modern Knowledgebases" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"notes • principles • systems","headline":"Modern Knowledgebases","url":"http://localhost:4000/study/aiKnowledgebases"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
  <header class="site-header">
  <a class="brand" href="/">glucolte</a>
  <nav class="nav">
    <a href="/principles">principles</a>
    <a href="/rules">rules</a>
    <a href="/stretches">stretches</a>
    <a href="/study/">study</a>
    <a href="/projects/">projects</a>
    <a href="/setup/">setup</a>
  </nav>
  <button id="dark-mode-toggle" class="dark-mode-toggle" aria-label="Toggle dark mode">
    <svg class="sun-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
    <svg class="moon-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
    </svg>
  </button>
</header>


  <main class="container">
    <article class="content">
      <h1 id="modern-knowledgebases">Modern Knowledgebases</h1>

<p>A few weeks ago, I migrated a dataset of around 30 million rows from <strong>MySQL</strong> to <strong>Parquet + DuckDB</strong>.<br />
The query time dropped from nearly a minute to just a few seconds.<br />
That shift changed how I thought about data: sometimes, the biggest gains come not from more compute,<br />
but from <strong>how data is organized and read</strong>.</p>

<p>That realization made me curious — if columnar databases redefined analytics,<br />
what’s the equivalent shift happening in <strong>knowledge systems</strong>?</p>

<p>Over the past year, I’ve been exploring how new systems—<strong>vector databases</strong>, <strong>embedding models</strong>, and <strong>retrieval frameworks</strong>—are quietly rebuilding the foundation of how machines represent and reason over information.<br />
This post is my attempt to organize that understanding.</p>

<hr />

<h2 id="1-the-architecture-of-modern-knowledgebases">1. The Architecture of Modern Knowledgebases</h2>

<p>At a high level, every modern “AI knowledgebase” sits on a stack of layers.<br />
Each one has a distinct responsibility—from raw storage to semantic reasoning.</p>

<table class="study-table">
  <thead>
    <tr>
      <th>Layer</th>
      <th>Responsibility</th>
      <th>Focus Area</th>
      <th>Analogy</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>L0 – Physical Storage</strong></td>
      <td>Where the bytes actually live: disk, SSD, S3, or block storage.</td>
      <td>Durability, throughput, cost.</td>
      <td>The warehouse floor — where everything physically sits.</td>
    </tr>
    <tr>
      <td><strong>L1 – Data Layout</strong></td>
      <td>How vectors and metadata are serialized or chunked on disk.</td>
      <td>Data formats, compression, compaction.</td>
      <td>The shelving system — how boxes are arranged.</td>
    </tr>
    <tr>
      <td><strong>L2 – Indexing &amp; Retrieval</strong></td>
      <td>How we find similar vectors quickly, without scanning everything.</td>
      <td>ANN algorithms like HNSW, IVF, PQ, DiskANN.</td>
      <td>The map of aisles — guiding you to the right shelf.</td>
    </tr>
    <tr>
      <td><strong>L3 – Search &amp; API Layer</strong></td>
      <td>The database interface: how you insert, query, and filter.</td>
      <td>Schema design, access control, hybrid filters.</td>
      <td>The reception desk — turns requests into lookups.</td>
    </tr>
    <tr>
      <td><strong>L4 – Integration / Retrieval Orchestration</strong></td>
      <td>Coordinates ingestion, embeddings, hybrid search, and reranking.</td>
      <td>Connectors, embedding pipelines, rerankers, query rewriting.</td>
      <td>The librarian — knows where to look and stacks the right boxes for you.</td>
    </tr>
    <tr>
      <td><strong>L5 – Reasoning / Generation</strong></td>
      <td>The layer that actually “thinks.” Uses context from L4 and responds in language.</td>
      <td>Prompting, planning, grounding, LLM reasoning.</td>
      <td>The subject-matter expert — reads the boxes and explains.</td>
    </tr>
  </tbody>
</table>

<p>Notes:</p>
<ol>
  <li><strong>Vector stores (L0–L3)</strong> handle how knowledge is stored, indexed, and retrieved efficiently.</li>
  <li><strong>Integration layers (L4)</strong> orchestrate embeddings, rerankers, and retrieval pipelines.</li>
  <li><strong>Reasoning layers (L5)</strong> use that context to generate insights, answers, or summaries.</li>
  <li><strong>Weaviate</strong> extends into L4; <strong>Kendra</strong> is a managed retrieval system; <strong>LangChain</strong> and <strong>LlamaIndex</strong> span both retrieval and reasoning.</li>
  <li>Together, these layers define the architecture of a <strong>modern AI knowledgebase</strong> — a system that doesn’t just <em>store</em> information, but can <em>understand and communicate</em> it.</li>
</ol>

<hr />

<h2 id="2-vectors-and-meaning">2. Vectors and Meaning</h2>

<p>At the heart of this new architecture is the <strong>vector</strong> — a numerical representation of meaning.</p>

<p>For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"The cat sits on the mat" → [0.12, -0.45, 0.88, ...] # 1536-dimensional embedding
</code></pre></div></div>

<p>A vector is just a long list of floating-point numbers, but its geometry captures relationships:<br />
sentences or images that “mean” similar things are close together in this high-dimensional space.<br />
Different models produce different kinds of embeddings, depending on what they were trained for.</p>

<table class="study-table">
  <thead>
    <tr>
      <th>Model</th>
      <th>Training Focus</th>
      <th>Strengths</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>OpenAI text-embedding-3-large</strong></td>
      <td>General-purpose text</td>
      <td>Broad coverage and strong multilingual performance.</td>
    </tr>
    <tr>
      <td><strong>AWS Titan Embeddings G1</strong></td>
      <td>Enterprise documents</td>
      <td>Handles structured, factual content effectively.</td>
    </tr>
    <tr>
      <td><strong>Cohere Embed v3</strong></td>
      <td>Multi-domain semantic search</td>
      <td>Tunable for classification and retrieval tasks.</td>
    </tr>
    <tr>
      <td><strong>CLIP (OpenAI)</strong></td>
      <td>Image ↔ text alignment</td>
      <td>Bridges visual and language representations.</td>
    </tr>
    <tr>
      <td><strong>E5 (Microsoft)</strong></td>
      <td>Sentence-level retrieval</td>
      <td>Optimized for semantic search and ranking.</td>
    </tr>
    <tr>
      <td><strong>Instructor XL</strong></td>
      <td>Task-specific embeddings</td>
      <td>Performs well in RAG and domain-tuned workflows.</td>
    </tr>
  </tbody>
</table>

<p>Understanding embeddings is the first step.<br />
But storing and searching through millions of them efficiently is what brought about <strong>vector databases</strong>.</p>

<hr />

<h2 id="3-vector-databases-how-they-differ">3. Vector Databases: How They Differ</h2>

<p>Not all vector stores are built the same way.<br />
Some focus on scalability, others on analytics or simplicity.<br />
Each can be understood through the same layered lens used above.</p>

<table class="study-table">
  <thead>
    <tr>
      <th>System</th>
      <th>Implements</th>
      <th>Indexing (L2)</th>
      <th>Storage Layout (L1)</th>
      <th>Physical Storage (L0)</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Weaviate</strong></td>
      <td>L3–L0 (+ optional L4 modules)</td>
      <td>HNSW / DiskANN</td>
      <td>Custom KV schema</td>
      <td>Disk + S3 backup</td>
      <td>A full-featured vector database with built-in hybrid search and RAG extensions.</td>
    </tr>
    <tr>
      <td><strong>LanceDB</strong></td>
      <td>L3–L0</td>
      <td>IVF_FLAT / PQ (Arrow-native)</td>
      <td>Apache Arrow / Lance</td>
      <td>Local / S3</td>
      <td>Columnar and analytics-friendly, ideal for local or hybrid workloads.</td>
    </tr>
    <tr>
      <td><strong>ChromaDB</strong></td>
      <td>L3–L0</td>
      <td>FAISS / HNSW</td>
      <td>DuckDB / SQLite</td>
      <td>Local</td>
      <td>Lightweight and Python-first — great for experimentation and rapid prototyping.</td>
    </tr>
    <tr>
      <td><strong>S3 Vector Bucket</strong></td>
      <td>L3–L0 (managed)</td>
      <td>AWS-managed ANN</td>
      <td>Proprietary format</td>
      <td>S3</td>
      <td>Serverless and fully managed; indexing and scaling handled by AWS.</td>
    </tr>
    <tr>
      <td><strong>OpenSearch (KNN Plugin)</strong></td>
      <td>L3–L0 (Lucene-based)</td>
      <td>HNSW / IVF / PQ</td>
      <td>Lucene segments</td>
      <td>Disk / EBS</td>
      <td>Text-first search engine with added vector retrieval capabilities.</td>
    </tr>
  </tbody>
</table>

<p>Common indexing methods:</p>
<ul>
  <li><strong>HNSW</strong> – graph-based, high recall with good latency.</li>
  <li><strong>DiskANN</strong> – optimized for billion-scale datasets on disk.</li>
  <li><strong>IVF_FLAT / IVF_PQ</strong> – cluster-based approaches balancing memory and speed.</li>
  <li><strong>FAISS</strong> – a foundational library for many open-source vector stores.</li>
  <li><strong>AWS-managed ANN</strong> – a proprietary, abstracted approach used in serverless systems.</li>
</ul>

<hr />

<h2 id="4-from-storage-to-understanding">4. From Storage to Understanding</h2>

<p>Once the data is stored and indexed, the next challenge is orchestration — how to retrieve and reason over it.</p>

<table class="study-table">
  <thead>
    <tr>
      <th>System</th>
      <th>L0</th>
      <th>L1</th>
      <th>L2</th>
      <th>L3</th>
      <th>L4</th>
      <th>L5</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Weaviate</strong></td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅ (auto-embed, hybrid, rerank, “generative” plugins)</td>
      <td>❌</td>
      <td>Has optional L4 modules but relies on external LLMs for reasoning.</td>
    </tr>
    <tr>
      <td><strong>Pinecone</strong></td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
      <td>Pure vector database; bring your own orchestration and reasoning layers.</td>
    </tr>
    <tr>
      <td><strong>LanceDB</strong></td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>Minimal</td>
      <td>❌</td>
      <td>Focused on analytics; orchestration handled externally.</td>
    </tr>
    <tr>
      <td><strong>ChromaDB</strong></td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>Light</td>
      <td>❌</td>
      <td>Great for quick RAG prototypes via LangChain or LlamaIndex.</td>
    </tr>
    <tr>
      <td><strong>OpenSearch (KNN)</strong></td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>Hybrid keyword + vector</td>
      <td>❌</td>
      <td>Adds ANN to a text-based search engine.</td>
    </tr>
    <tr>
      <td><strong>Amazon Kendra</strong></td>
      <td>Managed</td>
      <td>Managed</td>
      <td>Managed</td>
      <td>Managed</td>
      <td>✅</td>
      <td>❌*</td>
      <td>A managed retrieval system; for generation, pair with Bedrock or another LLM.</td>
    </tr>
    <tr>
      <td><strong>LangChain</strong></td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>✅</td>
      <td>✅</td>
      <td>Framework that orchestrates retrieval (L4) and reasoning (L5) across data sources.</td>
    </tr>
    <tr>
      <td><strong>LlamaIndex</strong></td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>✅</td>
      <td>✅</td>
      <td>Similar to LangChain; adds graph-based indexing and composability.</td>
    </tr>
    <tr>
      <td><strong>Bedrock / OpenAI / Claude / Gemini</strong></td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>✅</td>
      <td>Pure reasoning layer — uses retrieved context to generate answers.</td>
    </tr>
  </tbody>
</table>

<p>“Managed” means the internal indexing and storage details are not visible to the user.</p>

<hr />

<h2 id="5-e2e-flow">5. E2E Flow</h2>

<h3 id="ingestion-pipeline">Ingestion Pipeline</h3>
<ul>
  <li>Vector Store (L0–L3) handles the upserts and index commits.</li>
  <li>L4 performs connectors, chunking, embedding, and ACL registration.</li>
  <li>Metadata goes to a metadata store for filters, facets, and citations.</li>
</ul>

<div class="image-wrapper">
  <img src="./assets/kb_ingestion_pipeline.png" alt="KB Ingestion Pipeline" class="modal-trigger" />
  <div class="diagram-caption" data-snippet-id="kb-ingestion-snippet">
    🖼️ KB - Ingestion Pipeline Example 
  </div>
    <!-- Keep your PlantUML raw here -->
  <script type="text/plain" id="kb-ingestion-snippet">
@startuml
title Add Document to Knowledgebase (Ingestion)

autonumber
actor Producer as U
participant "L4 Orchestrator\n(ingestion service)" as L4
participant "Connector\n(S3/Drive/HTTP)" as Conn
participant "Chunker\n(splitter/cleaner)" as Chunker
participant "Embedding Model\n(encoder)" as Embed
participant "Vector Store\n(L0–L3)" as VS
participant "Metadata Store\n(SQL/Doc/Index)" as Meta
participant "ACL/Policy\n(enforcement)" as ACL

U -> L4: Submit document reference / upload
L4 -> Conn: Fetch raw bytes
Conn --> L4: Bytes/stream

L4 -> Chunker: Normalize + chunk (size/overlap)
Chunker --> L4: Chunks [{text, attrs}]

loop for each chunk
  L4 -> Embed: Encode text → vector
  Embed --> L4: vector[d]
  L4 -> VS: upsert({id, vector, metadata-ref})
  L4 -> Meta: upsert({id, doc_id, text, attrs})
end

L4 -> ACL: Register permissions (owners, groups, tags)
ACL --> L4: OK

L4 -> VS: Optimize/commit index (async allowed)
VS --> L4: OK

L4 --> U: Ingestion complete {doc_id, chunk_count}
@enduml

  </script>
</div>

<h3 id="query-the-knowledgebase-retrieval-orchestration--llm">Query the knowledgebase (retrieval orchestration + LLM)</h3>

<p>In this sequence, the LLM (L5) is drawn directly beside the User because it’s the layer the user interacts with — the conversational or reasoning interface.</p>

<p>Conceptually, however, L5 depends on L4: the orchestrator (L4) handles retrieval, embeddings, reranking, filtering, and context assembly before the LLM can reason over it.</p>

<p>In other words, L4 prepares the knowledge, and L5 expresses it.
The Vector Store (L0–L3) remains purely a retrieval substrate — it stores, indexes, and returns vectors, but performs no reasoning or synthesis.</p>

<div class="image-wrapper">
  <img src="./assets/kb_llm_query.png" alt="KB Query Pipeline" class="modal-trigger" />
  <div class="diagram-caption" data-snippet-id="kb-query-snippet">
    🖼️ KB - Query Pipeline Example 
  </div>
    <!-- Keep your PlantUML raw here -->
  <script type="text/plain" id="kb-query-snippet">
@startuml
title Query Knowledgebase (LLM next to User; L4 orchestrates retrieval)

autonumber
actor User as U
participant "LLM (L5)\n(reasoning/generation)" as LLM
participant "L4 Orchestrator\n(query service)" as L4
participant "Embedding Model\n(query encoder)" as EmbedQ
participant "Vector Store\n(L0–L3)" as VS
participant "Keyword Index\n(BM25/OpenSearch)" as KW
participant "Reranker\n(cross-encoder)" as Rerank
participant "Policy/ACL Filter" as ACL
participant "Context Builder\n(citations/dedupe)" as Ctx
participant "Cache\n(answer/context)" as Cache

U -> L4: Ask question (natural language)

opt optional query rewrite using LLM
  L4 -> LLM: Rewrite/expand query (synonyms, entities)
  LLM --> L4: Rewritten query
end

L4 -> EmbedQ: Encode query → vector_q
EmbedQ --> L4: vector_q

par hybrid retrieval
  L4 -> VS: ANN search(vector_q, k, filters)
  VS --> L4: Top-k by similarity
  L4 -> KW: Keyword/BM25 search(query, k)
  KW --> L4: Top-k lexical
end

L4 -> Rerank: Cross-encode merged candidates
Rerank --> L4: Reranked list

L4 -> ACL: Filter by user permissions
ACL --> L4: Permitted items

L4 -> Ctx: Build prompt context (dedupe, window, citations)
Ctx --> L4: Context blocks

alt cache hit
  L4 -> Cache: Lookup(query hash, scope)
  Cache --> L4: Answer/context
else cache miss
  L4 -> LLM: Prompt = {instructions, query, context}
  LLM --> L4: Answer + citations
  L4 -> Cache: Store(answer/context, TTL)
end

L4 --> U: Final answer + citations/snippets
@enduml


  </script>
</div>

    </article>
  </main>

  <div id="imageModal" class="image-modal">
  <div class="modal-content">
    <span class="modal-close">&times;</span>
    <button class="modal-nav modal-prev">&#8249;</button>
    <button class="modal-nav modal-next">&#8250;</button>
    <img id="modalImage" src="" alt="">
    <div id="modalCaption"></div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const modal = document.getElementById('imageModal');
  const modalImg = document.getElementById('modalImage');
  const modalCaption = document.getElementById('modalCaption');
  const modalClose = document.querySelector('.modal-close');
  const modalPrev = document.querySelector('.modal-prev');
  const modalNext = document.querySelector('.modal-next');

  const SCALE_STEP = 0.2;
  const MIN_SCALE = 1;
  const MAX_SCALE = 3;

  let modalImages = [];
  let currentIndex = -1;
  let currentScale = MIN_SCALE;
  let translateX = 0;
  let translateY = 0;
  let isDragging = false;
  let isTouchDragging = false;
  let isPinching = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let pinchStartDistance = 0;
  let pinchStartScale = MIN_SCALE;
  let transitionTimeout;

  function refreshModalImages() {
    modalImages = Array.from(document.querySelectorAll('.modal-trigger'));
  }

  function applyTransform(withTransition = false) {
    if (currentScale <= MIN_SCALE) {
      currentScale = MIN_SCALE;
      translateX = 0;
      translateY = 0;
    }

    if (transitionTimeout) {
      clearTimeout(transitionTimeout);
      transitionTimeout = null;
    }

    modalImg.style.transition = withTransition ? 'transform 0.15s ease' : 'none';
    modalImg.style.transform = `translate(${translateX}px, ${translateY}px) scale(${currentScale})`;
    modalImg.style.cursor = currentScale > MIN_SCALE
      ? (isDragging || isTouchDragging ? 'grabbing' : 'grab')
      : 'auto';

    if (withTransition) {
      transitionTimeout = setTimeout(() => {
        modalImg.style.transition = 'none';
      }, 160);
    }
  }

  function resetTransform() {
    currentScale = MIN_SCALE;
    translateX = 0;
    translateY = 0;
    applyTransform(false);
  }

  function getDistance(touch1, touch2) {
    return Math.hypot(
      touch1.clientX - touch2.clientX,
      touch1.clientY - touch2.clientY
    );
  }

  function openModalAtIndex(index) {
    refreshModalImages();

    if (!modalImages.length) {
      return;
    }

    if (index < 0) {
      index = modalImages.length - 1;
    } else if (index >= modalImages.length) {
      index = 0;
    }

    const target = modalImages[index];
    if (!target) {
      return;
    }

    currentIndex = index;
    const src = target.dataset.modalSrc || target.src;
    const caption = target.getAttribute('data-caption') || target.alt;

    modalImg.src = src;
    modalCaption.textContent = caption || '';
    modal.classList.add('show');
    document.body.style.overflow = 'hidden';
    resetTransform();
  }

  function closeModal() {
    if (!modal.classList.contains('show')) {
      return;
    }
    modal.classList.remove('show');
    document.body.style.overflow = '';
    currentIndex = -1;
    isDragging = false;
    isTouchDragging = false;
    isPinching = false;
    resetTransform();
  }

  refreshModalImages();

  modalImg.addEventListener('dragstart', event => event.preventDefault());

  document.addEventListener('click', event => {
    const trigger = event.target.closest('.modal-trigger');
    if (!trigger) {
      return;
    }

    event.preventDefault();
    refreshModalImages();
    const index = modalImages.indexOf(trigger);
    openModalAtIndex(index > -1 ? index : 0);
  });

  modalClose?.addEventListener('click', closeModal);

  modal.addEventListener('click', event => {
    if (event.target === modal) {
      closeModal();
    }
  });

  document.addEventListener('keydown', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    switch (event.key) {
      case 'Escape':
        closeModal();
        break;
      case 'ArrowLeft':
        event.preventDefault();
        openModalAtIndex(currentIndex - 1);
        break;
      case 'ArrowRight':
        event.preventDefault();
        openModalAtIndex(currentIndex + 1);
        break;
      case '+':
      case '=':
        event.preventDefault();
        currentScale = Math.min(MAX_SCALE, currentScale + SCALE_STEP);
        applyTransform(true);
        break;
      case '-':
        event.preventDefault();
        currentScale = Math.max(MIN_SCALE, currentScale - SCALE_STEP);
        applyTransform(true);
        break;
      case '0':
        event.preventDefault();
        resetTransform();
        applyTransform(true);
        break;
      default:
        break;
    }
  });

  modal.addEventListener('wheel', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    event.preventDefault();
    const delta = event.deltaY > 0 ? -SCALE_STEP : SCALE_STEP;
    const nextScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, currentScale + delta));

    if (nextScale === currentScale) {
      return;
    }

    currentScale = nextScale;
    applyTransform(true);
  }, { passive: false });

  if (modalPrev) {
    modalPrev.addEventListener('click', event => {
      event.preventDefault();
      if (currentIndex === -1) {
        return;
      }
      openModalAtIndex(currentIndex - 1);
    });
  }

  if (modalNext) {
    modalNext.addEventListener('click', event => {
      event.preventDefault();
      if (currentIndex === -1) {
        return;
      }
      openModalAtIndex(currentIndex + 1);
    });
  }

  modalImg.addEventListener('mousedown', event => {
    if (!modal.classList.contains('show') || currentScale <= MIN_SCALE) {
      return;
    }

    event.preventDefault();
    isDragging = true;
    dragStartX = event.clientX;
    dragStartY = event.clientY;
    modalImg.style.cursor = 'grabbing';
  });

  document.addEventListener('mousemove', event => {
    if (!isDragging) {
      return;
    }

    event.preventDefault();
    translateX += event.clientX - dragStartX;
    translateY += event.clientY - dragStartY;
    dragStartX = event.clientX;
    dragStartY = event.clientY;
    applyTransform(false);
  });

  document.addEventListener('mouseup', () => {
    if (!isDragging) {
      return;
    }
    isDragging = false;
    modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
  });

  modalImg.addEventListener('touchstart', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (event.touches.length === 1 && currentScale > MIN_SCALE) {
      event.preventDefault();
      isTouchDragging = true;
      dragStartX = event.touches[0].clientX;
      dragStartY = event.touches[0].clientY;
      modalImg.style.cursor = 'grabbing';
    } else if (event.touches.length === 2) {
      event.preventDefault();
      isTouchDragging = false;
      isPinching = true;
      pinchStartDistance = getDistance(event.touches[0], event.touches[1]);
      pinchStartScale = currentScale;
      modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
    }
  }, { passive: false });

  modalImg.addEventListener('touchmove', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (isPinching && event.touches.length === 2) {
      event.preventDefault();
      const distance = getDistance(event.touches[0], event.touches[1]);
      if (pinchStartDistance > 0) {
        const scaleRatio = distance / pinchStartDistance;
        currentScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, pinchStartScale * scaleRatio));
        applyTransform(false);
      }
    } else if (isTouchDragging && event.touches.length === 1) {
      event.preventDefault();
      translateX += event.touches[0].clientX - dragStartX;
      translateY += event.touches[0].clientY - dragStartY;
      dragStartX = event.touches[0].clientX;
      dragStartY = event.touches[0].clientY;
      applyTransform(false);
    }
  }, { passive: false });

  modalImg.addEventListener('touchend', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (event.touches.length === 0) {
      isTouchDragging = false;
      modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
    }

    if (event.touches.length < 2) {
      isPinching = false;
      pinchStartDistance = 0;
      pinchStartScale = currentScale;
    }
  });

  modalImg.addEventListener('touchcancel', () => {
    if (!modal.classList.contains('show')) {
      return;
    }

    isTouchDragging = false;
    isPinching = false;
    pinchStartDistance = 0;
    pinchStartScale = currentScale;
    modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
  });

  modal.addEventListener('touchend', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (event.target === modal && event.changedTouches.length === 1 && !isTouchDragging && !isPinching) {
      closeModal();
    }
  }, { passive: true });
});
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('[data-snippet-id]').forEach(caption => {
    const snippetId = caption.getAttribute('data-snippet-id');
    const snippetElement = document.getElementById(snippetId);

    if (snippetElement) {
      const content = snippetElement.textContent.replace(/"/g, '&quot;');
      caption.setAttribute('data-tooltip', content);
      caption.classList.add('diagram-caption');
    }
  });
});
</script>


  <!-- Floating Table of Contents -->
  <div id="floating-toc" class="floating-toc">
    <div class="toc-icon">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="8" y1="6" x2="21" y2="6"></line>
        <line x1="8" y1="12" x2="21" y2="12"></line>
        <line x1="8" y1="18" x2="21" y2="18"></line>
        <line x1="3" y1="6" x2="3.01" y2="6"></line>
        <line x1="3" y1="12" x2="3.01" y2="12"></line>
        <line x1="3" y1="18" x2="3.01" y2="18"></line>
      </svg>
    </div>
    <div class="toc-content">
      <div class="toc-header">
        <span>Contents</span>
        <button class="toc-close" aria-label="Close table of contents">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <nav class="toc-nav" id="toc-nav">
        <!-- Generated by JavaScript -->
      </nav>
    </div>
  </div>

  <footer class="site-footer">
    <span>© 2025 glucolte • </span>
    <a href="https://github.com/gLuColte/glucolte.github.io">source</a>
  </footer>

  <script>
    // Dark mode functionality
    function initDarkMode() {
      const toggle = document.getElementById('dark-mode-toggle');
      const body = document.body;
      
      // Check for saved theme preference or default to light mode
      const savedTheme = localStorage.getItem('theme');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      
      if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
        body.setAttribute('data-theme', 'dark');
      }
      
      // Toggle dark mode
      if (toggle) {
        toggle.addEventListener('click', function() {
          const currentTheme = body.getAttribute('data-theme');
          const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
          
          body.setAttribute('data-theme', newTheme);
          localStorage.setItem('theme', newTheme);
        });
      }
    }
    
    // Initialize dark mode immediately to prevent flash
    initDarkMode();
    
    // Initialize highlight.js and floating TOC after the DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      hljs.highlightAll();
      
      // Floating TOC functionality - only show on sub-study pages
      const floatingToc = document.getElementById('floating-toc');
      const tocNav = document.getElementById('toc-nav');
      const tocClose = document.querySelector('.toc-close');
      
      // Check if we're on a sub-study page (not the main study index)
      const isSubStudyPage = window.location.pathname !== '/study/' && 
                            window.location.pathname !== '/study' && 
                            window.location.pathname.startsWith('/study/');
      
      if (floatingToc && tocNav && isSubStudyPage) {
        // Generate TOC from headings
        function generateTOC() {
          const headings = document.querySelectorAll('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6');
          if (headings.length === 0) {
            floatingToc.style.display = 'none';
            return;
          }
          
          const tocList = document.createElement('ul');
          let currentLevel = 0;
          let currentList = tocList;
          const listStack = [tocList];
          
          headings.forEach((heading, index) => {
            const level = parseInt(heading.tagName.charAt(1));
            const id = heading.id || `heading-${index}`;
            
            // Ensure heading has an ID
            if (!heading.id) {
              heading.id = id;
            }
            
            // Create list item
            const listItem = document.createElement('li');
            const link = document.createElement('a');
            link.href = `#${id}`;
            link.textContent = heading.textContent.trim();
            link.addEventListener('click', function(e) {
              e.preventDefault();
              const targetElement = document.getElementById(id);
              if (targetElement) {
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                // Close TOC after clicking
                floatingToc.classList.remove('toc-open');
              }
            });
            
            listItem.appendChild(link);
            
            // Handle nesting
            if (level > currentLevel) {
              // Go deeper
              for (let i = currentLevel; i < level; i++) {
                const newList = document.createElement('ul');
                currentList.appendChild(newList);
                listStack.push(newList);
                currentList = newList;
              }
            } else if (level < currentLevel) {
              // Go shallower
              for (let i = currentLevel; i > level; i--) {
                listStack.pop();
                currentList = listStack[listStack.length - 1];
              }
            }
            
            currentList.appendChild(listItem);
            currentLevel = level;
          });
          
          tocNav.appendChild(tocList);
        }
        
        // Generate the TOC
        generateTOC();
        
        // Handle close button
        if (tocClose) {
          tocClose.addEventListener('click', function() {
            floatingToc.classList.remove('toc-open');
          });
        }
        
        // Handle click on icon to toggle
        const tocIcon = document.querySelector('.toc-icon');
        if (tocIcon) {
          tocIcon.addEventListener('click', function() {
            floatingToc.classList.toggle('toc-open');
          });
        }
        
        // Active section highlighting
        function updateActiveSection() {
          const headings = document.querySelectorAll('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6');
          const tocLinks = tocNav.querySelectorAll('a');
          
          // Remove active class from all links
          tocLinks.forEach(link => link.classList.remove('active'));
          
          // Find the current section
          let currentHeading = null;
          const scrollPosition = window.scrollY + 100; // Offset for better UX
          
          for (let i = headings.length - 1; i >= 0; i--) {
            const heading = headings[i];
            const headingTop = heading.offsetTop;
            
            if (headingTop <= scrollPosition) {
              currentHeading = heading;
              break;
            }
          }
          
          // Add active class to current section
          if (currentHeading) {
            const activeLink = tocNav.querySelector(`a[href="#${currentHeading.id}"]`);
            if (activeLink) {
              activeLink.classList.add('active');
            }
          }
        }
        
        // Update active section on scroll
        let scrollTimeout;
        window.addEventListener('scroll', function() {
          if (scrollTimeout) {
            clearTimeout(scrollTimeout);
          }
          scrollTimeout = setTimeout(updateActiveSection, 10);
        });
        
        // Initial update
        updateActiveSection();
      } else if (floatingToc && !isSubStudyPage) {
        // Hide floating TOC on main study page
        floatingToc.style.display = 'none';
      }
      
      // Legacy TOC functionality (for existing markdown TOCs)
      const toc = document.querySelector('#markdown-toc');
      if (toc) {
        // Hide the floating TOC if there's already a markdown TOC
        if (floatingToc) {
          floatingToc.style.display = 'none';
        }
        
        // Create TOC container with header
        const tocContainer = document.createElement('div');
        tocContainer.className = 'toc-container';
        tocContainer.style.cssText = `
          background: #f8fafc;
          border: 1px solid #e5e7eb;
          border-radius: 8px;
          padding: 16px;
          margin: 20px 0;
          position: relative;
        `;
        
        // Add TOC header
        const tocHeader = document.createElement('h3');
        tocHeader.textContent = 'Table of Contents';
        tocHeader.style.cssText = `
          margin: 0 0 12px 0;
          font-size: 16px;
          font-weight: 600;
          color: #374151;
        `;
        
        // Add back to top button
        const backToTopBtn = document.createElement('button');
        backToTopBtn.textContent = '↑ Top';
        backToTopBtn.style.cssText = `
          position: absolute;
          top: 12px;
          right: 12px;
          background: #ffffff;
          border: 1px solid #d1d5db;
          border-radius: 6px;
          padding: 4px 8px;
          font-size: 12px;
          cursor: pointer;
          color: #6b7280;
          transition: all 0.2s ease;
        `;
        
        // Add hover effect for back to top button
        backToTopBtn.addEventListener('mouseenter', function() {
          this.style.background = '#f3f4f6';
          this.style.color = '#374151';
        });
        
        backToTopBtn.addEventListener('mouseleave', function() {
          this.style.background = '#ffffff';
          this.style.color = '#6b7280';
        });
        
        // Back to top functionality
        backToTopBtn.addEventListener('click', function() {
          window.scrollTo({ top: 0, behavior: 'smooth' });
        });
        
        // Style the TOC list
        toc.style.cssText = `
          margin: 0;
          padding: 0;
          font-size: 14px;
          line-height: 1.5;
        `;
        
        // Insert header and button into container
        tocContainer.appendChild(tocHeader);
        tocContainer.appendChild(backToTopBtn);
        tocContainer.appendChild(toc);
        
        // Replace the original TOC with the new container
        toc.parentNode.insertBefore(tocContainer, toc);
        tocContainer.appendChild(toc);
        
        // Add smooth scrolling to TOC links
        const tocLinks = toc.querySelectorAll('a');
        tocLinks.forEach(link => {
          link.addEventListener('click', function(e) {
            e.preventDefault();
            const targetId = this.getAttribute('href').substring(1);
            const targetElement = document.getElementById(targetId);
            if (targetElement) {
              targetElement.scrollIntoView({ behavior: 'smooth' });
            }
          });
        });
      }
    });
  </script>
</body>
</html>
