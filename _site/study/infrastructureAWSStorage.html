<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>AWS Storage Services ¬∑ glucolte</title>
  <meta name="description" content="notes ‚Ä¢ principles ‚Ä¢ systems">
  <link rel="stylesheet" href="/assets/style.css">
  <link rel="stylesheet" href="/assets/study.css">
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/favicon.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>AWS Storage Services | glucolte</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="AWS Storage Services" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="notes ‚Ä¢ principles ‚Ä¢ systems" />
<meta property="og:description" content="notes ‚Ä¢ principles ‚Ä¢ systems" />
<link rel="canonical" href="http://localhost:4000/study/infrastructureAWSStorage" />
<meta property="og:url" content="http://localhost:4000/study/infrastructureAWSStorage" />
<meta property="og:site_name" content="glucolte" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="AWS Storage Services" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"notes ‚Ä¢ principles ‚Ä¢ systems","headline":"AWS Storage Services","url":"http://localhost:4000/study/infrastructureAWSStorage"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
  <header class="site-header">
  <a class="brand" href="/">glucolte</a>
  <nav class="nav">
    <a href="/principles">principles</a>
    <a href="/rules">rules</a>
    <a href="/stretches">stretches</a>
    <a href="/study/">study</a>
    <a href="/projects/">projects</a>
    <a href="/setup/">setup</a>
  </nav>
  <button id="dark-mode-toggle" class="dark-mode-toggle" aria-label="Toggle dark mode">
    <svg class="sun-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
    <svg class="moon-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
    </svg>
  </button>
</header>


  <main class="container">
    <article class="content">
      <h2 id="section-1-storage-building-blocks">1. Storage Building Blocks</h2>

<p>AWS exposes storage through three primary layers. Understanding how each layer writes to blocks helps when selecting the right service or designing migration paths.</p>

<table class="study-table">
<thead>
<tr>
<th>Layer</th>
<th>What It Exposes</th>
<th>How It Writes</th>
<th>Effect on Blocks</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Block Device</strong></td>
<td>Logical block addresses (LBA 0‚Ä¶n)</td>
<td>Direct I/O; write a 4 KB block at a time.</td>
<td>Overwrites the block exactly as requested; no metadata awareness.</td>
</tr>
<tr>
<td><strong>File System</strong></td>
<td>Files, directories, inodes, and metadata.</td>
<td>Splits files into metadata + data blocks.</td>
<td>Blocks interleave metadata and file payloads.</td>
</tr>
<tr>
<td><strong>Object Store</strong></td>
<td>Object = key + metadata + blob.</td>
<td>Stores metadata in an index, data in hidden chunks.</td>
<td>Objects fan out across multiple block devices; layout abstracted.</td>
</tr>
</tbody>
</table>

<div class="image-wrapper">
  <img src="./assets/storage_system.png" alt="storage_system" class="modal-trigger" data-caption="üß© Storage System" />
  <div class="diagram-caption" data-snippet-id="dedicated-tenancy-snippet">
    üß© Storage System
  </div>
  <script type="text/plain" id="dedicated-tenancy-snippet">
@startuml
title How applications interact with storage types

actor Application

participant "File System\n(NFS/SMB/Lustre)" as FILE
participant "Block Device\n(EBS)" as BLOCK
participant "Object Store\n(S3 API)" as OBJECT
participant "Physical Disk Blocks" as DISK

Application -> BLOCK: Read/write blocks\n(LBA addresses, sectors)
BLOCK -> DISK: Map to disk blocks

Application -> FILE: Read/write files\n(open/read/write/close)
FILE -> DISK: Convert to block operations

Application -> OBJECT: PUT/GET object\n(Key + Metadata)
OBJECT -> DISK: Store data as objects

@enduml
  </script>
</div>

<hr />

<h2 id="section-2-managed-file-services">2. Managed File Services</h2>

<p>AWS offers several turnkey file systems so lift-and-shift workloads do not require hand-built EC2 clusters. The three most common services cover Windows shares, HPC Lustre clusters, and general-purpose NFS for Linux.</p>

<h3 id="section-2-1-fsx-windows">2.1 Amazon FSx for Windows File Server</h3>

<ul>
  <li>Presents fully managed SMB shares with native Windows semantics (NTFS ACLs, SMB dialects, DFS Namespaces).</li>
  <li>Supports Volume Shadow Copy Service (VSS) so users can self-serve file-level restores.</li>
  <li>Integrates with self-managed Active Directory or AWS Managed Microsoft AD; you keep ownership of the domain join.</li>
  <li>Delivers multi-AZ scale-out options and the ability to lift traditional Windows file server workloads without standing up EC2 hosts.</li>
</ul>

<hr />

<h3 id="section-2-2-fsx-lustre">2.2 Amazon FSx for Lustre</h3>

<ul>
  <li>Purpose-built for Linux HPC workloads needing 100s of GB/s throughput and sub-millisecond latency.</li>
  <li>Two deployment modes:
    <ul>
      <li><strong>Scratch</strong>: no replication, temporary storage, 200 MB/s per TiB baseline; best for ephemeral HPC runs.</li>
      <li><strong>Persistent</strong>: 50/100/200 MB/s per TiB baseline with intra-AZ replication and auto-healing.</li>
    </ul>
  </li>
  <li>Metadata lives on Metadata Targets (MSTs); object data spreads across Object Storage Targets (OSTs).</li>
  <li>Minimum size 1.2 TiB (then 2.4 TiB increments). Larger filesystems add servers/disks for parallelism.</li>
  <li>Seamless S3 integration: link to an S3 bucket, lazily load objects into the file system, archive back to S3 via <code class="language-plaintext highlighter-rouge">hsm_archive</code>, and keep 0‚Äì35 day backups in S3.</li>
</ul>

<hr />

<h3 id="section-2-3-efs">2.3 Amazon Elastic File System (EFS)</h3>

<ul>
  <li>Managed NFSv4 storage for Linux instances (EC2, on-prem via DX/VPN).</li>
  <li>Mount targets expose private IPs per subnet/AZ; traffic never traverses the public internet.</li>
  <li>Supports POSIX permissions, security groups, and access via multiple instances simultaneously.</li>
  <li>Performance modes:
    <ul>
      <li><strong>General Purpose</strong> ‚Äì low-latency workloads.</li>
      <li><strong>Max I/O</strong> ‚Äì higher aggregate throughput and open file counts.</li>
    </ul>
  </li>
  <li>Throughput modes:
    <ul>
      <li><strong>Bursting</strong> ‚Äì scales with filesystem size.</li>
      <li><strong>Provisioned</strong> ‚Äì fixed MB/s regardless of stored data.</li>
    </ul>
  </li>
  <li>Storage classes: <strong>Standard</strong> and <strong>Infrequent Access (IA)</strong> with lifecycle policies moving cold files automatically.</li>
</ul>

<hr />

<h2 id="section-3-amazon-s3-core-concepts">3. Amazon S3 Core Concepts</h2>

<p>Simple Storage Service underpins most AWS architectures. The focus areas below keep cost, durability, and replication under control.</p>

<h3 id="section-3-1-cost-model">3.1 Cost Model</h3>

<p>S3 charges on three levers: storage (GB-month), requests (per 1,000 API calls), and data transfer out (per GB). Choosing the right storage class, lifecycle rules, and replication strategy is how to keep those levers predictable.</p>

<hr />

<h3 id="section-3-2-storage-classes">3.2 Storage Classes</h3>

<table class="study-table">
<thead>
<tr>
<th>Class</th>
<th>Durability &amp; Availability</th>
<th>Retrieval</th>
<th>Minimums</th>
<th>Best For</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Standard</strong></td>
<td>11 nines durability, multi-AZ availability.</td>
<td>Milliseconds, no retrieval fee.</td>
<td>None.</td>
<td>Hot data, frequently accessed, mission critical.</td>
</tr>
<tr>
<td><strong>Standard-IA</strong></td>
<td>Multi-AZ, same durability.</td>
<td>Milliseconds, per-GB retrieval fee.</td>
<td>30-day storage; 128 KB minimum charge.</td>
<td>Long-lived but infrequently accessed data.</td>
</tr>
<tr>
<td><strong>One Zone-IA</strong></td>
<td>Single AZ (cost optimized).</td>
<td>Milliseconds, per-GB retrieval fee.</td>
<td>30-day storage; 128 KB minimum charge.</td>
<td>Re-creatable data that can tolerate AZ loss.</td>
</tr>
<tr>
<td><strong>Glacier Instant Retrieval</strong></td>
<td>Multi-AZ durability.</td>
<td>Milliseconds, higher retrieval fee.</td>
<td>90-day storage minimum.</td>
<td>Quarterly access patterns with instant retrieval needs.</td>
</tr>
<tr>
<td><strong>Glacier Flexible Retrieval</strong></td>
<td>Multi-AZ, cold archive.</td>
<td>Minutes to hours per retrieval job.</td>
<td>90-day storage minimum.</td>
<td>Archival data; bulk retrievals acceptable.</td>
</tr>
<tr>
<td><strong>Glacier Deep Archive</strong></td>
<td>Multi-AZ, lowest cost.</td>
<td>12‚Äì48 hours.</td>
<td>180-day storage minimum.</td>
<td>Compliance archives rarely accessed.</td>
</tr>
</tbody>
</table>

<hr />

<h3 id="section-3-3-intelligent-tiering">3.3 Intelligent-Tiering</h3>

<ul>
  <li>Monitors objects for access and automatically moves them:
    <ul>
      <li>&lt;30 days ‚Üí Frequent Access tier.</li>
      <li>30+ days idle ‚Üí Infrequent Access tier.</li>
      <li>90‚Äì270 days idle ‚Üí Archive Instant Access tier.</li>
      <li>180‚Äì730 days idle ‚Üí Deep Archive Access tier.</li>
    </ul>
  </li>
  <li>No retrieval fees; small monitoring charge per object.</li>
  <li>Ideal when access patterns are unpredictable or when manual lifecycle rules become complex.</li>
</ul>

<hr />

<h3 id="section-3-4-lifecycle-policies">3.4 Lifecycle Policies</h3>

<ul>
  <li>Transition actions move data between classes; minimum 30 days before any transition and another 30 days before moving to archive classes.</li>
  <li>Expiration actions permanently delete objects or previous versions.</li>
  <li>Rules can target prefixes or tags; multiple rules handle sequential transitions (e.g., Standard ‚Üí Standard-IA ‚Üí Glacier Flexible).</li>
</ul>

<hr />

<h3 id="section-3-5-replication">3.5 Replication (SRR/CRR)</h3>

<ul>
  <li>Requires versioning on both source and destination buckets; not retroactive.</li>
  <li>IAM role grants S3 permission to replicate via HTTPS; cross-account destinations need a trusting bucket policy.</li>
  <li>Options:
    <ul>
      <li><strong>Same-Region Replication (SRR)</strong> ‚Äì log aggregation, sovereign backups, multi-environment sync.</li>
      <li><strong>Cross-Region Replication (CRR)</strong> ‚Äì global resiliency, latency reduction, geo-compliance.</li>
    </ul>
  </li>
  <li>Settings:
    <ul>
      <li>Filter objects (prefix, tags).</li>
      <li>Override storage class at destination.</li>
      <li>Define object ownership and replication metrics (including Replication Time Control for SLA-backed copy times).</li>
    </ul>
  </li>
  <li>Limitations: Glacier/Deep Archive objects and bucket-level events do not replicate.</li>
</ul>

<hr />

<h2 id="section-4-s3-security-data">4. S3 Security &amp; Data Management</h2>

<p>After the storage class and lifecycle decisions are made, attention shifts to encryption, secure sharing, and data-classification tooling around S3.</p>

<h3 id="section-4-1-encryption">4.1 Encryption Choices</h3>

<ul>
  <li><strong>SSE-S3</strong> ‚Äì S3 manages keys (AES-256); simplest option.</li>
  <li><strong>SSE-KMS</strong> ‚Äì use AWS KMS CMKs for per-object DEKs, fine-grained access control, auditing, and rotation.</li>
  <li><strong>SSE-C</strong> ‚Äì bring your own keys in the request; AWS never stores them.</li>
  <li><strong>Client-side encryption</strong> ‚Äì encrypt before upload; S3 stores ciphertext only.</li>
  <li><strong>Bucket Keys</strong> ‚Äì cache a time-limited KMS key per bucket to reduce KMS API calls for SSE-KMS workloads; shows up as bucket events in CloudTrail and works with replication.</li>
</ul>

<hr />

<h3 id="section-4-2-presigned-urls">4.2 Presigned URLs</h3>

<ul>
  <li>Provide time-bound, signed access for GET or PUT against otherwise private objects.</li>
  <li>Permissions inherit from the identity that generated the URL; ‚ÄúAccessDenied‚Äù often indicates the signer lacked permissions.</li>
  <li>Avoid using short-lived assumed roles to generate URLs‚Äîwhen the role session expires, the URL breaks.</li>
</ul>

<hr />

<h3 id="section-4-3-select">4.3 S3 &amp; Glacier Select</h3>

<ul>
  <li>Run SQL-like queries against CSV, JSON, or Parquet objects directly in S3/Glacier to retrieve only the filtered data.</li>
  <li>Reduces data transfer and client-side processing when dealing with multi-GB objects.</li>
</ul>

<hr />

<h3 id="section-4-4-access-points">4.4 S3 Access Points</h3>

<ul>
  <li>Create dedicated endpoints (with their own policies and network controls) per application, team, or VPC instead of using a single bucket policy.</li>
  <li>Each access point can restrict prefixes, require VPC origins, or expose a public hostname.</li>
</ul>

<hr />

<h3 id="section-4-5-object-lock">4.5 Object Lock</h3>

<ul>
  <li>Enables WORM behavior on a per-object-version basis; requires versioning and cannot be disabled once enabled on a bucket.</li>
  <li>Retention modes:
    <ul>
      <li><strong>Compliance</strong> ‚Äì immutable until the retention date; even the root user cannot shorten it.</li>
      <li><strong>Governance</strong> ‚Äì privileged users with <code class="language-plaintext highlighter-rouge">s3:BypassGovernanceRetention</code> can adjust retention.</li>
    </ul>
  </li>
  <li><strong>Legal holds</strong> ‚Äì binary on/off flag (<code class="language-plaintext highlighter-rouge">S3:PutObjectLegalHold</code>) with no expiry until removed.</li>
</ul>

<hr />

<h3 id="section-4-6-macie">4.6 Amazon Macie</h3>

<ul>
  <li>Data security service that inspects S3 for PII/PHI/financial data using managed or custom identifiers.</li>
  <li>Findings categories:
    <ul>
      <li><strong>Policy</strong> ‚Äì encryption disabled, public access enabled, etc.</li>
      <li><strong>Sensitive data</strong> ‚Äì exposed credentials, personal identifiers, multi-type matches.</li>
    </ul>
  </li>
  <li>Integrates with Security Hub and EventBridge for automated response workflows and central management across accounts.</li>
</ul>

<hr />

<h2 id="section-5-block-ephemeral">5. Block &amp; Ephemeral Storage</h2>

<p>EC2 workloads still rely on block devices for boot/root volumes and ultra-low-latency scratch space. This section summarizes the available performance tiers and when to pick each one.</p>

<h3 id="section-5-1-ssd-ebs">5.1 SSD-backed EBS Volumes</h3>

<table class="study-table">
<thead>
<tr>
<th>Type</th>
<th>IOPS Model</th>
<th>Baseline / Burst</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>gp2</strong></td>
<td>3 IOPS/GB (minimum 100); credit bucket.</td>
<td>Up to 3,000 IOPS burst; 16,000 max.</td>
<td>Great for boot disks and general workloads; must manage I/O credits.</td>
</tr>
<tr>
<td><strong>gp3</strong></td>
<td>Provision IOPS independently of size.</td>
<td>3,000 IOPS &amp; 125 MiB/s baseline; scale to 16,000 IOPS &amp; 1,000 MiB/s.</td>
<td>20% cheaper than gp2; combines gp2 flexibility with io1 features.</td>
</tr>
<tr>
<td><strong>io1/io2</strong></td>
<td>Provision up to 64,000 IOPS (256,000 with io2 Block Express).</td>
<td>Consistent low latency; up to 4 GB/s throughput on Block Express.</td>
<td>Use for low-latency databases; io2 offers 500 IOPS/GB durability SLA.</td>
</tr>
</tbody>
</table>

<hr />

<h3 id="section-5-2-hdd-ebs">5.2 HDD-backed EBS Volumes</h3>

<table class="study-table">
<thead>
<tr>
<th>Type</th>
<th>Workload</th>
<th>Baseline</th>
<th>Burst</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>st1 (Throughput Optimized)</strong></td>
<td>Sequential, frequently accessed data.</td>
<td>40 MB/s per TiB.</td>
<td>Up to 250 MB/s per TiB (max 500 MB/s).</td>
<td>Big data, ETL streams, logs.</td>
</tr>
<tr>
<td><strong>sc1 (Cold HDD)</strong></td>
<td>Infrequently accessed data.</td>
<td>12 MB/s per TiB.</td>
<td>Up to 80 MB/s per TiB (max 250 MB/s).</td>
<td>Lowest-cost magnetic storage for archives.</td>
</tr>
</tbody>
</table>

<hr />

<h3 id="section-5-3-instance-store-vs-ebs">5.3 Instance Store vs. EBS</h3>

<ul>
  <li><strong>Instance Store</strong> ‚Äì physically attached NVMe/SATA on the host; millions of IOPS, but data disappears when the instance stops, terminates, or the host fails.</li>
  <li><strong>EBS</strong> ‚Äì network-attached block storage; persistent, resilient, snapshot-capable, and independent of the instance lifecycle.</li>
  <li>Selection guidance:
    <ul>
      <li>Persistence/resilience/isolation ‚Üí choose EBS.</li>
      <li>Ultra-low latency scratch space or &gt;260K IOPS ‚Üí choose instance store (often striped RAID-0 for even higher throughput).</li>
      <li>Cost-sensitive streaming workloads ‚Üí HDD-based EBS (st1/sc1).</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="section-6-transfer-family">6. AWS Transfer Family</h2>

<p>Managed service for lifting traditional file-transfer workflows into S3 or EFS without running custom servers.</p>

<table class="study-table">
<thead>
<tr>
<th>Protocol</th>
<th>Use Case</th>
<th>Identity Options</th>
<th>Endpoint Modes</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SFTP</strong></td>
<td>Secure shell file transfers (most common).</td>
<td>Service-managed, AWS Directory Service, or custom IdP.</td>
<td>Public, VPC (internet-facing with Elastic IP), or VPC-internal only.</td>
</tr>
<tr>
<td><strong>FTPS</strong></td>
<td>FTP over TLS for partners needing TLS termination.</td>
<td>Directory Service or custom IdP.</td>
<td>Public or VPC modes.</td>
</tr>
<tr>
<td><strong>FTP</strong></td>
<td>Legacy internal-only transfers.</td>
<td>Directory Service or custom IdP.</td>
<td>VPC-internal mode only.</td>
</tr>
<tr>
<td><strong>AS2</strong></td>
<td>Structured B2B document exchange.</td>
<td>Service-managed users.</td>
<td>Public endpoints.</td>
</tr>
</tbody>
</table>

<p>Key traits:</p>

<ul>
  <li>Multi-AZ architecture delivers resilience without patching or capacity management.</li>
  <li>Pay by the hour for the server endpoint plus standard S3/EFS request and transfer charges; no upfront fees.</li>
  <li>Works with DX/VPN for private ingestion pipelines.</li>
</ul>

<hr />

<h2 id="section-4-exam-reminders">4. Exam Reminders</h2>

<ul>
  <li><strong>EBS vs instance store</strong> ‚Äì EBS is persistent, snapshot-capable, and survives stop/start; instance store is ephemeral and tied to host lifecycle.</li>
  <li><strong>Snapshots</strong> ‚Äì incremental, stored in S3, cross-Region copyable. Use them for PITR or as seeds for new volumes.</li>
  <li><strong>RAID quick sheet</strong> ‚Äì 0 (striping, no redundancy), 1 (mirroring), 5 (1 disk fault tolerance), 6 (2 disks), 10 (striped mirrors), 50/60 (stacked). Hot spares auto-replace failed disks.</li>
  <li><strong>RDS</strong> ‚Äì snapshots stored in S3; cross-Region replica promotion triggers reboot; deletion protection stops accidental wipes but is not a backup.</li>
  <li><strong>Redshift</strong> ‚Äì enable snapshot copy grants when copying encrypted snapshots to another Region (destination CMK required).</li>
  <li><strong>FSx for Lustre</strong> ‚Äì high-performance POSIX file system with manual resize; integrate with S3 via import/export.</li>
  <li><strong>Storage Gateway restores</strong> ‚Äì to recover a volume, restore snapshot ‚Üí create EBS volume ‚Üí attach to EC2; there is no direct S3‚ÜíEC2 attach.</li>
  <li><strong>S3 SSE-C headers</strong> ‚Äì clients must send <code class="language-plaintext highlighter-rouge">x-amz-server-side-encryption-customer-algorithm</code> (usually <code class="language-plaintext highlighter-rouge">AES256</code>) and <code class="language-plaintext highlighter-rouge">x-amz-server-side-encryption-customer-key-MD5</code> (Base64 MD5 of the key).</li>
  <li><strong>S3 versioning</strong> ‚Äì existing objects receive <code class="language-plaintext highlighter-rouge">VersionId = null</code> when enabling versioning. Design prefixes for search/browse patterns since S3 has limited query capabilities.</li>
  <li><strong>Aurora fast restart</strong> ‚Äì buffer cache kept outside database process; restarts often finish in under a minute without full redo replay.</li>
  <li><strong>AWS Backup</strong> ‚Äì centralized service to define backup plans/schedules across EBS, RDS, DynamoDB, EFS, FSx, Storage Gateway, and on-prem connectors. Monitor backup jobs and compliance from a single console.</li>
  <li><strong>Storage Gateway (iSCSI)</strong> ‚Äì uses CHAP for initiator authentication, protecting against replay attacks before accessing cached/volume targets.</li>
</ul>

<hr />

    </article>
  </main>

  <div id="imageModal" class="image-modal">
  <div class="modal-content">
    <span class="modal-close">&times;</span>
    <button class="modal-nav modal-prev">&#8249;</button>
    <button class="modal-nav modal-next">&#8250;</button>
    <img id="modalImage" src="" alt="">
    <div id="modalCaption"></div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const modal = document.getElementById('imageModal');
  const modalImg = document.getElementById('modalImage');
  const modalCaption = document.getElementById('modalCaption');
  const modalClose = document.querySelector('.modal-close');
  const modalPrev = document.querySelector('.modal-prev');
  const modalNext = document.querySelector('.modal-next');

  const SCALE_STEP = 0.2;
  const MIN_SCALE = 1;
  const MAX_SCALE = 3;

  let modalImages = [];
  let currentIndex = -1;
  let currentScale = MIN_SCALE;
  let translateX = 0;
  let translateY = 0;
  let isDragging = false;
  let isTouchDragging = false;
  let isPinching = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let pinchStartDistance = 0;
  let pinchStartScale = MIN_SCALE;
  let transitionTimeout;

  function refreshModalImages() {
    modalImages = Array.from(document.querySelectorAll('.modal-trigger'));
  }

  function applyTransform(withTransition = false) {
    if (currentScale <= MIN_SCALE) {
      currentScale = MIN_SCALE;
      translateX = 0;
      translateY = 0;
    }

    if (transitionTimeout) {
      clearTimeout(transitionTimeout);
      transitionTimeout = null;
    }

    modalImg.style.transition = withTransition ? 'transform 0.15s ease' : 'none';
    modalImg.style.transform = `translate(${translateX}px, ${translateY}px) scale(${currentScale})`;
    modalImg.style.cursor = currentScale > MIN_SCALE
      ? (isDragging || isTouchDragging ? 'grabbing' : 'grab')
      : 'auto';

    if (withTransition) {
      transitionTimeout = setTimeout(() => {
        modalImg.style.transition = 'none';
      }, 160);
    }
  }

  function resetTransform() {
    currentScale = MIN_SCALE;
    translateX = 0;
    translateY = 0;
    applyTransform(false);
  }

  function getDistance(touch1, touch2) {
    return Math.hypot(
      touch1.clientX - touch2.clientX,
      touch1.clientY - touch2.clientY
    );
  }

  function openModalAtIndex(index) {
    refreshModalImages();

    if (!modalImages.length) {
      return;
    }

    if (index < 0) {
      index = modalImages.length - 1;
    } else if (index >= modalImages.length) {
      index = 0;
    }

    const target = modalImages[index];
    if (!target) {
      return;
    }

    currentIndex = index;
    const src = target.dataset.modalSrc || target.src;
    const caption = target.getAttribute('data-caption') || target.alt;

    modalImg.src = src;
    modalCaption.textContent = caption || '';
    modal.classList.add('show');
    document.body.style.overflow = 'hidden';
    resetTransform();
  }

  function closeModal() {
    if (!modal.classList.contains('show')) {
      return;
    }
    modal.classList.remove('show');
    document.body.style.overflow = '';
    currentIndex = -1;
    isDragging = false;
    isTouchDragging = false;
    isPinching = false;
    resetTransform();
  }

  refreshModalImages();

  modalImg.addEventListener('dragstart', event => event.preventDefault());

  document.addEventListener('click', event => {
    const trigger = event.target.closest('.modal-trigger');
    if (!trigger) {
      return;
    }

    event.preventDefault();
    refreshModalImages();
    const index = modalImages.indexOf(trigger);
    openModalAtIndex(index > -1 ? index : 0);
  });

  modalClose?.addEventListener('click', closeModal);

  modal.addEventListener('click', event => {
    if (event.target === modal) {
      closeModal();
    }
  });

  document.addEventListener('keydown', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    switch (event.key) {
      case 'Escape':
        closeModal();
        break;
      case 'ArrowLeft':
        event.preventDefault();
        openModalAtIndex(currentIndex - 1);
        break;
      case 'ArrowRight':
        event.preventDefault();
        openModalAtIndex(currentIndex + 1);
        break;
      case '+':
      case '=':
        event.preventDefault();
        currentScale = Math.min(MAX_SCALE, currentScale + SCALE_STEP);
        applyTransform(true);
        break;
      case '-':
        event.preventDefault();
        currentScale = Math.max(MIN_SCALE, currentScale - SCALE_STEP);
        applyTransform(true);
        break;
      case '0':
        event.preventDefault();
        resetTransform();
        applyTransform(true);
        break;
      default:
        break;
    }
  });

  modal.addEventListener('wheel', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    event.preventDefault();
    const delta = event.deltaY > 0 ? -SCALE_STEP : SCALE_STEP;
    const nextScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, currentScale + delta));

    if (nextScale === currentScale) {
      return;
    }

    currentScale = nextScale;
    applyTransform(true);
  }, { passive: false });

  if (modalPrev) {
    modalPrev.addEventListener('click', event => {
      event.preventDefault();
      if (currentIndex === -1) {
        return;
      }
      openModalAtIndex(currentIndex - 1);
    });
  }

  if (modalNext) {
    modalNext.addEventListener('click', event => {
      event.preventDefault();
      if (currentIndex === -1) {
        return;
      }
      openModalAtIndex(currentIndex + 1);
    });
  }

  modalImg.addEventListener('mousedown', event => {
    if (!modal.classList.contains('show') || currentScale <= MIN_SCALE) {
      return;
    }

    event.preventDefault();
    isDragging = true;
    dragStartX = event.clientX;
    dragStartY = event.clientY;
    modalImg.style.cursor = 'grabbing';
  });

  document.addEventListener('mousemove', event => {
    if (!isDragging) {
      return;
    }

    event.preventDefault();
    translateX += event.clientX - dragStartX;
    translateY += event.clientY - dragStartY;
    dragStartX = event.clientX;
    dragStartY = event.clientY;
    applyTransform(false);
  });

  document.addEventListener('mouseup', () => {
    if (!isDragging) {
      return;
    }
    isDragging = false;
    modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
  });

  modalImg.addEventListener('touchstart', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (event.touches.length === 1 && currentScale > MIN_SCALE) {
      event.preventDefault();
      isTouchDragging = true;
      dragStartX = event.touches[0].clientX;
      dragStartY = event.touches[0].clientY;
      modalImg.style.cursor = 'grabbing';
    } else if (event.touches.length === 2) {
      event.preventDefault();
      isTouchDragging = false;
      isPinching = true;
      pinchStartDistance = getDistance(event.touches[0], event.touches[1]);
      pinchStartScale = currentScale;
      modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
    }
  }, { passive: false });

  modalImg.addEventListener('touchmove', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (isPinching && event.touches.length === 2) {
      event.preventDefault();
      const distance = getDistance(event.touches[0], event.touches[1]);
      if (pinchStartDistance > 0) {
        const scaleRatio = distance / pinchStartDistance;
        currentScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, pinchStartScale * scaleRatio));
        applyTransform(false);
      }
    } else if (isTouchDragging && event.touches.length === 1) {
      event.preventDefault();
      translateX += event.touches[0].clientX - dragStartX;
      translateY += event.touches[0].clientY - dragStartY;
      dragStartX = event.touches[0].clientX;
      dragStartY = event.touches[0].clientY;
      applyTransform(false);
    }
  }, { passive: false });

  modalImg.addEventListener('touchend', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (event.touches.length === 0) {
      isTouchDragging = false;
      modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
    }

    if (event.touches.length < 2) {
      isPinching = false;
      pinchStartDistance = 0;
      pinchStartScale = currentScale;
    }
  });

  modalImg.addEventListener('touchcancel', () => {
    if (!modal.classList.contains('show')) {
      return;
    }

    isTouchDragging = false;
    isPinching = false;
    pinchStartDistance = 0;
    pinchStartScale = currentScale;
    modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
  });

  modal.addEventListener('touchend', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (event.target === modal && event.changedTouches.length === 1 && !isTouchDragging && !isPinching) {
      closeModal();
    }
  }, { passive: true });
});
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('[data-snippet-id]').forEach(caption => {
    const snippetId = caption.getAttribute('data-snippet-id');
    const snippetElement = document.getElementById(snippetId);

    if (snippetElement) {
      const content = snippetElement.textContent.replace(/"/g, '&quot;');
      caption.setAttribute('data-tooltip', content);
      caption.classList.add('diagram-caption');
    }
  });
});
</script>


  <!-- Floating Table of Contents -->
  <div id="floating-toc" class="floating-toc">
    <div class="toc-icon">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="8" y1="6" x2="21" y2="6"></line>
        <line x1="8" y1="12" x2="21" y2="12"></line>
        <line x1="8" y1="18" x2="21" y2="18"></line>
        <line x1="3" y1="6" x2="3.01" y2="6"></line>
        <line x1="3" y1="12" x2="3.01" y2="12"></line>
        <line x1="3" y1="18" x2="3.01" y2="18"></line>
      </svg>
    </div>
    <div class="toc-content">
      <div class="toc-header">
        <span>Contents</span>
        <button class="toc-close" aria-label="Close table of contents">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <nav class="toc-nav" id="toc-nav">
        <!-- Generated by JavaScript -->
      </nav>
    </div>
  </div>

  <footer class="site-footer">
    <span>¬© 2026 glucolte ‚Ä¢ </span>
    <a href="https://github.com/gLuColte/glucolte.github.io">source</a>
  </footer>

  <script>
    // Dark mode functionality
    function initDarkMode() {
      const toggle = document.getElementById('dark-mode-toggle');
      const body = document.body;
      
      // Check for saved theme preference or default to light mode
      const savedTheme = localStorage.getItem('theme');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      
      if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
        body.setAttribute('data-theme', 'dark');
      }
      
      // Toggle dark mode
      if (toggle) {
        toggle.addEventListener('click', function() {
          const currentTheme = body.getAttribute('data-theme');
          const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
          
          body.setAttribute('data-theme', newTheme);
          localStorage.setItem('theme', newTheme);
        });
      }
    }
    
    // Initialize dark mode immediately to prevent flash
    initDarkMode();
    
    // Initialize highlight.js and floating TOC after the DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      hljs.highlightAll();
      
      // Floating TOC functionality - only show on sub-study pages
      const floatingToc = document.getElementById('floating-toc');
      const tocNav = document.getElementById('toc-nav');
      const tocClose = document.querySelector('.toc-close');
      
      // Check if we're on a sub-study page (not the main study index)
      const isSubStudyPage = window.location.pathname !== '/study/' && 
                            window.location.pathname !== '/study' && 
                            window.location.pathname.startsWith('/study/');
      
      if (floatingToc && tocNav && isSubStudyPage) {
        // Generate TOC from headings
        function generateTOC() {
          const headings = document.querySelectorAll('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6');
          if (headings.length === 0) {
            floatingToc.style.display = 'none';
            return;
          }
          
          const tocList = document.createElement('ul');
          let currentLevel = 0;
          let currentList = tocList;
          const listStack = [tocList];
          
          headings.forEach((heading, index) => {
            const level = parseInt(heading.tagName.charAt(1));
            const id = heading.id || `heading-${index}`;
            
            // Ensure heading has an ID
            if (!heading.id) {
              heading.id = id;
            }
            
            // Create list item
            const listItem = document.createElement('li');
            const link = document.createElement('a');
            link.href = `#${id}`;
            link.textContent = heading.textContent.trim();
            link.addEventListener('click', function(e) {
              e.preventDefault();
              const targetElement = document.getElementById(id);
              if (targetElement) {
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                // Close TOC after clicking
                floatingToc.classList.remove('toc-open');
              }
            });
            
            listItem.appendChild(link);
            
            // Handle nesting
            if (level > currentLevel) {
              // Go deeper
              for (let i = currentLevel; i < level; i++) {
                const newList = document.createElement('ul');
                currentList.appendChild(newList);
                listStack.push(newList);
                currentList = newList;
              }
            } else if (level < currentLevel) {
              // Go shallower
              for (let i = currentLevel; i > level; i--) {
                listStack.pop();
                currentList = listStack[listStack.length - 1];
              }
            }
            
            currentList.appendChild(listItem);
            currentLevel = level;
          });
          
          tocNav.appendChild(tocList);
        }
        
        // Generate the TOC
        generateTOC();
        
        // Handle close button
        if (tocClose) {
          tocClose.addEventListener('click', function() {
            floatingToc.classList.remove('toc-open');
          });
        }
        
        // Handle click on icon to toggle
        const tocIcon = document.querySelector('.toc-icon');
        if (tocIcon) {
          tocIcon.addEventListener('click', function() {
            floatingToc.classList.toggle('toc-open');
          });
        }
        
        // Active section highlighting
        function updateActiveSection() {
          const headings = document.querySelectorAll('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6');
          const tocLinks = tocNav.querySelectorAll('a');
          
          // Remove active class from all links
          tocLinks.forEach(link => link.classList.remove('active'));
          
          // Find the current section
          let currentHeading = null;
          const scrollPosition = window.scrollY + 100; // Offset for better UX
          
          for (let i = headings.length - 1; i >= 0; i--) {
            const heading = headings[i];
            const headingTop = heading.offsetTop;
            
            if (headingTop <= scrollPosition) {
              currentHeading = heading;
              break;
            }
          }
          
          // Add active class to current section
          if (currentHeading) {
            const activeLink = tocNav.querySelector(`a[href="#${currentHeading.id}"]`);
            if (activeLink) {
              activeLink.classList.add('active');
            }
          }
        }
        
        // Update active section on scroll
        let scrollTimeout;
        window.addEventListener('scroll', function() {
          if (scrollTimeout) {
            clearTimeout(scrollTimeout);
          }
          scrollTimeout = setTimeout(updateActiveSection, 10);
        });
        
        // Initial update
        updateActiveSection();
      } else if (floatingToc && !isSubStudyPage) {
        // Hide floating TOC on main study page
        floatingToc.style.display = 'none';
      }
      
      // Legacy TOC functionality (for existing markdown TOCs)
      const toc = document.querySelector('#markdown-toc');
      if (toc) {
        // Hide the floating TOC if there's already a markdown TOC
        if (floatingToc) {
          floatingToc.style.display = 'none';
        }
        
        // Create TOC container with header
        const tocContainer = document.createElement('div');
        tocContainer.className = 'toc-container';
        tocContainer.style.cssText = `
          background: #f8fafc;
          border: 1px solid #e5e7eb;
          border-radius: 8px;
          padding: 16px;
          margin: 20px 0;
          position: relative;
        `;
        
        // Add TOC header
        const tocHeader = document.createElement('h3');
        tocHeader.textContent = 'Table of Contents';
        tocHeader.style.cssText = `
          margin: 0 0 12px 0;
          font-size: 16px;
          font-weight: 600;
          color: #374151;
        `;
        
        // Add back to top button
        const backToTopBtn = document.createElement('button');
        backToTopBtn.textContent = '‚Üë Top';
        backToTopBtn.style.cssText = `
          position: absolute;
          top: 12px;
          right: 12px;
          background: #ffffff;
          border: 1px solid #d1d5db;
          border-radius: 6px;
          padding: 4px 8px;
          font-size: 12px;
          cursor: pointer;
          color: #6b7280;
          transition: all 0.2s ease;
        `;
        
        // Add hover effect for back to top button
        backToTopBtn.addEventListener('mouseenter', function() {
          this.style.background = '#f3f4f6';
          this.style.color = '#374151';
        });
        
        backToTopBtn.addEventListener('mouseleave', function() {
          this.style.background = '#ffffff';
          this.style.color = '#6b7280';
        });
        
        // Back to top functionality
        backToTopBtn.addEventListener('click', function() {
          window.scrollTo({ top: 0, behavior: 'smooth' });
        });
        
        // Style the TOC list
        toc.style.cssText = `
          margin: 0;
          padding: 0;
          font-size: 14px;
          line-height: 1.5;
        `;
        
        // Insert header and button into container
        tocContainer.appendChild(tocHeader);
        tocContainer.appendChild(backToTopBtn);
        tocContainer.appendChild(toc);
        
        // Replace the original TOC with the new container
        toc.parentNode.insertBefore(tocContainer, toc);
        tocContainer.appendChild(toc);
        
        // Add smooth scrolling to TOC links
        const tocLinks = toc.querySelectorAll('a');
        tocLinks.forEach(link => {
          link.addEventListener('click', function(e) {
            e.preventDefault();
            const targetId = this.getAttribute('href').substring(1);
            const targetElement = document.getElementById(targetId);
            if (targetElement) {
              targetElement.scrollIntoView({ behavior: 'smooth' });
            }
          });
        });
      }
    });
  </script>
</body>
</html>
