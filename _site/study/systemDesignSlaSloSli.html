<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>SLA, SLO & SLI ¬∑ glucolte</title>
  <meta name="description" content="notes ‚Ä¢ principles ‚Ä¢ systems">
  <link rel="stylesheet" href="/assets/style.css">
  <link rel="stylesheet" href="/assets/study.css">
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/favicon.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>SLA, SLO &amp; SLI | glucolte</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="SLA, SLO &amp; SLI" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="notes ‚Ä¢ principles ‚Ä¢ systems" />
<meta property="og:description" content="notes ‚Ä¢ principles ‚Ä¢ systems" />
<link rel="canonical" href="http://localhost:4000/study/systemDesignSlaSloSli" />
<meta property="og:url" content="http://localhost:4000/study/systemDesignSlaSloSli" />
<meta property="og:site_name" content="glucolte" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="SLA, SLO &amp; SLI" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"notes ‚Ä¢ principles ‚Ä¢ systems","headline":"SLA, SLO &amp; SLI","url":"http://localhost:4000/study/systemDesignSlaSloSli"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
  <header class="site-header">
  <a class="brand" href="/">glucolte</a>
  <nav class="nav">
    <a href="/principles">principles</a>
    <a href="/rules">rules</a>
    <a href="/stretches">stretches</a>
    <a href="/study/">study</a>
    <a href="/projects/">projects</a>
    <a href="/setup/">setup</a>
  </nav>
  <button id="dark-mode-toggle" class="dark-mode-toggle" aria-label="Toggle dark mode">
    <svg class="sun-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
    <svg class="moon-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
    </svg>
  </button>
</header>


  <main class="container">
    <article class="content">
      <h1 id="sla-slo-sli">SLA, SLO &amp; SLI</h1>

<p>An <strong>SLA (Service Level Agreement)</strong> is a formal commitment between a service provider and its customers. It defines what level of service will be delivered, often with financial or contractual penalties if the provider fails to meet it. To design reliable systems, you start by defining SLAs and then architect infrastructure to meet those guarantees.</p>

<hr />

<h2 id="sla-vs-slo-vs-sli">SLA vs SLO vs SLI</h2>

<ul>
  <li><strong>SLI (Service Level Indicator):</strong> The actual metric being measured.
    <ul>
      <li>Example: Percentage of HTTP 200 responses under 300ms.</li>
    </ul>
  </li>
  <li><strong>SLO (Service Level Objective):</strong> The internal target for an SLI.
    <ul>
      <li>Example: 99.9% of requests respond under 300ms in a rolling 30-day window.</li>
    </ul>
  </li>
  <li><strong>SLA (Service Level Agreement):</strong> The external customer contract, usually tied to SLOs with penalties.
    <ul>
      <li>Example: If uptime drops below 99.9% in a month, customers receive service credits.</li>
    </ul>
  </li>
</ul>

<p>üëâ SLI = metric ‚Üí SLO = target ‚Üí SLA = binding agreement.</p>

<hr />

<h2 id="key-sla-components">Key SLA Components</h2>

<ol>
  <li><strong>Availability</strong><br />
Defines uptime guarantees.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Availability = (Total Time ‚Äì Downtime) √∑ Total Time √ó 100
</code></pre></div>    </div>
    <ul>
      <li>99.9% ‚Üí 8.77 hrs downtime/year.</li>
      <li>99.99% ‚Üí 52.6 mins downtime/year.</li>
    </ul>
  </li>
  <li><strong>Performance</strong>
    <ul>
      <li>Response time (e.g., P95 &lt; 100ms).</li>
      <li>Throughput (e.g., ‚â•500 req/sec).</li>
    </ul>
  </li>
  <li><strong>Error Rate</strong><br />
  Acceptable % of failed requests.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Error Rate = (Failed Requests √∑ Total Requests) √ó 100
</code></pre></div>    </div>
  </li>
  <li><strong>Recovery</strong>
    <ul>
      <li><strong>RTO (Recovery Time Objective):</strong> Max acceptable downtime per incident.</li>
      <li><strong>RPO (Recovery Point Objective):</strong> Max acceptable data loss.</li>
    </ul>
  </li>
  <li><strong>Other Dimensions</strong>
    <ul>
      <li><strong>Durability:</strong> e.g., S3 promises 99.999999999% object durability.</li>
      <li><strong>Consistency:</strong> strong vs eventual.</li>
      <li><strong>Support SLAs:</strong> e.g., P1 ticket response within 1 hour.</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="sla-and-system-design">SLA and System Design</h2>

<ol>
  <li><strong>SLA First, Architecture Second</strong>
    <ul>
      <li>A 99.9% SLA means tolerating up to 8.77 hrs downtime/year.</li>
      <li>Higher targets require multi-AZ or multi-region redundancy.</li>
    </ul>
  </li>
  <li><strong>Availability Targets and Architecture</strong>
    <ul>
      <li><strong>90% (36.5 days downtime/year):</strong> Single AZ, minimal redundancy.</li>
      <li><strong>99.9% (8.77 hrs/year):</strong> Single AZ with fast recovery, or Multi-AZ for resilience.</li>
      <li><strong>99.99% (52.6 mins/year):</strong> Multi-AZ failover, automated recovery.</li>
      <li><strong>99.999% (~5 mins/year):</strong> Multi-region active-active, very high cost.</li>
    </ul>
  </li>
  <li><strong>Key Considerations</strong>
    <ul>
      <li>Planned maintenance often excluded.</li>
      <li>Unplanned downtime directly impacts SLA.</li>
      <li>Buffers account for unexpected incidents.</li>
      <li>Redundancy raises SLA but increases cost and complexity.</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="example-e-commerce-platform">Example: E-Commerce Platform</h2>

<h3 id="step-1-define-slis-what-to-measure">Step 1: Define SLIs (What to Measure)</h3>

<ul>
  <li><strong>Availability:</strong> % of successful HTTPS responses (measured at the edge via Route 53).</li>
  <li><strong>Performance:</strong>
    <ul>
      <li>Homepage latency (P95).</li>
      <li>Checkout API latency (P95).</li>
    </ul>
  </li>
  <li><strong>Error Rate:</strong> % of failed transactions.</li>
  <li><strong>Recovery:</strong>
    <ul>
      <li>RTO (time to recover).</li>
      <li>RPO (max data loss).</li>
    </ul>
  </li>
</ul>

<p>‚û°Ô∏è These are end-to-end metrics as seen by customers. Internally, engineers also watch component health (EC2, RDS, ALB, etc.), but those are <em>inputs</em>, not customer-facing outcomes.</p>

<hr />

<h3 id="step-2-define-slos-targets-for-each-sli">Step 2: Define SLOs (Targets for Each SLI)</h3>

<p>Each SLO directly maps to an SLI in Step 1:</p>

<ul>
  <li>Availability ‚â• <strong>99.95%</strong> successful requests per month.</li>
  <li>Homepage latency &lt; <strong>200ms P95</strong>.</li>
  <li>Checkout API latency &lt; <strong>100ms P95</strong>.</li>
  <li>Error rate &lt; <strong>0.1%</strong> per month.</li>
  <li>Recovery: RTO = <strong>15 minutes</strong>, RPO = <strong>5 minutes</strong>.</li>
</ul>

<p>‚û°Ô∏è Step 1 defines <em>variables</em>, Step 2 sets <em>thresholds</em>. If SLOs aren‚Äôt realistic, the SLA that follows will be hollow.</p>

<hr />

<h3 id="step-3-define-sla-customer-facing-contract">Step 3: Define SLA (Customer-Facing Contract)</h3>

<p>Only a subset of SLOs become contractual:</p>

<ul>
  <li><strong>Availability SLA:</strong> ‚â• <strong>99.95% uptime</strong> per month (~21.6 mins downtime).</li>
  <li><strong>Remedy:</strong> Service credits if uptime falls below 99.95%.</li>
  <li><strong>Other SLOs:</strong> (latency, error rate, recovery) may be tracked internally or included in premium SLAs, but are not part of the base contract.</li>
</ul>

<p>‚û°Ô∏è Customers don‚Äôt care about component health; they only care about <strong>request success</strong>. That‚Äôs why SLAs are expressed in terms of end-to-end outcomes, not subsystem metrics.</p>

<hr />

<h3 id="step-4-architecture-to-meet-sla">Step 4: Architecture to Meet SLA</h3>

<p>The system is engineered to satisfy the SLA (Step 3) by aligning infrastructure to the SLOs (Step 2):</p>

<ul>
  <li><strong>Frontend:</strong> CloudFront CDN ‚Üí improves availability and latency SLOs.</li>
  <li><strong>APIs:</strong> Multi-AZ ECS/EC2 behind ALB ‚Üí ensures API availability.</li>
  <li><strong>Database:</strong> Aurora Multi-AZ ‚Üí automatic failover meets recovery SLOs (RTO/RPO).</li>
  <li><strong>Storage:</strong> S3 ‚Üí supports durability promises (11 nines).</li>
  <li><strong>Payments:</strong> Primary + backup providers ‚Üí protects error rate SLO.</li>
  <li><strong>Monitoring:</strong> CloudWatch + Route 53 health checks ‚Üí enforce availability at the edge.</li>
</ul>

<p>‚û°Ô∏è This isn‚Äôt random architecture ‚Äî each choice directly maps back to the metrics that underpin the SLA.</p>

<hr />

<h3 id="customer-facing-sla-external-view">Customer-Facing SLA (External View)</h3>

<ul>
  <li><strong>Metric</strong>: % of successful HTTPS requests (Route 53 checks).</li>
  <li><strong>Promise</strong>: ‚â• <strong>99.95% uptime</strong> per month.</li>
  <li><strong>Enforcement</strong>: Credits issued if the target is missed.</li>
</ul>

<p>üëâ Customers never see the internal math. They only see whether they can load the homepage and complete checkout.</p>

<hr />

<h3 id="internal-sla-baseline-aws-as-our-provider">Internal SLA Baseline (AWS as Our Provider)</h3>

<p>As AWS customers, we rely on <strong>provider SLAs</strong> to know our lower bound:</p>

<table class="study-table">
  <thead>
    <tr>
      <th>Service</th>
      <th>SLA (Published by AWS)</th>
      <th>Link</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CloudFront</td>
      <td>99.9%</td>
      <td><a href="https://aws.amazon.com/cloudfront/sla/" target="_blank">CloudFront SLA</a></td>
    </tr>
    <tr>
      <td>ALB (Elastic Load Balancing)</td>
      <td>99.99%</td>
      <td><a href="https://aws.amazon.com/elasticloadbalancing/sla/" target="_blank">ALB SLA</a></td>
    </tr>
    <tr>
      <td>EC2 (per AZ)</td>
      <td>99.99%</td>
      <td><a href="https://aws.amazon.com/compute/sla/" target="_blank">EC2 SLA</a></td>
    </tr>
    <tr>
      <td>RDS Multi-AZ</td>
      <td>99.99%</td>
      <td><a href="https://aws.amazon.com/rds/sla/" target="_blank">RDS SLA</a></td>
    </tr>
    <tr>
      <td>S3</td>
      <td>99.99% availability,<br />11 nines durability</td>
      <td><a href="https://aws.amazon.com/s3/sla/" target="_blank">S3 SLA</a></td>
    </tr>
  </tbody>
</table>

<p>With <strong>Multi-AZ deployments</strong>, availability improves because both AZs would need to fail simultaneously for the service to be unavailable. If each AZ has <strong>99.99% availability (0.9999)</strong>, then the probability of <em>both</em> failing at the same time is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Joint failure = (1 ‚Äì 0.9999) √ó (1 ‚Äì 0.9999)
              = 0.0001 √ó 0.0001
              = 0.00000001  (0.000001%)
</code></pre></div></div>

<p>So effective availability is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Multi-AZ Availability ‚âà 1 ‚Äì Joint failure
                      ‚âà 1 ‚Äì 0.00000001
                      ‚âà 99.999999%  (8 nines)
</code></pre></div></div>

<p>That‚Äôs why AWS often markets <strong>Multi-AZ RDS or EC2 setups</strong> as ‚Äúhighly available‚Äù ‚Äî the redundancy pushes the number of nines up dramatically.</p>

<hr />

<h3 id="engineering-roll-up-approx">Engineering roll-up (approx)</h3>

<p>When combining multiple services, the system‚Äôs effective availability is roughly the product of each component‚Äôs availability:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>System Availability ‚âà CloudFront √ó ALB √ó EC2(Multi-AZ) √ó RDS(Multi-AZ) √ó S3
‚âà 0.999 √ó 0.9999 √ó 0.99999999 √ó 0.99999999 √ó 0.9999
‚âà 99.88%
</code></pre></div></div>

<p>‚û°Ô∏è This illustrates a <strong>gap</strong>: even though individual services have strong SLAs, the multiplicative effect drags the total down. To confidently offer an external <strong>99.95% SLA</strong> (or higher), you need <strong>extra redundancy</strong> such as multi-region, edge caching, or graceful degradation (e.g., read-only mode if the database is down).</p>

<hr />

<h3 id="key-insight">Key Insight</h3>

<ul>
  <li><strong>Externally:</strong> SLA is measured end-to-end at the edge ‚Üí customer outcomes.</li>
  <li><strong>Internally:</strong> Engineers validate feasibility by multiplying provider SLAs.</li>
  <li><strong>Professional Risk View:</strong> If AWS guarantees ~99.88% and we promise 99.95%, we must close the delta with multi-region or fallback strategies ‚Äî otherwise the SLA is wishful thinking.</li>
</ul>

    </article>
  </main>

  <div id="imageModal" class="image-modal">
  <div class="modal-content">
    <span class="modal-close">&times;</span>
    <button class="modal-nav modal-prev">&#8249;</button>
    <button class="modal-nav modal-next">&#8250;</button>
    <img id="modalImage" src="" alt="">
    <div id="modalCaption"></div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const modal = document.getElementById('imageModal');
  const modalImg = document.getElementById('modalImage');
  const modalCaption = document.getElementById('modalCaption');
  const modalClose = document.querySelector('.modal-close');
  const modalPrev = document.querySelector('.modal-prev');
  const modalNext = document.querySelector('.modal-next');

  const SCALE_STEP = 0.2;
  const MIN_SCALE = 1;
  const MAX_SCALE = 3;

  let modalImages = [];
  let currentIndex = -1;
  let currentScale = MIN_SCALE;
  let translateX = 0;
  let translateY = 0;
  let isDragging = false;
  let isTouchDragging = false;
  let isPinching = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let pinchStartDistance = 0;
  let pinchStartScale = MIN_SCALE;
  let transitionTimeout;

  function refreshModalImages() {
    modalImages = Array.from(document.querySelectorAll('.modal-trigger'));
  }

  function applyTransform(withTransition = false) {
    if (currentScale <= MIN_SCALE) {
      currentScale = MIN_SCALE;
      translateX = 0;
      translateY = 0;
    }

    if (transitionTimeout) {
      clearTimeout(transitionTimeout);
      transitionTimeout = null;
    }

    modalImg.style.transition = withTransition ? 'transform 0.15s ease' : 'none';
    modalImg.style.transform = `translate(${translateX}px, ${translateY}px) scale(${currentScale})`;
    modalImg.style.cursor = currentScale > MIN_SCALE
      ? (isDragging || isTouchDragging ? 'grabbing' : 'grab')
      : 'auto';

    if (withTransition) {
      transitionTimeout = setTimeout(() => {
        modalImg.style.transition = 'none';
      }, 160);
    }
  }

  function resetTransform() {
    currentScale = MIN_SCALE;
    translateX = 0;
    translateY = 0;
    applyTransform(false);
  }

  function getDistance(touch1, touch2) {
    return Math.hypot(
      touch1.clientX - touch2.clientX,
      touch1.clientY - touch2.clientY
    );
  }

  function openModalAtIndex(index) {
    refreshModalImages();

    if (!modalImages.length) {
      return;
    }

    if (index < 0) {
      index = modalImages.length - 1;
    } else if (index >= modalImages.length) {
      index = 0;
    }

    const target = modalImages[index];
    if (!target) {
      return;
    }

    currentIndex = index;
    const src = target.dataset.modalSrc || target.src;
    const caption = target.getAttribute('data-caption') || target.alt;

    modalImg.src = src;
    modalCaption.textContent = caption || '';
    modal.classList.add('show');
    document.body.style.overflow = 'hidden';
    resetTransform();
  }

  function closeModal() {
    if (!modal.classList.contains('show')) {
      return;
    }
    modal.classList.remove('show');
    document.body.style.overflow = '';
    currentIndex = -1;
    isDragging = false;
    isTouchDragging = false;
    isPinching = false;
    resetTransform();
  }

  refreshModalImages();

  modalImg.addEventListener('dragstart', event => event.preventDefault());

  document.addEventListener('click', event => {
    const trigger = event.target.closest('.modal-trigger');
    if (!trigger) {
      return;
    }

    event.preventDefault();
    refreshModalImages();
    const index = modalImages.indexOf(trigger);
    openModalAtIndex(index > -1 ? index : 0);
  });

  modalClose?.addEventListener('click', closeModal);

  modal.addEventListener('click', event => {
    if (event.target === modal) {
      closeModal();
    }
  });

  document.addEventListener('keydown', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    switch (event.key) {
      case 'Escape':
        closeModal();
        break;
      case 'ArrowLeft':
        event.preventDefault();
        openModalAtIndex(currentIndex - 1);
        break;
      case 'ArrowRight':
        event.preventDefault();
        openModalAtIndex(currentIndex + 1);
        break;
      case '+':
      case '=':
        event.preventDefault();
        currentScale = Math.min(MAX_SCALE, currentScale + SCALE_STEP);
        applyTransform(true);
        break;
      case '-':
        event.preventDefault();
        currentScale = Math.max(MIN_SCALE, currentScale - SCALE_STEP);
        applyTransform(true);
        break;
      case '0':
        event.preventDefault();
        resetTransform();
        applyTransform(true);
        break;
      default:
        break;
    }
  });

  modal.addEventListener('wheel', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    event.preventDefault();
    const delta = event.deltaY > 0 ? -SCALE_STEP : SCALE_STEP;
    const nextScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, currentScale + delta));

    if (nextScale === currentScale) {
      return;
    }

    currentScale = nextScale;
    applyTransform(true);
  }, { passive: false });

  if (modalPrev) {
    modalPrev.addEventListener('click', event => {
      event.preventDefault();
      if (currentIndex === -1) {
        return;
      }
      openModalAtIndex(currentIndex - 1);
    });
  }

  if (modalNext) {
    modalNext.addEventListener('click', event => {
      event.preventDefault();
      if (currentIndex === -1) {
        return;
      }
      openModalAtIndex(currentIndex + 1);
    });
  }

  modalImg.addEventListener('mousedown', event => {
    if (!modal.classList.contains('show') || currentScale <= MIN_SCALE) {
      return;
    }

    event.preventDefault();
    isDragging = true;
    dragStartX = event.clientX;
    dragStartY = event.clientY;
    modalImg.style.cursor = 'grabbing';
  });

  document.addEventListener('mousemove', event => {
    if (!isDragging) {
      return;
    }

    event.preventDefault();
    translateX += event.clientX - dragStartX;
    translateY += event.clientY - dragStartY;
    dragStartX = event.clientX;
    dragStartY = event.clientY;
    applyTransform(false);
  });

  document.addEventListener('mouseup', () => {
    if (!isDragging) {
      return;
    }
    isDragging = false;
    modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
  });

  modalImg.addEventListener('touchstart', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (event.touches.length === 1 && currentScale > MIN_SCALE) {
      event.preventDefault();
      isTouchDragging = true;
      dragStartX = event.touches[0].clientX;
      dragStartY = event.touches[0].clientY;
      modalImg.style.cursor = 'grabbing';
    } else if (event.touches.length === 2) {
      event.preventDefault();
      isTouchDragging = false;
      isPinching = true;
      pinchStartDistance = getDistance(event.touches[0], event.touches[1]);
      pinchStartScale = currentScale;
      modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
    }
  }, { passive: false });

  modalImg.addEventListener('touchmove', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (isPinching && event.touches.length === 2) {
      event.preventDefault();
      const distance = getDistance(event.touches[0], event.touches[1]);
      if (pinchStartDistance > 0) {
        const scaleRatio = distance / pinchStartDistance;
        currentScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, pinchStartScale * scaleRatio));
        applyTransform(false);
      }
    } else if (isTouchDragging && event.touches.length === 1) {
      event.preventDefault();
      translateX += event.touches[0].clientX - dragStartX;
      translateY += event.touches[0].clientY - dragStartY;
      dragStartX = event.touches[0].clientX;
      dragStartY = event.touches[0].clientY;
      applyTransform(false);
    }
  }, { passive: false });

  modalImg.addEventListener('touchend', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (event.touches.length === 0) {
      isTouchDragging = false;
      modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
    }

    if (event.touches.length < 2) {
      isPinching = false;
      pinchStartDistance = 0;
      pinchStartScale = currentScale;
    }
  });

  modalImg.addEventListener('touchcancel', () => {
    if (!modal.classList.contains('show')) {
      return;
    }

    isTouchDragging = false;
    isPinching = false;
    pinchStartDistance = 0;
    pinchStartScale = currentScale;
    modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
  });

  modal.addEventListener('touchend', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (event.target === modal && event.changedTouches.length === 1 && !isTouchDragging && !isPinching) {
      closeModal();
    }
  }, { passive: true });
});
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('[data-snippet-id]').forEach(caption => {
    const snippetId = caption.getAttribute('data-snippet-id');
    const snippetElement = document.getElementById(snippetId);

    if (snippetElement) {
      const content = snippetElement.textContent.replace(/"/g, '&quot;');
      caption.setAttribute('data-tooltip', content);
      caption.classList.add('diagram-caption');
    }
  });
});
</script>


  <!-- Floating Table of Contents -->
  <div id="floating-toc" class="floating-toc">
    <div class="toc-icon">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="8" y1="6" x2="21" y2="6"></line>
        <line x1="8" y1="12" x2="21" y2="12"></line>
        <line x1="8" y1="18" x2="21" y2="18"></line>
        <line x1="3" y1="6" x2="3.01" y2="6"></line>
        <line x1="3" y1="12" x2="3.01" y2="12"></line>
        <line x1="3" y1="18" x2="3.01" y2="18"></line>
      </svg>
    </div>
    <div class="toc-content">
      <div class="toc-header">
        <span>Contents</span>
        <button class="toc-close" aria-label="Close table of contents">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <nav class="toc-nav" id="toc-nav">
        <!-- Generated by JavaScript -->
      </nav>
    </div>
  </div>

  <footer class="site-footer">
    <span>¬© 2026 glucolte ‚Ä¢ </span>
    <a href="https://github.com/gLuColte/glucolte.github.io">source</a>
  </footer>

  <script>
    // Dark mode functionality
    function initDarkMode() {
      const toggle = document.getElementById('dark-mode-toggle');
      const body = document.body;
      
      // Check for saved theme preference or default to light mode
      const savedTheme = localStorage.getItem('theme');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      
      if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
        body.setAttribute('data-theme', 'dark');
      }
      
      // Toggle dark mode
      if (toggle) {
        toggle.addEventListener('click', function() {
          const currentTheme = body.getAttribute('data-theme');
          const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
          
          body.setAttribute('data-theme', newTheme);
          localStorage.setItem('theme', newTheme);
        });
      }
    }
    
    // Initialize dark mode immediately to prevent flash
    initDarkMode();
    
    // Initialize highlight.js and floating TOC after the DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      hljs.highlightAll();
      
      // Floating TOC functionality - only show on sub-study pages
      const floatingToc = document.getElementById('floating-toc');
      const tocNav = document.getElementById('toc-nav');
      const tocClose = document.querySelector('.toc-close');
      
      // Check if we're on a sub-study page (not the main study index)
      const isSubStudyPage = window.location.pathname !== '/study/' && 
                            window.location.pathname !== '/study' && 
                            window.location.pathname.startsWith('/study/');
      
      if (floatingToc && tocNav && isSubStudyPage) {
        // Generate TOC from headings
        function generateTOC() {
          const headings = document.querySelectorAll('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6');
          if (headings.length === 0) {
            floatingToc.style.display = 'none';
            return;
          }
          
          const tocList = document.createElement('ul');
          let currentLevel = 0;
          let currentList = tocList;
          const listStack = [tocList];
          
          headings.forEach((heading, index) => {
            const level = parseInt(heading.tagName.charAt(1));
            const id = heading.id || `heading-${index}`;
            
            // Ensure heading has an ID
            if (!heading.id) {
              heading.id = id;
            }
            
            // Create list item
            const listItem = document.createElement('li');
            const link = document.createElement('a');
            link.href = `#${id}`;
            link.textContent = heading.textContent.trim();
            link.addEventListener('click', function(e) {
              e.preventDefault();
              const targetElement = document.getElementById(id);
              if (targetElement) {
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                // Close TOC after clicking
                floatingToc.classList.remove('toc-open');
              }
            });
            
            listItem.appendChild(link);
            
            // Handle nesting
            if (level > currentLevel) {
              // Go deeper
              for (let i = currentLevel; i < level; i++) {
                const newList = document.createElement('ul');
                currentList.appendChild(newList);
                listStack.push(newList);
                currentList = newList;
              }
            } else if (level < currentLevel) {
              // Go shallower
              for (let i = currentLevel; i > level; i--) {
                listStack.pop();
                currentList = listStack[listStack.length - 1];
              }
            }
            
            currentList.appendChild(listItem);
            currentLevel = level;
          });
          
          tocNav.appendChild(tocList);
        }
        
        // Generate the TOC
        generateTOC();
        
        // Handle close button
        if (tocClose) {
          tocClose.addEventListener('click', function() {
            floatingToc.classList.remove('toc-open');
          });
        }
        
        // Handle click on icon to toggle
        const tocIcon = document.querySelector('.toc-icon');
        if (tocIcon) {
          tocIcon.addEventListener('click', function() {
            floatingToc.classList.toggle('toc-open');
          });
        }
        
        // Active section highlighting
        function updateActiveSection() {
          const headings = document.querySelectorAll('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6');
          const tocLinks = tocNav.querySelectorAll('a');
          
          // Remove active class from all links
          tocLinks.forEach(link => link.classList.remove('active'));
          
          // Find the current section
          let currentHeading = null;
          const scrollPosition = window.scrollY + 100; // Offset for better UX
          
          for (let i = headings.length - 1; i >= 0; i--) {
            const heading = headings[i];
            const headingTop = heading.offsetTop;
            
            if (headingTop <= scrollPosition) {
              currentHeading = heading;
              break;
            }
          }
          
          // Add active class to current section
          if (currentHeading) {
            const activeLink = tocNav.querySelector(`a[href="#${currentHeading.id}"]`);
            if (activeLink) {
              activeLink.classList.add('active');
            }
          }
        }
        
        // Update active section on scroll
        let scrollTimeout;
        window.addEventListener('scroll', function() {
          if (scrollTimeout) {
            clearTimeout(scrollTimeout);
          }
          scrollTimeout = setTimeout(updateActiveSection, 10);
        });
        
        // Initial update
        updateActiveSection();
      } else if (floatingToc && !isSubStudyPage) {
        // Hide floating TOC on main study page
        floatingToc.style.display = 'none';
      }
      
      // Legacy TOC functionality (for existing markdown TOCs)
      const toc = document.querySelector('#markdown-toc');
      if (toc) {
        // Hide the floating TOC if there's already a markdown TOC
        if (floatingToc) {
          floatingToc.style.display = 'none';
        }
        
        // Create TOC container with header
        const tocContainer = document.createElement('div');
        tocContainer.className = 'toc-container';
        tocContainer.style.cssText = `
          background: #f8fafc;
          border: 1px solid #e5e7eb;
          border-radius: 8px;
          padding: 16px;
          margin: 20px 0;
          position: relative;
        `;
        
        // Add TOC header
        const tocHeader = document.createElement('h3');
        tocHeader.textContent = 'Table of Contents';
        tocHeader.style.cssText = `
          margin: 0 0 12px 0;
          font-size: 16px;
          font-weight: 600;
          color: #374151;
        `;
        
        // Add back to top button
        const backToTopBtn = document.createElement('button');
        backToTopBtn.textContent = '‚Üë Top';
        backToTopBtn.style.cssText = `
          position: absolute;
          top: 12px;
          right: 12px;
          background: #ffffff;
          border: 1px solid #d1d5db;
          border-radius: 6px;
          padding: 4px 8px;
          font-size: 12px;
          cursor: pointer;
          color: #6b7280;
          transition: all 0.2s ease;
        `;
        
        // Add hover effect for back to top button
        backToTopBtn.addEventListener('mouseenter', function() {
          this.style.background = '#f3f4f6';
          this.style.color = '#374151';
        });
        
        backToTopBtn.addEventListener('mouseleave', function() {
          this.style.background = '#ffffff';
          this.style.color = '#6b7280';
        });
        
        // Back to top functionality
        backToTopBtn.addEventListener('click', function() {
          window.scrollTo({ top: 0, behavior: 'smooth' });
        });
        
        // Style the TOC list
        toc.style.cssText = `
          margin: 0;
          padding: 0;
          font-size: 14px;
          line-height: 1.5;
        `;
        
        // Insert header and button into container
        tocContainer.appendChild(tocHeader);
        tocContainer.appendChild(backToTopBtn);
        tocContainer.appendChild(toc);
        
        // Replace the original TOC with the new container
        toc.parentNode.insertBefore(tocContainer, toc);
        tocContainer.appendChild(toc);
        
        // Add smooth scrolling to TOC links
        const tocLinks = toc.querySelectorAll('a');
        tocLinks.forEach(link => {
          link.addEventListener('click', function(e) {
            e.preventDefault();
            const targetId = this.getAttribute('href').substring(1);
            const targetElement = document.getElementById(targetId);
            if (targetElement) {
              targetElement.scrollIntoView({ behavior: 'smooth' });
            }
          });
        });
      }
    });
  </script>
</body>
</html>
