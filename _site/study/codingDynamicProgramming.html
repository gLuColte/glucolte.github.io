<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>dynamic programming · glucolte</title>
  <meta name="description" content="notes • principles • systems">
  <link rel="stylesheet" href="/assets/style.css">
  <link rel="stylesheet" href="/assets/study.css">
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/favicon.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>dynamic programming | glucolte</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="dynamic programming" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="notes • principles • systems" />
<meta property="og:description" content="notes • principles • systems" />
<link rel="canonical" href="http://localhost:4000/study/codingDynamicProgramming" />
<meta property="og:url" content="http://localhost:4000/study/codingDynamicProgramming" />
<meta property="og:site_name" content="glucolte" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="dynamic programming" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"notes • principles • systems","headline":"dynamic programming","url":"http://localhost:4000/study/codingDynamicProgramming"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
  <header class="site-header">
  <a class="brand" href="/">glucolte</a>
  <nav class="nav">
    <a href="/principles">principles</a>
    <a href="/rules">rules</a>
    <a href="/stretches">stretches</a>
    <a href="/study/">study</a>
    <a href="/projects/">projects</a>
    <a href="/setup/">setup</a>
  </nav>
  <button id="dark-mode-toggle" class="dark-mode-toggle" aria-label="Toggle dark mode">
    <svg class="sun-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
    <svg class="moon-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
    </svg>
  </button>
</header>


  <main class="container">
    <article class="content">
      <h1 id="dynamic-programming">Dynamic Programming</h1>

<p><strong>Patterns to know:</strong></p>
<ul>
  <li>1D DP (Fibonacci, House Robber).</li>
  <li>2D DP on Grids (Unique Paths, Min Path Sum).
    <ul>
      <li>If it’s pure counting with 2 moves (right/down) → yes, think Pascal/binomial.</li>
      <li>If it’s extra rules → switch to general DP grid filling (but it’s the same spirit).</li>
      <li>If it’s just paths with no conditions → you can even skip DP and use the formula directly (C(m+n-2, m-1)).</li>
    </ul>
  </li>
  <li>Subsequence DP (LIS, LCS, Edit Distance).</li>
  <li>Knapsack Variants.</li>
  <li>Interval DP (Burst Balloons).</li>
  <li>State Machine DP (Stocks).</li>
  <li>State Compression (Bitmask DP).</li>
  <li>Digit DP (counting numbers under constraints).</li>
</ul>

<p><strong>How to identify:</strong></p>
<ul>
  <li>Problem asks for “maximum/minimum ways, cost, length”.</li>
  <li>Overlapping subproblems (same input repeated).</li>
  <li>Optimal substructure (global optimum = combination of local optima).</li>
  <li>Often solved recursively → memoization → tabulation.</li>
</ul>

<hr />

<ul id="markdown-toc">
  <li><a href="#climbing-stairs---easy" id="markdown-toc-climbing-stairs---easy">Climbing Stairs - Easy</a></li>
  <li><a href="#pascals-triangle---easy" id="markdown-toc-pascals-triangle---easy">Pascal’s Triangle - Easy</a></li>
  <li><a href="#pascals-triangle-ii---easy" id="markdown-toc-pascals-triangle-ii---easy">Pascal’s Triangle II - Easy</a></li>
  <li><a href="#counting-bits---easy" id="markdown-toc-counting-bits---easy">Counting Bits - Easy</a></li>
  <li><a href="#unique-paths---medium" id="markdown-toc-unique-paths---medium">Unique Paths - Medium</a></li>
  <li><a href="#unique-paths-ii---medium" id="markdown-toc-unique-paths-ii---medium">Unique Paths II - Medium</a></li>
  <li><a href="#minimum-path-sum---medium" id="markdown-toc-minimum-path-sum---medium">Minimum Path Sum - Medium</a></li>
  <li><a href="#is-subsequence---easy" id="markdown-toc-is-subsequence---easy">Is Subsequence - Easy</a></li>
  <li><a href="#fibonacci-number---easy" id="markdown-toc-fibonacci-number---easy">Fibonacci Number - Easy</a></li>
  <li><a href="#nth-tribonacci-number" id="markdown-toc-nth-tribonacci-number">Nth Tribonacci Number</a></li>
  <li><a href="#maximum-repeating-substring---easy" id="markdown-toc-maximum-repeating-substring---easy">Maximum Repeating Substring - Easy</a></li>
</ul>

<hr />

<h2 id="climbing-stairs---easy">Climbing Stairs - Easy</h2>

<p><a href="https://leetcode.com/problems/climbing-stairs/?envType=problem-list-v2&amp;envId=dynamic-programming">Leetcode Link</a></p>

<p>To understand the problem:</p>

<div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">4   ------------ 4 ----------
               / ^  \
3   -------  3 - ^ - ^ ------
          /  ^ - ^ - ^ ------
2   ---- 2 - ^ - 2 - 2 ------
       / ^   ^ - ^ - | ------
1   --1- ^ - 1 - ^ - 1 ------
      |  ^   |   ^   |
S   --o--o---o---o---o-------

</span><span class="gp">| -&gt;</span><span class="w"> </span>1 Step
<span class="gp">^ -&gt;</span><span class="w"> </span>2 Step
</code></pre></div></div>

<p>Solution:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">climbStairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># Input: int
</span>        <span class="c1"># Output: int
</span>        <span class="c1"># Description:
</span>            <span class="c1"># Only 1 or 2 Steps
</span>            <span class="c1"># Find distinct ways for Summing to n
</span>        
        <span class="c1"># Example 1:
</span>        <span class="c1"># Input -&gt; [1]
</span>        <span class="c1"># Output -&gt; 1 way
</span>        <span class="c1"># Example 2:
</span>        <span class="c1"># Input -&gt; [2]
</span>        <span class="c1"># Output -&gt; [1+1], [2] = 2 Ways
</span>        <span class="c1"># Input -&gt; 3
</span>        <span class="c1"># Output -&gt; [1+1+1], [1+2], [2+1] = 3 ways
</span>
        <span class="c1"># Going from bottom of the tree up
</span>
        <span class="c1"># 0) If there is 1 stair -&gt; only 1 way up
</span>        <span class="c1"># If there are 2 stairs -&gt; 2 ways up
</span>        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span>

        <span class="c1"># Initialize
</span>        <span class="c1"># We at ladder 3, one step before = 2, and there is 2 way to reach it (aka step a single step, or jump two steps)
</span>        <span class="c1"># We at ladder 3, two steps beofer = 1, and there is 1 way to reach it (aka step a single step)
</span>        <span class="n">one_step_before</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># ways to reach THE step ahead
</span>        <span class="n">two_steps_before</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># ways to reach THE 2 steps ahead
</span>        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Iterate from 3, meaning we are going up the "ladder"
</span>        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># to reach 3, we add the "paths" before
</span>            <span class="n">total</span> <span class="o">=</span> <span class="n">one_step_before</span> <span class="o">+</span> <span class="n">two_steps_before</span>
            <span class="c1"># Re-assign, the two steps before, becomes one step before, as we move along
</span>            <span class="n">two_steps_before</span> <span class="o">=</span> <span class="n">one_step_before</span>
            <span class="c1"># The one step before becomes the current step
</span>            <span class="n">one_step_before</span> <span class="o">=</span> <span class="n">total</span>
        <span class="k">return</span> <span class="n">total</span>
        <span class="c1"># Complexity:
</span>        <span class="c1"># Time = O(n)
</span>        <span class="c1"># Space = O(1)
</span></code></pre></div></div>

<h2 id="pascals-triangle---easy">Pascal’s Triangle - Easy</h2>

<p><a href="https://leetcode.com/problems/pascals-triangle/description/?envType=problem-list-v2&amp;envId=dynamic-programming">Leetcode Link</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numRows</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="c1"># Input: int
</span>        <span class="c1"># Output: List[List[int]]
</span>        <span class="c1"># Description:
</span>            <span class="c1"># Each number is the sum of the two numbers directly above it
</span>        <span class="c1"># Example 1:
</span>        <span class="c1"># Input -&gt; numRows = 5
</span>        <span class="c1"># Output -&gt; [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
</span>        <span class="c1"># Example 2:
</span>        <span class="c1"># Input -&gt; numRows = 1
</span>        <span class="c1"># Output -&gt; [[1]]
</span>
        <span class="c1"># Understanding by reverting the "triangle"
</span>        <span class="c1"># 5 | 1 4 6 4 1
</span>        <span class="c1"># 4 |  1 3 3 1
</span>        <span class="c1"># 3 |   1 2 1
</span>        <span class="c1"># 2 |    1 1
</span>        <span class="c1"># 1 |     1
</span>        
        <span class="c1"># Initialize with [1]
</span>        <span class="n">output_list</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># We going up the "rows"
</span>        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">numRows</span><span class="p">):</span>
            <span class="c1"># Get the "last" row
</span>            <span class="n">prev</span> <span class="o">=</span> <span class="n">output_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># The Current becomes:
</span>            <span class="c1"># Middle Component "iterates" through length of previous and adds
</span>            <span class="c1"># e.g. len(prev) = 3, minus one to keep it in index, then use the index to add
</span>            <span class="n">middle_component</span> <span class="o">=</span> <span class="p">[</span><span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
            <span class="c1"># Append [1] to two side
</span>            <span class="n">current</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">middle_component</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Add to output_list
</span>            <span class="n">output_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output_list</span>
        <span class="c1"># Complexity
</span>        <span class="c1"># Time = O(n^2) -&gt; Row 1 has 1 element, row 2 has 2, … row n has n.
</span>        <span class="c1"># Space = O(n^2) -&gt; If you store all rows (like in output_list), you’re storing ~ n(n+1)/2 integers.
</span></code></pre></div></div>

<h2 id="pascals-triangle-ii---easy">Pascal’s Triangle II - Easy</h2>

<p><a href="https://leetcode.com/problems/pascals-triangle-ii/?envType=problem-list-v2&amp;envId=dynamic-programming">Leetcode Link</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">getRow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rowIndex</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># Inputs: int
</span>        <span class="c1"># Output: List[int]
</span>        <span class="c1"># Description:
</span>        <span class="c1"># In Pascal's triangle, each number is the sum of the two numbers directly above it
</span>
        <span class="c1"># Example 1:
</span>        <span class="c1"># Inputs -&gt; rowIndex = 3
</span>        <span class="c1"># Outputs -&gt; [1,3,3,1]
</span>
        <span class="c1"># Example 2:
</span>        <span class="c1"># Inputs -&gt; rowIndex = 0
</span>        <span class="c1"># Outputs -&gt; [1]
</span>
        <span class="c1"># Example 3:
</span>        <span class="c1"># Inputs -&gt; rowIndex = 1
</span>        <span class="c1"># Outputs -&gt; [1,1]
</span>
        <span class="c1"># Understanding:
</span>        <span class="c1"># 4 | 1 4 6 4 1
</span>        <span class="c1"># 3 |  1 3 3 1
</span>        <span class="c1"># 2 |   1 2 1
</span>        <span class="c1"># 1 |    1 1
</span>        <span class="c1"># 0 |     1
</span>
        <span class="c1"># Initialize 1st row
</span>        <span class="n">previous_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">rowIndex</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">previous_list</span>

        <span class="c1"># Iterate through
</span>        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rowIndex</span><span class="p">):</span>
            <span class="n">middle_component</span> <span class="o">=</span> <span class="p">[</span><span class="n">previous_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">previous_list</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">previous_list</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
            <span class="n">current_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">middle_component</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">previous_list</span> <span class="o">=</span> <span class="n">current_list</span>
        <span class="k">return</span> <span class="n">current_list</span>

        <span class="c1"># Complexity:
</span>        <span class="c1"># Time = O(n^2)
</span>        <span class="c1"># Space = O(n)
</span>
</code></pre></div></div>

<h2 id="counting-bits---easy">Counting Bits - Easy</h2>

<p><a href="https://leetcode.com/problems/counting-bits/?envType=problem-list-v2&amp;envId=dynamic-programming">Leetcode Link</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">countBits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># Inputs: int
</span>        <span class="c1"># Outputs: List[int]
</span>        <span class="c1"># Description:
</span>            <span class="c1"># For 0...n
</span>            <span class="c1"># Convert to Binary
</span>
        <span class="c1"># Example 1:
</span>        <span class="c1"># Input -&gt; n = 2
</span>        <span class="c1"># Output -&gt; [0,1,1] 
</span>
        <span class="c1"># Example 2:
</span>        <span class="c1"># Input -&gt; n = 5
</span>        <span class="c1"># Output -&gt; [0,1,1,2,1,2]
</span>
        <span class="c1"># Brute Force appraoch
</span>        <span class="c1"># output_list = []
</span>        <span class="c1"># for num in range(n+1):
</span>        <span class="c1">#     current_sum = sum(int(_) for _ in bin(num)[2:])
</span>        <span class="c1">#     output_list.append(current_sum)
</span>        <span class="c1"># return output_list
</span>
        <span class="c1"># DP approach
</span>        <span class="c1"># 0) Setup
</span>        <span class="c1"># Initialize an array of 0s -&gt; [0,0,0,0,0,0] for n = 5
</span>        <span class="n">output_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Iterate from 0...n+1
</span>        <span class="c1"># 0 has no bit, which is already captured
</span>        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># num &gt;&gt; 1 = Chop off the last bit and return the integer
</span>            <span class="c1"># E.g. 
</span>            <span class="c1"># 13231 &gt;&gt; 1 = 6615
</span>            <span class="c1"># &gt;&gt;&gt; bin(13231)
</span>            <span class="c1"># '0b11001110101111'
</span>            <span class="c1"># &gt;&gt;&gt; bin(13231&gt;&gt;1)
</span>            <span class="c1"># '0b1100111010111'
</span>            <span class="c1"># num &amp; 1 = last bit (0 if even, 1 if odd)
</span>            <span class="c1"># The trick here is:
</span>            <span class="c1"># 1 → 001  (1 one-bit)
</span>            <span class="c1"># 2 → 010  (1 one-bit)
</span>            <span class="c1"># 3 → 011  (2 one-bits)
</span>            <span class="c1"># 4 → 100  (1 one-bit)
</span>            <span class="c1"># 5 → 101  (2 one-bits)
</span>            <span class="c1"># 6 → 110  (2 one-bits)
</span>            <span class="c1"># 7 → 111  (3 one-bits)
</span>            <span class="c1"># Example:
</span>            <span class="c1"># 5 (101) → 2 (10)
</span>            <span class="c1"># 6 (110) → 3 (11)
</span>            <span class="c1"># 7 (111) → 3 (11)
</span>            <span class="c1"># You are not "directly" using the previous number
</span>            <span class="c1"># You are using the "number" that is off the same "bit"
</span>            <span class="c1"># So overall, we get:
</span>            <span class="n">output_list</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_list</span><span class="p">[</span><span class="n">num</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">num</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output_list</span>

        <span class="c1"># Complexity
</span>        <span class="c1"># Time -&gt; O(n)
</span>        <span class="c1"># Space -&gt; O(n) -&gt; Output list has size n+1
</span>
</code></pre></div></div>

<h2 id="unique-paths---medium">Unique Paths - Medium</h2>

<p><a href="https://leetcode.com/problems/unique-paths/?envType=problem-list-v2&amp;envId=dynamic-programming">Leetcode Link</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">uniquePaths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># Inputs: int, int
</span>        <span class="c1"># Outputs: int
</span>        <span class="c1"># Description:
</span>            <span class="c1"># Initially located at the top left corner (0,0)
</span>            <span class="c1"># Tries to move to bottom right
</span>            <span class="c1"># Can only move down or right
</span>            <span class="c1"># Return the number of possible unique paths that the robot can take to reach the bottom righ corner
</span>
        <span class="c1"># Example 1:
</span>        <span class="c1"># Inputs -&gt; 3,7
</span>        <span class="c1"># Outputs -&gt; 28
</span>
        <span class="c1"># Example 2:
</span>        <span class="c1"># Inputs -&gt; 3,2
</span>        <span class="c1"># Outputs -&gt; 3
</span>
        <span class="c1"># Think of it as Pascal Triangle
</span>        <span class="c1"># 3x3
</span>        <span class="c1"># 1 1 1
</span>        <span class="c1"># 1 2 3
</span>        <span class="c1"># 1 3 6
</span>
        <span class="c1"># 5x4
</span>        <span class="c1"># 1  1  1  1  1 
</span>        <span class="c1"># 1  2  3  4  5
</span>        <span class="c1"># 1  3  6  10 15
</span>        <span class="c1"># 1  4  10 20 35 
</span>
        <span class="c1"># Create the 2d grid first
</span>        <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>
        <span class="c1"># Fill the rest of the table
</span>        <span class="c1"># i goes down
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="p">):</span>
            <span class="c1"># j goes right
</span>            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
                <span class="c1"># E.g. i = 1, j = 1 --&gt; 1 + 1 = 2
</span>                <span class="c1"># E.g. i = 2, j = 6 --&gt; 2 + 6 = 7
</span>                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Answer
</span>        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="unique-paths-ii---medium">Unique Paths II - Medium</h2>

<p><a href="https://leetcode.com/problems/unique-paths-ii/?envType=problem-list-v2&amp;envId=dynamic-programming">Leetcode Link</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">uniquePathsWithObstacles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstacleGrid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># Inputs: List[List[int]]
</span>        <span class="c1"># Outputs: int
</span>        <span class="c1"># Description:
</span>        <span class="c1">#   Given a Grid m x n
</span>        <span class="c1">#   Start at (0,0)
</span>        <span class="c1">#   Move to the bottom right (m-1, n-1)
</span>        <span class="c1">#   Can only move down or right
</span>        <span class="c1">#   Obstacles are marked as 1, spaces as 0
</span>        <span class="c1">#   Return the number of possible unique paths to the bottom right
</span>        <span class="c1">#
</span>        <span class="c1"># Example 1
</span>        <span class="c1"># Inputs: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
</span>        <span class="c1"># Output: 2
</span>        <span class="c1">#
</span>        <span class="c1"># Pascal Triangle intuition (no obstacles):
</span>        <span class="c1"># 3x3
</span>        <span class="c1"># 1 1 1
</span>        <span class="c1"># 1 2 3
</span>        <span class="c1"># 1 3 6
</span>        <span class="c1">#
</span>        <span class="c1"># With obstacles (1s act like “walls” that stop flow):
</span>        <span class="c1"># 1 1 1
</span>        <span class="c1"># 1 0 1
</span>        <span class="c1"># 1 1 2
</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obstacleGrid</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obstacleGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Edge case: start or end blocked → 0 paths
</span>        <span class="k">if</span> <span class="n">obstacleGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">obstacleGrid</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># pathGrid[i][j] = number of ways to reach (i, j)
</span>        <span class="c1"># Note - a mistake made here is assuming pathGrid initialize with 1
</span>        <span class="n">pathGrid</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>

        <span class="c1"># Seed: exactly one way to “be” at the start (if not blocked)
</span>        <span class="n">pathGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># First column: only from above; if an obstacle appears,
</span>        <span class="c1"># everything below remains 0 (no way around in the same column)
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="n">pathGrid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">obstacleGrid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">pathGrid</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># First row: only from left; if an obstacle appears,
</span>        <span class="c1"># everything to the right remains 0 (no way around in the same row)
</span>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">pathGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">obstacleGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">pathGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Inner cells: if not an obstacle → sum of top + left (Pascal with walls)
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="c1"># If there is an obstacle
</span>                <span class="k">if</span> <span class="n">obstacleGrid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">pathGrid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># If there is no obstacle, sum top and left
</span>                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pathGrid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">pathGrid</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">pathGrid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Answer: ways to reach bottom-right
</span>        <span class="k">return</span> <span class="n">pathGrid</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Complexity:
</span>        <span class="c1"># Time = O(mn)
</span>        <span class="c1"># Space = O(mn)
</span>
</code></pre></div></div>

<h2 id="minimum-path-sum---medium">Minimum Path Sum - Medium</h2>

<p><a href="https://leetcode.com/problems/unique-paths-ii/description/?envType=problem-list-v2&amp;envId=dynamic-programming">Leetcode Link</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minPathSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># Inputs: List[List[int]]
</span>        <span class="c1"># Outputs: int
</span>        <span class="c1"># Descriptions:
</span>            <span class="c1"># Grid with NON Negative values
</span>            <span class="c1"># Find a path from top left to bottom right, minimizes the sum
</span>
        <span class="c1"># Example 1:
</span>        <span class="c1"># Inputs -&gt; grid = [[1,3,1],[1,5,1],[4,2,1]]
</span>        <span class="c1"># Outputs -&gt; 7
</span>        <span class="c1"># Example 2:
</span>        <span class="c1"># Inputs -&gt; grid = [[1,2,3],[4,5,6]]
</span>        <span class="c1"># Outputs -&gt; 12
</span>        <span class="c1"># Understanding:
</span>            <span class="c1"># Think of as Tolls per Cell
</span>            <span class="c1"># You are finding the "accumulative minimum cost"
</span>            <span class="c1"># The local minimum will eventually build the "global" minimum
</span>
        <span class="c1"># Setup
</span>        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Prefix sums along first row
</span>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
            <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Prefix sums along the first column
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="p">):</span>
            <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Fill the rest
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">grid</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Complexity
</span>        <span class="c1"># Time -&gt; O(nm)
</span>        <span class="c1"># Space -&gt; O(nm)
</span></code></pre></div></div>

<h2 id="is-subsequence---easy">Is Subsequence - Easy</h2>

<p><a href="https://leetcode.com/problems/unique-paths-ii/description/?envType=problem-list-v2&amp;envId=dynamic-programming">Leetcode Link</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSubsequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># Inputs: str, str
</span>        <span class="c1"># Outputs: bool
</span>        <span class="c1"># Description:
</span>            <span class="c1"># Subsequence -&gt; s is formed by deleting some(or nill) of the characters
</span>            <span class="c1"># Preserving the order
</span>            <span class="c1"># "ace" -&gt; abcde -&gt; true
</span>            <span class="c1"># "aec" -&gt; abcde -&gt; false
</span>        <span class="c1"># Example 1
</span>        <span class="c1"># Inputs -&gt; s = "abc", t = "ahbgdc"
</span>        <span class="c1"># Output -&gt; True
</span>
        <span class="c1"># Example 2
</span>        <span class="c1"># Inputs -&gt; s = "axc", t = "ahbgdc"
</span>        <span class="c1"># Output -&gt; False
</span>        
        <span class="c1"># Edge Case
</span>        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s">""</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="c1"># Iterate and pointer
</span>        <span class="n">s_pointer</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">character</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">character</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">s_pointer</span><span class="p">]:</span>
                <span class="n">s_pointer</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># Early exit
</span>                <span class="k">if</span> <span class="n">s_pointer</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

        <span class="c1"># Walk through an example
</span>        <span class="c1"># t = ahbgdc
</span>        <span class="c1"># s = abc
</span>        <span class="c1"># Iteration 1
</span>            <span class="c1"># a, s_pointer = 0
</span>            <span class="c1"># a == s[s_pointer] --&gt; s_pointer += 1 = 1
</span>        <span class="c1"># Iteration 2
</span>            <span class="c1"># h, s_pointer = 1
</span>            <span class="c1"># h != s[s_pointer] 
</span>        <span class="c1"># Iteration 3
</span>            <span class="c1"># b, s_pointer = 1
</span>            <span class="c1"># b == s[pointer] --&gt; s_pointer += 1 = 2
</span>        <span class="c1"># Iteration 4
</span>            <span class="c1"># g, s_pointer = 2
</span>            <span class="c1"># g != s[s_pointer]
</span>        <span class="c1"># iteration 5
</span>            <span class="c1"># d, s_pointer = 2
</span>            <span class="c1"># d != s[s_pointer]
</span>        <span class="c1"># iteration 6
</span>            <span class="c1"># c, s_pointer = 2
</span>            <span class="c1"># c == s[s_pointer] -&gt; s_pointer += 1 = 3
</span>            <span class="c1"># s_pointer == len(s) -&gt; Return True
</span></code></pre></div></div>

<h2 id="fibonacci-number---easy">Fibonacci Number - Easy</h2>

<p><a href="https://leetcode.com/problems/unique-paths-ii/description/?envType=problem-list-v2&amp;envId=dynamic-programming">Leetcode Link</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># Inputs: int
</span>        <span class="c1"># Outputs: int
</span>        <span class="c1"># Description:
</span>            <span class="c1"># F(n-1) + F(n-2) 
</span>        
        <span class="c1"># Typical Recursion Appraoch
</span>        <span class="c1"># if n == 0:
</span>        <span class="c1">#     return 0
</span>        <span class="c1"># if n == 1:
</span>        <span class="c1">#     return 1
</span>        
        <span class="c1"># return self.fib(n-1) + self.fib(n-2)
</span>        <span class="c1"># Complexity
</span>        <span class="c1"># Time O(2^n)
</span>        <span class="c1"># Space O(n)
</span>
        <span class="c1"># Dynamic Programming approach
</span>        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span>
        <span class="c1"># We create a list
</span>        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># We calculate the list
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Append the value
</span>            <span class="n">dp</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="c1"># Complexity:
</span>        <span class="c1"># Time O(n)
</span>        <span class="c1"># Space O(n)
</span>
</code></pre></div></div>

<h2 id="nth-tribonacci-number">Nth Tribonacci Number</h2>

<p><a href="https://leetcode.com/problems/unique-paths-ii/description/?envType=problem-list-v2&amp;envId=dynamic-programming">Leetcode Link</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">tribonacci</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># Inputs: int
</span>        <span class="c1"># Outputs: int
</span>        <span class="c1"># Description:
</span>            <span class="c1"># T3 = T0 + T1 + T2
</span>
        <span class="c1"># Setup
</span>        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Iterate
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dp</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="c1"># Complexity
</span>        <span class="c1"># Time - O(n)
</span>        <span class="c1"># Space - O(n)
</span></code></pre></div></div>

<h2 id="maximum-repeating-substring---easy">Maximum Repeating Substring - Easy</h2>

<p><a href="https://leetcode.com/problems/unique-paths-ii/description/?envType=problem-list-v2&amp;envId=dynamic-programming">Leetcode Link</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxRepeating</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># Inputs: str, str
</span>        <span class="c1"># Outputs: int
</span>        <span class="c1"># Description:
</span>            <span class="c1"># Occurence of "word" in sequence
</span>        <span class="c1"># Count
</span>        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Current Word
</span>        <span class="n">cur</span> <span class="o">=</span> <span class="n">word</span>
        <span class="c1"># Keep Iterating and add word to cur
</span>        <span class="c1"># Breaks when it is no longer a substring
</span>        <span class="k">while</span> <span class="n">cur</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">cur</span> <span class="o">+=</span> <span class="n">word</span>
        <span class="k">return</span> <span class="n">k</span>
        <span class="c1"># Think about it in a reverse manner
</span>        <span class="c1"># how many words keeps it in "Sequence"
</span>        <span class="c1"># Complexity:
</span>        <span class="c1"># Time - O(kn) - n = len of sequence
</span>        <span class="c1"># Space - O(km) - m = len of word
</span>

</code></pre></div></div>

    </article>
  </main>

  <div id="imageModal" class="image-modal">
  <div class="modal-content">
    <span class="modal-close">&times;</span>
    <button class="modal-nav modal-prev">&#8249;</button>
    <button class="modal-nav modal-next">&#8250;</button>
    <img id="modalImage" src="" alt="">
    <div id="modalCaption"></div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const modal = document.getElementById('imageModal');
  const modalImg = document.getElementById('modalImage');
  const modalCaption = document.getElementById('modalCaption');
  const modalClose = document.querySelector('.modal-close');
  const modalPrev = document.querySelector('.modal-prev');
  const modalNext = document.querySelector('.modal-next');

  let modalImages = [];
  let currentIndex = -1;
  let currentScale = 1;
  const scaleFactor = 0.1;

  function refreshModalImages() {
    modalImages = Array.from(document.querySelectorAll('.modal-trigger'));
  }

  function updateImageTransform() {
    modalImg.style.transform = `scale(${currentScale})`;
    modalImg.style.transition = 'transform 0.1s ease';
  }

  function openModalAtIndex(index) {
    if (!modalImages.length) {
      return;
    }

    if (index < 0) {
      index = modalImages.length - 1;
    } else if (index >= modalImages.length) {
      index = 0;
    }

    currentIndex = index;
    const target = modalImages[currentIndex];
    if (!target) {
      return;
    }

    const src = target.dataset.modalSrc || target.src;
    const caption = target.getAttribute('data-caption') || target.alt;

    modalImg.src = src;
    modalCaption.textContent = caption || '';
    modal.classList.add('show');
    currentScale = 1;
    updateImageTransform();
    document.body.style.overflow = 'hidden';
  }

  function closeModal() {
    modal.classList.remove('show');
    document.body.style.overflow = '';
    currentScale = 1;
    currentIndex = -1;
    delete modal.dataset.initialDistance;
  }

  refreshModalImages();

  document.addEventListener('click', function(e) {
    if (!e.target.classList.contains('modal-trigger')) {
      return;
    }

    if (!modalImages.length) {
      refreshModalImages();
    }

    let index = modalImages.indexOf(e.target);
    if (index === -1) {
      refreshModalImages();
      index = modalImages.indexOf(e.target);
    }

    if (index === -1) {
      return;
    }

    openModalAtIndex(index);
  });

  modalClose.addEventListener('click', closeModal);
  modal.addEventListener('click', function(e) {
    if (e.target === modal) {
      closeModal();
    }
  });

  document.addEventListener('keydown', function(e) {
    if (!modal.classList.contains('show')) {
      return;
    }

    switch (e.key) {
      case 'Escape':
        closeModal();
        break;
      case 'ArrowLeft':
        e.preventDefault();
        openModalAtIndex(currentIndex - 1);
        break;
      case 'ArrowRight':
        e.preventDefault();
        openModalAtIndex(currentIndex + 1);
        break;
      case '+':
      case '=':
        e.preventDefault();
        currentScale = Math.min(currentScale + scaleFactor, 3);
        updateImageTransform();
        break;
      case '-':
        e.preventDefault();
        currentScale = Math.max(currentScale - scaleFactor, 0.1);
        updateImageTransform();
        break;
      case '0':
        e.preventDefault();
        currentScale = 1;
        updateImageTransform();
        break;
    }
  });

  modal.addEventListener('wheel', function(e) {
    if (!modal.classList.contains('show')) {
      return;
    }

    e.preventDefault();
    const delta = e.deltaY > 0 ? -scaleFactor : scaleFactor;
    currentScale = Math.max(0.1, Math.min(3, currentScale + delta));
    updateImageTransform();
  }, { passive: false });

  if (modalPrev) {
    modalPrev.addEventListener('click', function(e) {
      e.preventDefault();
      if (currentIndex === -1) {
        return;
      }
      openModalAtIndex(currentIndex - 1);
    });
  }

  if (modalNext) {
    modalNext.addEventListener('click', function(e) {
      e.preventDefault();
      if (currentIndex === -1) {
        return;
      }
      openModalAtIndex(currentIndex + 1);
    });
  }

  modal.addEventListener('touchstart', function(e) {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (e.touches.length === 2) {
      const [touch1, touch2] = e.touches;
      modal.dataset.initialDistance = Math.hypot(
        touch1.clientX - touch2.clientX,
        touch1.clientY - touch2.clientY
      );
    } else {
      e.preventDefault();
    }
  }, { passive: false });

  modal.addEventListener('touchmove', function(e) {
    if (!modal.classList.contains('show') || e.touches.length !== 2) {
      return;
    }

    e.preventDefault();
    const [touch1, touch2] = e.touches;
    const currentDistance = Math.hypot(
      touch1.clientX - touch2.clientX,
      touch1.clientY - touch2.clientY
    );
    const initialDistance = parseFloat(modal.dataset.initialDistance || '0');
    if (initialDistance > 0) {
      const scaleChange = (currentDistance - initialDistance) / initialDistance;
      currentScale = Math.max(0.1, Math.min(3, currentScale + scaleChange * 0.5));
      updateImageTransform();
      modal.dataset.initialDistance = currentDistance;
    }
  }, { passive: false });
});

// PlantUML Hover Tooltip functionality
document.addEventListener('DOMContentLoaded', function() {
  document.querySelectorAll('[data-snippet-id]').forEach(function(caption) {
    const snippetId = caption.getAttribute('data-snippet-id');
    const snippetElement = document.getElementById(snippetId);

    if (snippetElement) {
      const content = snippetElement.textContent.replace(/"/g, '&quot;');
      caption.setAttribute('data-tooltip', content);
      caption.classList.add('diagram-caption');
    }
  });
});
</script>


  <!-- Floating Table of Contents -->
  <div id="floating-toc" class="floating-toc">
    <div class="toc-icon">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="8" y1="6" x2="21" y2="6"></line>
        <line x1="8" y1="12" x2="21" y2="12"></line>
        <line x1="8" y1="18" x2="21" y2="18"></line>
        <line x1="3" y1="6" x2="3.01" y2="6"></line>
        <line x1="3" y1="12" x2="3.01" y2="12"></line>
        <line x1="3" y1="18" x2="3.01" y2="18"></line>
      </svg>
    </div>
    <div class="toc-content">
      <div class="toc-header">
        <span>Contents</span>
        <button class="toc-close" aria-label="Close table of contents">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <nav class="toc-nav" id="toc-nav">
        <!-- Generated by JavaScript -->
      </nav>
    </div>
  </div>

  <footer class="site-footer">
    <span>© 2025 glucolte • </span>
    <a href="https://github.com/gLuColte/glucolte.github.io">source</a>
  </footer>

  <script>
    // Dark mode functionality
    function initDarkMode() {
      const toggle = document.getElementById('dark-mode-toggle');
      const body = document.body;
      
      // Check for saved theme preference or default to light mode
      const savedTheme = localStorage.getItem('theme');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      
      if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
        body.setAttribute('data-theme', 'dark');
      }
      
      // Toggle dark mode
      if (toggle) {
        toggle.addEventListener('click', function() {
          const currentTheme = body.getAttribute('data-theme');
          const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
          
          body.setAttribute('data-theme', newTheme);
          localStorage.setItem('theme', newTheme);
        });
      }
    }
    
    // Initialize dark mode immediately to prevent flash
    initDarkMode();
    
    // Initialize highlight.js and floating TOC after the DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      hljs.highlightAll();
      
      // Floating TOC functionality - only show on sub-study pages
      const floatingToc = document.getElementById('floating-toc');
      const tocNav = document.getElementById('toc-nav');
      const tocClose = document.querySelector('.toc-close');
      
      // Check if we're on a sub-study page (not the main study index)
      const isSubStudyPage = window.location.pathname !== '/study/' && 
                            window.location.pathname !== '/study' && 
                            window.location.pathname.startsWith('/study/');
      
      if (floatingToc && tocNav && isSubStudyPage) {
        // Generate TOC from headings
        function generateTOC() {
          const headings = document.querySelectorAll('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6');
          if (headings.length === 0) {
            floatingToc.style.display = 'none';
            return;
          }
          
          const tocList = document.createElement('ul');
          let currentLevel = 0;
          let currentList = tocList;
          const listStack = [tocList];
          
          headings.forEach((heading, index) => {
            const level = parseInt(heading.tagName.charAt(1));
            const id = heading.id || `heading-${index}`;
            
            // Ensure heading has an ID
            if (!heading.id) {
              heading.id = id;
            }
            
            // Create list item
            const listItem = document.createElement('li');
            const link = document.createElement('a');
            link.href = `#${id}`;
            link.textContent = heading.textContent.trim();
            link.addEventListener('click', function(e) {
              e.preventDefault();
              const targetElement = document.getElementById(id);
              if (targetElement) {
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                // Close TOC after clicking
                floatingToc.classList.remove('toc-open');
              }
            });
            
            listItem.appendChild(link);
            
            // Handle nesting
            if (level > currentLevel) {
              // Go deeper
              for (let i = currentLevel; i < level; i++) {
                const newList = document.createElement('ul');
                currentList.appendChild(newList);
                listStack.push(newList);
                currentList = newList;
              }
            } else if (level < currentLevel) {
              // Go shallower
              for (let i = currentLevel; i > level; i--) {
                listStack.pop();
                currentList = listStack[listStack.length - 1];
              }
            }
            
            currentList.appendChild(listItem);
            currentLevel = level;
          });
          
          tocNav.appendChild(tocList);
        }
        
        // Generate the TOC
        generateTOC();
        
        // Handle close button
        if (tocClose) {
          tocClose.addEventListener('click', function() {
            floatingToc.classList.remove('toc-open');
          });
        }
        
        // Handle click on icon to toggle
        const tocIcon = document.querySelector('.toc-icon');
        if (tocIcon) {
          tocIcon.addEventListener('click', function() {
            floatingToc.classList.toggle('toc-open');
          });
        }
        
        // Active section highlighting
        function updateActiveSection() {
          const headings = document.querySelectorAll('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6');
          const tocLinks = tocNav.querySelectorAll('a');
          
          // Remove active class from all links
          tocLinks.forEach(link => link.classList.remove('active'));
          
          // Find the current section
          let currentHeading = null;
          const scrollPosition = window.scrollY + 100; // Offset for better UX
          
          for (let i = headings.length - 1; i >= 0; i--) {
            const heading = headings[i];
            const headingTop = heading.offsetTop;
            
            if (headingTop <= scrollPosition) {
              currentHeading = heading;
              break;
            }
          }
          
          // Add active class to current section
          if (currentHeading) {
            const activeLink = tocNav.querySelector(`a[href="#${currentHeading.id}"]`);
            if (activeLink) {
              activeLink.classList.add('active');
            }
          }
        }
        
        // Update active section on scroll
        let scrollTimeout;
        window.addEventListener('scroll', function() {
          if (scrollTimeout) {
            clearTimeout(scrollTimeout);
          }
          scrollTimeout = setTimeout(updateActiveSection, 10);
        });
        
        // Initial update
        updateActiveSection();
      } else if (floatingToc && !isSubStudyPage) {
        // Hide floating TOC on main study page
        floatingToc.style.display = 'none';
      }
      
      // Legacy TOC functionality (for existing markdown TOCs)
      const toc = document.querySelector('#markdown-toc');
      if (toc) {
        // Hide the floating TOC if there's already a markdown TOC
        if (floatingToc) {
          floatingToc.style.display = 'none';
        }
        
        // Create TOC container with header
        const tocContainer = document.createElement('div');
        tocContainer.className = 'toc-container';
        tocContainer.style.cssText = `
          background: #f8fafc;
          border: 1px solid #e5e7eb;
          border-radius: 8px;
          padding: 16px;
          margin: 20px 0;
          position: relative;
        `;
        
        // Add TOC header
        const tocHeader = document.createElement('h3');
        tocHeader.textContent = 'Table of Contents';
        tocHeader.style.cssText = `
          margin: 0 0 12px 0;
          font-size: 16px;
          font-weight: 600;
          color: #374151;
        `;
        
        // Add back to top button
        const backToTopBtn = document.createElement('button');
        backToTopBtn.textContent = '↑ Top';
        backToTopBtn.style.cssText = `
          position: absolute;
          top: 12px;
          right: 12px;
          background: #ffffff;
          border: 1px solid #d1d5db;
          border-radius: 6px;
          padding: 4px 8px;
          font-size: 12px;
          cursor: pointer;
          color: #6b7280;
          transition: all 0.2s ease;
        `;
        
        // Add hover effect for back to top button
        backToTopBtn.addEventListener('mouseenter', function() {
          this.style.background = '#f3f4f6';
          this.style.color = '#374151';
        });
        
        backToTopBtn.addEventListener('mouseleave', function() {
          this.style.background = '#ffffff';
          this.style.color = '#6b7280';
        });
        
        // Back to top functionality
        backToTopBtn.addEventListener('click', function() {
          window.scrollTo({ top: 0, behavior: 'smooth' });
        });
        
        // Style the TOC list
        toc.style.cssText = `
          margin: 0;
          padding: 0;
          font-size: 14px;
          line-height: 1.5;
        `;
        
        // Insert header and button into container
        tocContainer.appendChild(tocHeader);
        tocContainer.appendChild(backToTopBtn);
        tocContainer.appendChild(toc);
        
        // Replace the original TOC with the new container
        toc.parentNode.insertBefore(tocContainer, toc);
        tocContainer.appendChild(toc);
        
        // Add smooth scrolling to TOC links
        const tocLinks = toc.querySelectorAll('a');
        tocLinks.forEach(link => {
          link.addEventListener('click', function(e) {
            e.preventDefault();
            const targetId = this.getAttribute('href').substring(1);
            const targetElement = document.getElementById(targetId);
            if (targetElement) {
              targetElement.scrollIntoView({ behavior: 'smooth' });
            }
          });
        });
      }
    });
  </script>
</body>
</html>
