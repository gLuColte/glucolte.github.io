<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>RDS · glucolte</title>
  <meta name="description" content="notes • principles • systems">
  <link rel="stylesheet" href="/assets/style.css">
  <link rel="stylesheet" href="/assets/study.css">
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/favicon.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>RDS | glucolte</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="RDS" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="notes • principles • systems" />
<meta property="og:description" content="notes • principles • systems" />
<link rel="canonical" href="http://localhost:4000/study/tmp_awsProDatabases.html" />
<meta property="og:url" content="http://localhost:4000/study/tmp_awsProDatabases.html" />
<meta property="og:site_name" content="glucolte" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="RDS" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"notes • principles • systems","headline":"RDS","url":"http://localhost:4000/study/tmp_awsProDatabases.html"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
  <header class="site-header">
  <a class="brand" href="/">glucolte</a>
  <nav class="nav">
    <a href="/principles">principles</a>
    <a href="/rules">rules</a>
    <a href="/stretches">stretches</a>
    <a href="/study/">study</a>
    <a href="/projects/">projects</a>
    <a href="/setup/">setup</a>
  </nav>
  <button id="dark-mode-toggle" class="dark-mode-toggle" aria-label="Toggle dark mode">
    <svg class="sun-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
    <svg class="moon-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
    </svg>
  </button>
</header>


  <main class="container">
    <article class="content">
      <h2 id="rds">RDS</h2>
<ul>
  <li>Database Server as a Service ( NOT DBaaS )
    <ul>
      <li>Subnet Group (Spams across AZs)</li>
      <li>RDS can be configured with public addressing if you are on public subnet</li>
      <li>Primary/Standup
        <ul>
          <li>You can pick or randomly assigned</li>
          <li>Primary and Standup is on different subnets (Multi AZs)</li>
        </ul>
      </li>
      <li>RDS instance
        <ul>
          <li>can have multiple Database</li>
          <li>Dedicated storage EBD</li>
          <li>Uses Database CNAME</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Multi AZ - Instance:
    <ul>
      <li>Synchronous Replication
        <ul>
          <li>Replication is at Storage Level</li>
        </ul>
      </li>
      <li>You access via CNAME
        <ul>
          <li>which hits Primary</li>
          <li>Standby is never directly access, only when failure occured</li>
        </ul>
      </li>
      <li>Backup and Snap is also replicated across s3</li>
      <li>Primay AND Replicated to Standby = Commited</li>
      <li>ONLY one standBy Replica</li>
      <li>failure happes 60-120</li>
      <li>only fail over in the same region</li>
    </ul>
  </li>
  <li>Multi AZ - Clusters:
    <ul>
      <li>1 writer and 2 Reader</li>
      <li>Writer replicate to Readers on different Az</li>
      <li>Synchronous Replications from Writers to Readers
        <ul>
          <li>Data is committed when 1_ reader finihsed writing</li>
        </ul>
      </li>
      <li>Reader endpoint directs any reads at an Avialble Reader</li>
      <li>Instance endpoints are used for Testing fault fiding</li>
      <li>Replication is done via transaction Logs</li>
      <li>Failover is faster ~35 seconds + transaction log apply</li>
    </ul>
  </li>
  <li>Read Replica
    <ul>
      <li>Asynchronous Replication</li>
      <li>It is separate to MultiAz Instance/Clusters
        <ul>
          <li>It adds ON TOP</li>
          <li>you need a Database choice then do read replica</li>
        </ul>
      </li>
      <li>Replicate to the standby</li>
      <li>5x direct read relpica per DB instance
        <ul>
          <li>Read Replica can have their own read replica</li>
          <li>Lag starts to be a problem (as more level you build)</li>
        </ul>
      </li>
      <li>Snapshot/Backups Improve RPO</li>
      <li>RTO are problem (Restoring snapsort)
        <ul>
          <li>RR offer Near Zero RPO</li>
          <li>can promte a read relpica as Primary fast</li>
          <li>Failure ONLY
            <ul>
              <li>NOT FOR DATA CORRUPTION (as read replica probably poisoned too)</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Cheap way to achive Global availability</li>
    </ul>
  </li>
  <li>Backups &amp; Snapshots
    <ul>
      <li>Automated Backups
        <ul>
          <li>Once Per day (Similar to Snapshot)</li>
          <li>Taken during Maintenance Windo you set</li>
          <li>Backup occurs on the Standby</li>
          <li>Transaction Logs are stored on s3 every 5 minutes
            <ul>
              <li>5 minutes RPO</li>
            </ul>
          </li>
          <li>Auto cleaned up</li>
          <li>Retention 0 - 35 days</li>
          <li>Can replicated across to a destination region</li>
          <li>HAS TO BE CONFIGURED, DISABLED BY DEFAULT</li>
        </ul>
      </li>
      <li>Snapshots (Manually done )
        <ul>
          <li>Taking off the instance</li>
          <li>First snap shot is FULL size consumed data</li>
          <li>Then onwards is Incremental</li>
          <li>YOU HAVE TO MANUALLY DELETE IT</li>
        </ul>
      </li>
      <li>Everything Stored in AWS Managed S3 Buckets
        <ul>
          <li>Can replicate across Different buckets</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Restores
    <ul>
      <li>Creates a new RDS Instance -new address</li>
      <li>Snapshot = single point int time (creation time)
        <ul>
          <li>RPO</li>
        </ul>
      </li>
      <li>Automated = Any 5 mimnute point in time</li>
      <li>Backup is restored and transcation logsare replayed</li>
      <li>Restores aint fast (RTOs)</li>
    </ul>
  </li>
  <li>Costs factors:
    <ul>
      <li>Instance Size &amp; Type (Similar to EC2 INstacne)</li>
      <li>MultiAZ</li>
      <li>Storage Type &amp; Amount (Similar to EBS)</li>
      <li>Data Transferred
        <ul>
          <li>In and out of RDS</li>
        </ul>
      </li>
      <li>Backups &amp; Snapshots
        <ul>
          <li>Storage cost (per GB month cost)</li>
        </ul>
      </li>
      <li>Licensing (if applicable)</li>
    </ul>
  </li>
  <li>Data Security
    <ul>
      <li>SSL/TLS is available for RDS (Data in transit)</li>
      <li>RDS Supports EBS Volume encryption - KMS</li>
      <li>Handled by HOST/EBS
        <ul>
          <li>AWS/Customer generates data keys</li>
        </ul>
      </li>
      <li>Storage, logs, snapshots and replicas are encrypted</li>
      <li>ENCRYPTION CAN NOT BE REMOVED AFTER</li>
      <li>
        <p>RDS MSSQL and RDS Oracle Support Transparent Data Encryption ( TDE)</p>
      </li>
      <li>CloudHSM -&gt; for RDS ORACLE
        <ul>
          <li>You managed Key Manager, NOT TRUSTING AWS</li>
        </ul>
      </li>
      <li>the keys are use on RDS HOSTS, they encrypt it and RDS stores the encrypted data
        <ul>
          <li>They dont need engine to decrypt, as the HOST does it</li>
        </ul>
      </li>
      <li>IAM Authentication
        <ul>
          <li>Its another choice to control access</li>
          <li>A mapping of IAM Identity onto the local RDS server
            <ul>
              <li>Generate a 15 minutes token to create a set of credentials to log in</li>
            </ul>
          </li>
          <li>Authorization still depends on Local RDS setup</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="aurora">Aurora</h3>
<ul>
  <li>Custom Engine
    <ul>
      <li>Cluster</li>
      <li>Single Primary instance +  0 or more replicas</li>
      <li>Aurora uses shared cluster volume instaed of local storage
        <ul>
          <li>128 TiB, 6 Replicas, AZs</li>
          <li>Replication HAPPENS on the storage level</li>
          <li>SSD Based -&gt; High IOPS low latency</li>
          <li>You dont specify storage, its billed by whats used</li>
        </ul>
      </li>
      <li>By Default
        <ul>
          <li>Primary can only be used for write</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Endpoints
    <ul>
      <li>Cluster Endpoint</li>
      <li>Read Endpoint
        <ul>
          <li>Can point to multiple (easier comparing against RDS Cluster Option)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>COST:
    <ul>
      <li>No free tier</li>
      <li>Does not support Micro Instances</li>
      <li>Beyond RDS singleAZ auroa offers better value</li>
      <li>Storage - GB-Month consumer, IO cost per request</li>
      <li>100% DB Size in backups are included</li>
    </ul>
  </li>
  <li>Restore/Clone/Backtrack
    <ul>
      <li>Same as RDS</li>
      <li>Restores create a new cluster</li>
      <li>Backtrack can be used to a previous point in time (Data Corruption fix)</li>
      <li>Fast clones makes a new database much faster, and only copy the difference</li>
    </ul>
  </li>
</ul>

<p>NEED TO FIGURE OUT AURORA VS MULTI AZ CLUST and INSTANCE</p>

<h3 id="aurora-serverless">Aurora Serverless</h3>
<ul>
  <li>Version of Aurora that does not need Server managing</li>
  <li>Similar to Aurora, but charged by ACU (Aurora Capacity Unit)
    <ul>
      <li>ACU is provided via AWS’s pool</li>
      <li>Proxy is used to connect to ACU which then use to interact with storage</li>
      <li>You configure based on  Min and MAX ACU
        <ul>
          <li>The cluster auto adjust it self and can be paused</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Sitatuion:
    <ul>
      <li>Infrequently used applications</li>
      <li>Only pay for resources on per second basis</li>
      <li>New APplication (When you are not sure of instance size and etc)</li>
      <li>Variable/Unpredictable Wrokloads</li>
      <li>Development and test database</li>
      <li>Multi-tenant applications</li>
    </ul>
  </li>
</ul>

<h2 id="aurora-multi-master">Aurora Multi Master</h2>
<ul>
  <li>Multiple instance that is capable of Read and Write</li>
  <li>All instnaces are R/W</li>
  <li>Same cluster structure to Aurora Cluster
    <ul>
      <li>No Custom Endpoint to use</li>
      <li>No Endpoint balancing</li>
      <li>You can initiate to any instance</li>
    </ul>
  </li>
  <li>When a write happens to a Instance
    <ul>
      <li>it checks and commits to all AZ’s storage
        <ul>
          <li>If it has no conflict, the it can commit
            <ul>
              <li>then Instance are sync for cache data</li>
            </ul>
          </li>
          <li>if it has a CONFLICT</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Situtation
    <ul>
      <li>Faster Fail over comparing to Aurora Cluster (Single Master - as Endopint need to be update to point to Read Replica - Take time to change endpoint), when faill over happens, it immediately connect to another writer</li>
      <li>Fault Tolerant Application</li>
    </ul>
  </li>
</ul>

<h2 id="rds-proxy">RDS Proxy</h2>
<ul>
  <li>Situation
    <ul>
      <li>Opening and Closing Connections consume resources - Takes time and creates latency
        <ul>
          <li>e.g. Serverless Lambda hitting RDS</li>
        </ul>
      </li>
      <li>Failure of DB instance is hard</li>
      <li>Doing it within application add risks</li>
    </ul>
  </li>
  <li>RDS Proxy is to manage the above
    <ul>
      <li>Application connects to Proxy (which has a pool of connections maintained open) to Database</li>
    </ul>
  </li>
  <li>Deployed on VPC</li>
  <li>Multiplexing is used</li>
  <li>Long Term Connection Pool</li>
  <li>Abstracts failure away from Application when DB failure happen
    <ul>
      <li>Proxy stays on “WAIT” when failure to DB is unresponseive (failover)</li>
    </ul>
  </li>
  <li>When to use
    <ul>
      <li>Too many connections errors</li>
      <li>DB instance using t2/t3 small burst</li>
      <li>You use Lambda time saved/connect reuse</li>
      <li></li>
    </ul>
  </li>
  <li>Key points
    <ul>
      <li>Fully Managed Proxy for RDS/AUrora
        <ul>
          <li>AUto scaling, HA</li>
        </ul>
      </li>
      <li>Provides connection Pooling - reduce DB Load</li>
      <li>Accessible ONLY from a VPC (Private connected)</li>
      <li>Access through Proxy App Endpoints</li>
      <li>Can enforce SSl/TLS</li>
      <li>Reduce failover time by 50%</li>
      <li>Abstract failure away from applications</li>
    </ul>
  </li>
</ul>

<h2 id="rds-custom">RDS Custom</h2>
<ul>
  <li>Fills the gap bewween RDS and EC2 running a DB Engine
    <ul>
      <li>RDS -&gt; Fully Managed</li>
      <li>EC2 DB -&gt; You Manage</li>
    </ul>
  </li>
  <li>Give you the ability to utilize RDS, but also controll EC2 Server
    <ul>
      <li>You might need to manage HOST due to security/restriction</li>
    </ul>
  </li>
  <li>RDS Custom
    <ul>
      <li>Allows you to use SSH/RDP/Session Manager</li>
      <li>Works only for MS SQL and Oracle</li>
      <li>RDS Custom Database Auomtation
        <ul>
          <li>Pause to Customize</li>
          <li>Resume for full automation
<img src="./Screenshot%202025-10-09%20at%2022.58.10.png" alt="RDS Custom" /></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="dynamodb">DynamoDB</h2>
<ul>
  <li>Public Service</li>
  <li>NoSQL - Key/Value &amp; Document</li>
  <li>No Self-Managed Servers or infrastructure</li>
  <li>Capacity Options
    <ul>
      <li>Manual/Automatic Provisionsed/ On Demand</li>
    </ul>
  </li>
  <li>High Resilient across AZs (Optionally global)</li>
  <li>
    <p>SSD based -&gt; Single Digit Milisecond</p>
  </li>
  <li>Structure
    <ul>
      <li>A table is a grouping of items with the same Primary Key
        <ul>
          <li>Simple or Composite(Partion&amp;Sort) Primary Key</li>
        </ul>
      </li>
      <li>Each item must have a unique value for PK and SK
        <ul>
          <li>can have none, all, mixture or different attributes</li>
        </ul>
      </li>
      <li>Item Max 400KB</li>
      <li>Capacity means Speed NOT storage
        <ul>
          <li>1 WCU = 1KB per second</li>
          <li>1 RCU = 4KB per second</li>
        </ul>
      </li>
      <li>No rigid attribute schema</li>
      <li>No Query Langague like SQL</li>
    </ul>
  </li>
  <li>Backups
    <ul>
      <li>On Demand Backup -&gt; Manually created until removed
        <ul>
          <li>Restore to same/cross region</li>
          <li>with or without Indexes</li>
          <li>Adjust Encryption Settings</li>
        </ul>
      </li>
      <li>Point In Time Recovery
        <ul>
          <li>Not Enabled By Default</li>
          <li>Continuous record of chagnes allows replay to ANY point in the window (35 days)</li>
          <li>1 second granualrity</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>You pay for RCU,WCU,Storage and Features</li>
</ul>

<h2 id="read--write">Read / Write</h2>
<ul>
  <li>Every Operation consumes at least 1 RCU/WCU
    <ul>
      <li>1 RCU is 1 x 4 KB read operation per second
        <ul>
          <li>e.g. if you have an iteam = 400KB = 100 RCU</li>
        </ul>
      </li>
      <li>1 WCU is 1 x 1KB write operation per second
        <ul>
          <li>e.g. if you have an iteam = 400 kb = 400 WCU</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Every table has a RCU/WCU burst Pool (300 seconds)</li>
  <li>OnDemand
    <ul>
      <li>For Unknown, unpredictable and low admin</li>
      <li>Price per million R or W units</li>
    </ul>
  </li>
  <li>Provisioned
    <ul>
      <li>Set RCU/WCU set on a per table basis</li>
    </ul>
  </li>
</ul>

<h3 id="wcu-calculation">WCU Calculation</h3>
<ul>
  <li>If you need to store 10 items per second, 2.5 k average size per item
    <ul>
      <li>Calculate WCU per item Round up (Item Size/1KB)(3)</li>
      <li>Multiply by average number per second</li>
      <li>WCU required = 30</li>
    </ul>
  </li>
</ul>

<h2 id="query">Query</h2>
<ul>
  <li>Quey accepts a single PK calue and optionaly a SK or range, Capacity consumed is the size of ALL returned items.
    <ul>
      <li>can only query on PK or PK and SK</li>
    </ul>
  </li>
  <li>Further filtering discards data, capacity is still consumed.</li>
  <li>Always think on the WHOLE item, and Capacity returned
see <img src="./Screenshot%202025-10-10%20at%2010.18.32 am.png" alt="" /></li>
</ul>

<h2 id="scan">Scan</h2>
<ul>
  <li>Least efficient operation but most flexible</li>
  <li>Moves through a table consuming the capacity of EVERY ITEM.
    <ul>
      <li>e.g. you looking at an attribute, but you CONSUMED WHOEL TABLE and SPENT RCU
see <img src="./Screenshot%202025-10-10%20at%2010.21.57 am.png" alt="" /></li>
    </ul>
  </li>
</ul>

<h2 id="consistency">Consistency</h2>
<ul>
  <li>Every data is replicated to Nodes
    <ul>
      <li>each node is in different AZ</li>
    </ul>
  </li>
  <li>A leader Note is elected
    <ul>
      <li>Writes are always directed to Leader Node</li>
    </ul>
  </li>
  <li>Once the new data is written to Leader node
    <ul>
      <li>Replicated to Storage Nodes</li>
      <li>becomes “consistent”</li>
    </ul>
  </li>
  <li>EVENTUAL CONSISTENT
    <ul>
      <li>Not Every Second</li>
      <li>Stale Data might be read
  -&gt; Cheaper</li>
    </ul>
  </li>
  <li>STRONG CONSISTENT
    <ul>
      <li>Every Second</li>
      <li>Always use Leader Node for Latest Copy</li>
    </ul>
  </li>
</ul>

<h2 id="indexes">Indexes</h2>
<ul>
  <li>Situation
    <ul>
      <li>Query can only owrk on 1 PK value at a time</li>
      <li>Index allows Alterbative views on table data
        <ul>
          <li>Allows to chooose attributes as Keys
            <ul>
              <li>LSI -&gt; Use Differetn Sort Ket</li>
              <li>GSI -&gt; Use Different Primary and Sory Key</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Local Secondary Index
    <ul>
      <li>Strong consistent</li>
      <li>MUST be created with a table
        <ul>
          <li>e.g. when you create base table you create it too</li>
        </ul>
      </li>
      <li>5 LSI’s per base table</li>
      <li>Allows Alternative Sort Key on the Table</li>
      <li>Shares the RCU/WCU with the table</li>
      <li>Attributes -&gt; ALL/KeyONLY &amp; INCLUDE
<img src="./Screenshot%202025-10-10%20at%2010.46.24 am.png" alt="" /></li>
    </ul>
  </li>
  <li>Global Secondary Index
    <ul>
      <li>Own RCU/WCU</li>
      <li>Can be created any time</li>
      <li>Default to 20 per base table</li>
      <li>Eventual Consistent
<img src="./Screenshot%202025-10-10%20at%2011.02.42 am.png" alt="" /></li>
    </ul>
  </li>
</ul>

<h2 id="streams-and-triggers">Streams and Triggers</h2>
<p>Stream</p>
<ul>
  <li>Time ordered list of ITEM Changes in a table</li>
  <li>24 Hour Rolling window</li>
  <li>Need to enable on a per table basis</li>
  <li>Records INERSTS/UPDATES/DELETES</li>
  <li>Different View types</li>
  <li>Configuration have 4 types:
    <ul>
      <li>Keys Only</li>
      <li>New Image</li>
      <li>Old Image</li>
      <li>NEW and OLD Images
Triggers:</li>
    </ul>
  </li>
  <li>Serverless way</li>
  <li>If an item changes GENERATES an event
    <ul>
      <li>Event contains the data changed</li>
      <li>Action is taken</li>
    </ul>
  </li>
  <li>e.g. Streams + Lambda to respond to data change</li>
  <li>Reporting &amp; Analytics</li>
  <li>Aggregation/Messaging/Notification</li>
</ul>

<h2 id="ddb-accelerator">DDB Accelerator</h2>

<ul>
  <li>Traditionally
    <ul>
      <li>Application calls Cache In memory
        <ul>
          <li>If CACHE MISS, it fetch from Database,</li>
          <li>then another Call to store in CACHE</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>DAX
    <ul>
      <li>Application uses DAX SDK and make a single call for the data which is returned by DAX</li>
      <li>Basically you interact only with DAX
<img src="./Screenshot%202025-10-10%20at%2011.26.04 am.png" alt="" /></li>
    </ul>
  </li>
  <li>DAX
    <ul>
      <li>Operates inside VPC</li>
      <li>AZs based</li>
      <li>Cluster
        <ul>
          <li>1 AZ is Primary, other is Replica</li>
        </ul>
      </li>
      <li>Item Cache
        <ul>
          <li>Holds results of GetItem</li>
        </ul>
      </li>
      <li>Query Cache
        <ul>
          <li>holds data based on Query/Scan Parameters</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="./Screenshot%202025-10-10%20at%2011.29.04 am.png" alt="" /></p>

<ul>
  <li>Keys:
    <ul>
      <li>Primary node Writes, Replicas Read</li>
      <li>HA -&gt; Fail over happens</li>
      <li>In Memory Cache - Scaling Much Faster reads, reduced costs</li>
      <li>You can Scale UP or SCALE OUT on DAX Instances</li>
      <li>You can also write through DAX</li>
      <li>DAX IS PRIVATE SERVICE in VPC
        <ul>
          <li>DDB is Public Service</li>
        </ul>
      </li>
      <li>Taking down from Mili- to Micro Second capacity</li>
    </ul>
  </li>
</ul>

<h2 id="ddb-global-tables">DDB Global Tables</h2>
<ul>
  <li>Multi Master Cross Region
    <ul>
      <li>Everyone is Master</li>
    </ul>
  </li>
  <li>Tables are created in multiple regions and added to the same global table</li>
  <li>LAST WRITER WINS -&gt; Used for conflict resolution</li>
  <li>READ and WRITE to ANY REGION
    <ul>
      <li>Generaly sub-second replication between regions</li>
    </ul>
  </li>
  <li>Consistency
    <ul>
      <li>Can perform Strongly Consistent reads ONLY in the SAME region as writes</li>
    </ul>
  </li>
  <li>For Global HA/DR BC</li>
</ul>

<h2 id="ddb-ttl">DDB TTL</h2>
<ul>
  <li>Defines a per-item timestamp to determin when an item is no longer needed
    <ul>
      <li>DDB deletes the item after without consuming ANY WCU</li>
    </ul>
  </li>
  <li>No extra cost is needed</li>
  <li>On AWS side
    <ul>
      <li>a per-partition process periodically runs to check the current time in EPOCH the the TTL</li>
      <li>item older than current time is removed</li>
    </ul>
  </li>
  <li>You can configure a stream to listen to the TTL deletion happened</li>
</ul>

<h2 id="aws-elastic-search">AWS Elastic Search</h2>
<ul>
  <li>Managed of Elastic Search (Open Source)</li>
  <li>Alternative to AWS service like CloudWAtch if you already have Elasticsearch, Logstash, Kibanana stack (ELK)</li>
  <li>ELK Stack:
    <ul>
      <li>Elastich - Search/Indexing</li>
      <li>Kibana - Visualization/dashboard</li>
      <li>Logstash - Similar to CWLogs, need Logstash agent</li>
    </ul>
  </li>
</ul>

<h2 id="athena">Athena</h2>
<ul>
  <li>Serverless Interactive Querying Services</li>
  <li>AdHoc queries on data -&gt; PAY ONLY DATA CONSUMED</li>
  <li>SCHEMA ON READ
    <ul>
      <li>Table like translationwhen reading the data</li>
      <li>Original data on S3 never changed</li>
    </ul>
  </li>
  <li>
    <p>Output can be send to other services</p>
  </li>
  <li>How it works
    <ul>
      <li>Reads standard formats of structured/semi-sstructured/unstruute data sotred on s3</li>
      <li>Can also directly read CloudTral/ELB Logs/Flow Logs</li>
      <li>Data is conceptually “pointed” during read</li>
    </ul>
  </li>
  <li>Key points:
    <ul>
      <li>No Infrastructure</li>
      <li>Use when Loading/Transformation isn’t desired</li>
      <li>for Cost Consicous scenario</li>
      <li>Query Logs</li>
      <li>Glue Data Cataloge/Web server</li>
      <li>Can be a CONNECTOR to logs
        <ul>
          <li>Federated QUery</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="neptune">Neptune</h2>
<ul>
  <li>Managed Graph Database</li>
  <li>Like RDS but for Graph
    <ul>
      <li>VPC deployment</li>
      <li>MultiAZ/Scales via read replicas</li>
    </ul>
  </li>
  <li>Continuous Backup to S3</li>
</ul>

<h2 id="quantum-ledger-database-qldb">Quantum Ledger Database (QLDB)</h2>
<ul>
  <li>Feature:
    <ul>
      <li>Immutable append-only Ledge Based Database</li>
      <li>Cryptographically verifiable transaction log</li>
      <li>Transparent - FULL HISTORY is always accessible</li>
      <li>Serverless</li>
      <li>3AZ resiliene and replication within each AZ</li>
      <li>Can stream data to Amazon Kinesis</li>
      <li>Document DB Model</li>
      <li>ACID</li>
    </ul>
  </li>
  <li>Use case:
    <ul>
      <li>Finance - account balance/transactions</li>
      <li>Medical - Full history of data changes</li>
      <li>Logistics - Track movement of objects</li>
      <li>Legal - Track usage and change of data (custody)</li>
    </ul>
  </li>
</ul>

    </article>
  </main>

  <div id="imageModal" class="image-modal">
  <div class="modal-content">
    <span class="modal-close">&times;</span>
    <button class="modal-nav modal-prev">&#8249;</button>
    <button class="modal-nav modal-next">&#8250;</button>
    <img id="modalImage" src="" alt="">
    <div id="modalCaption"></div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const modal = document.getElementById('imageModal');
  const modalImg = document.getElementById('modalImage');
  const modalCaption = document.getElementById('modalCaption');
  const modalClose = document.querySelector('.modal-close');
  const modalPrev = document.querySelector('.modal-prev');
  const modalNext = document.querySelector('.modal-next');

  const SCALE_STEP = 0.2;
  const MIN_SCALE = 1;
  const MAX_SCALE = 3;

  let modalImages = [];
  let currentIndex = -1;
  let currentScale = MIN_SCALE;
  let translateX = 0;
  let translateY = 0;
  let isDragging = false;
  let isTouchDragging = false;
  let isPinching = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let pinchStartDistance = 0;
  let pinchStartScale = MIN_SCALE;
  let transitionTimeout;

  function refreshModalImages() {
    modalImages = Array.from(document.querySelectorAll('.modal-trigger'));
  }

  function applyTransform(withTransition = false) {
    if (currentScale <= MIN_SCALE) {
      currentScale = MIN_SCALE;
      translateX = 0;
      translateY = 0;
    }

    if (transitionTimeout) {
      clearTimeout(transitionTimeout);
      transitionTimeout = null;
    }

    modalImg.style.transition = withTransition ? 'transform 0.15s ease' : 'none';
    modalImg.style.transform = `translate(${translateX}px, ${translateY}px) scale(${currentScale})`;
    modalImg.style.cursor = currentScale > MIN_SCALE
      ? (isDragging || isTouchDragging ? 'grabbing' : 'grab')
      : 'auto';

    if (withTransition) {
      transitionTimeout = setTimeout(() => {
        modalImg.style.transition = 'none';
      }, 160);
    }
  }

  function resetTransform() {
    currentScale = MIN_SCALE;
    translateX = 0;
    translateY = 0;
    applyTransform(false);
  }

  function getDistance(touch1, touch2) {
    return Math.hypot(
      touch1.clientX - touch2.clientX,
      touch1.clientY - touch2.clientY
    );
  }

  function openModalAtIndex(index) {
    refreshModalImages();

    if (!modalImages.length) {
      return;
    }

    if (index < 0) {
      index = modalImages.length - 1;
    } else if (index >= modalImages.length) {
      index = 0;
    }

    const target = modalImages[index];
    if (!target) {
      return;
    }

    currentIndex = index;
    const src = target.dataset.modalSrc || target.src;
    const caption = target.getAttribute('data-caption') || target.alt;

    modalImg.src = src;
    modalCaption.textContent = caption || '';
    modal.classList.add('show');
    document.body.style.overflow = 'hidden';
    resetTransform();
  }

  function closeModal() {
    if (!modal.classList.contains('show')) {
      return;
    }
    modal.classList.remove('show');
    document.body.style.overflow = '';
    currentIndex = -1;
    isDragging = false;
    isTouchDragging = false;
    isPinching = false;
    resetTransform();
  }

  refreshModalImages();

  modalImg.addEventListener('dragstart', event => event.preventDefault());

  document.addEventListener('click', event => {
    const trigger = event.target.closest('.modal-trigger');
    if (!trigger) {
      return;
    }

    event.preventDefault();
    refreshModalImages();
    const index = modalImages.indexOf(trigger);
    openModalAtIndex(index > -1 ? index : 0);
  });

  modalClose?.addEventListener('click', closeModal);

  modal.addEventListener('click', event => {
    if (event.target === modal) {
      closeModal();
    }
  });

  document.addEventListener('keydown', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    switch (event.key) {
      case 'Escape':
        closeModal();
        break;
      case 'ArrowLeft':
        event.preventDefault();
        openModalAtIndex(currentIndex - 1);
        break;
      case 'ArrowRight':
        event.preventDefault();
        openModalAtIndex(currentIndex + 1);
        break;
      case '+':
      case '=':
        event.preventDefault();
        currentScale = Math.min(MAX_SCALE, currentScale + SCALE_STEP);
        applyTransform(true);
        break;
      case '-':
        event.preventDefault();
        currentScale = Math.max(MIN_SCALE, currentScale - SCALE_STEP);
        applyTransform(true);
        break;
      case '0':
        event.preventDefault();
        resetTransform();
        applyTransform(true);
        break;
      default:
        break;
    }
  });

  modal.addEventListener('wheel', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    event.preventDefault();
    const delta = event.deltaY > 0 ? -SCALE_STEP : SCALE_STEP;
    const nextScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, currentScale + delta));

    if (nextScale === currentScale) {
      return;
    }

    currentScale = nextScale;
    applyTransform(true);
  }, { passive: false });

  if (modalPrev) {
    modalPrev.addEventListener('click', event => {
      event.preventDefault();
      if (currentIndex === -1) {
        return;
      }
      openModalAtIndex(currentIndex - 1);
    });
  }

  if (modalNext) {
    modalNext.addEventListener('click', event => {
      event.preventDefault();
      if (currentIndex === -1) {
        return;
      }
      openModalAtIndex(currentIndex + 1);
    });
  }

  modalImg.addEventListener('mousedown', event => {
    if (!modal.classList.contains('show') || currentScale <= MIN_SCALE) {
      return;
    }

    event.preventDefault();
    isDragging = true;
    dragStartX = event.clientX;
    dragStartY = event.clientY;
    modalImg.style.cursor = 'grabbing';
  });

  document.addEventListener('mousemove', event => {
    if (!isDragging) {
      return;
    }

    event.preventDefault();
    translateX += event.clientX - dragStartX;
    translateY += event.clientY - dragStartY;
    dragStartX = event.clientX;
    dragStartY = event.clientY;
    applyTransform(false);
  });

  document.addEventListener('mouseup', () => {
    if (!isDragging) {
      return;
    }
    isDragging = false;
    modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
  });

  modalImg.addEventListener('touchstart', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (event.touches.length === 1 && currentScale > MIN_SCALE) {
      event.preventDefault();
      isTouchDragging = true;
      dragStartX = event.touches[0].clientX;
      dragStartY = event.touches[0].clientY;
      modalImg.style.cursor = 'grabbing';
    } else if (event.touches.length === 2) {
      event.preventDefault();
      isTouchDragging = false;
      isPinching = true;
      pinchStartDistance = getDistance(event.touches[0], event.touches[1]);
      pinchStartScale = currentScale;
      modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
    }
  }, { passive: false });

  modalImg.addEventListener('touchmove', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (isPinching && event.touches.length === 2) {
      event.preventDefault();
      const distance = getDistance(event.touches[0], event.touches[1]);
      if (pinchStartDistance > 0) {
        const scaleRatio = distance / pinchStartDistance;
        currentScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, pinchStartScale * scaleRatio));
        applyTransform(false);
      }
    } else if (isTouchDragging && event.touches.length === 1) {
      event.preventDefault();
      translateX += event.touches[0].clientX - dragStartX;
      translateY += event.touches[0].clientY - dragStartY;
      dragStartX = event.touches[0].clientX;
      dragStartY = event.touches[0].clientY;
      applyTransform(false);
    }
  }, { passive: false });

  modalImg.addEventListener('touchend', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (event.touches.length === 0) {
      isTouchDragging = false;
      modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
    }

    if (event.touches.length < 2) {
      isPinching = false;
      pinchStartDistance = 0;
      pinchStartScale = currentScale;
    }
  });

  modalImg.addEventListener('touchcancel', () => {
    if (!modal.classList.contains('show')) {
      return;
    }

    isTouchDragging = false;
    isPinching = false;
    pinchStartDistance = 0;
    pinchStartScale = currentScale;
    modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
  });

  modal.addEventListener('touchend', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (event.target === modal && event.changedTouches.length === 1 && !isTouchDragging && !isPinching) {
      closeModal();
    }
  }, { passive: true });
});
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('[data-snippet-id]').forEach(caption => {
    const snippetId = caption.getAttribute('data-snippet-id');
    const snippetElement = document.getElementById(snippetId);

    if (snippetElement) {
      const content = snippetElement.textContent.replace(/"/g, '&quot;');
      caption.setAttribute('data-tooltip', content);
      caption.classList.add('diagram-caption');
    }
  });
});
</script>


  <!-- Floating Table of Contents -->
  <div id="floating-toc" class="floating-toc">
    <div class="toc-icon">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="8" y1="6" x2="21" y2="6"></line>
        <line x1="8" y1="12" x2="21" y2="12"></line>
        <line x1="8" y1="18" x2="21" y2="18"></line>
        <line x1="3" y1="6" x2="3.01" y2="6"></line>
        <line x1="3" y1="12" x2="3.01" y2="12"></line>
        <line x1="3" y1="18" x2="3.01" y2="18"></line>
      </svg>
    </div>
    <div class="toc-content">
      <div class="toc-header">
        <span>Contents</span>
        <button class="toc-close" aria-label="Close table of contents">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <nav class="toc-nav" id="toc-nav">
        <!-- Generated by JavaScript -->
      </nav>
    </div>
  </div>

  <footer class="site-footer">
    <span>© 2025 glucolte • </span>
    <a href="https://github.com/gLuColte/glucolte.github.io">source</a>
  </footer>

  <script>
    // Dark mode functionality
    function initDarkMode() {
      const toggle = document.getElementById('dark-mode-toggle');
      const body = document.body;
      
      // Check for saved theme preference or default to light mode
      const savedTheme = localStorage.getItem('theme');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      
      if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
        body.setAttribute('data-theme', 'dark');
      }
      
      // Toggle dark mode
      if (toggle) {
        toggle.addEventListener('click', function() {
          const currentTheme = body.getAttribute('data-theme');
          const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
          
          body.setAttribute('data-theme', newTheme);
          localStorage.setItem('theme', newTheme);
        });
      }
    }
    
    // Initialize dark mode immediately to prevent flash
    initDarkMode();
    
    // Initialize highlight.js and floating TOC after the DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      hljs.highlightAll();
      
      // Floating TOC functionality - only show on sub-study pages
      const floatingToc = document.getElementById('floating-toc');
      const tocNav = document.getElementById('toc-nav');
      const tocClose = document.querySelector('.toc-close');
      
      // Check if we're on a sub-study page (not the main study index)
      const isSubStudyPage = window.location.pathname !== '/study/' && 
                            window.location.pathname !== '/study' && 
                            window.location.pathname.startsWith('/study/');
      
      if (floatingToc && tocNav && isSubStudyPage) {
        // Generate TOC from headings
        function generateTOC() {
          const headings = document.querySelectorAll('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6');
          if (headings.length === 0) {
            floatingToc.style.display = 'none';
            return;
          }
          
          const tocList = document.createElement('ul');
          let currentLevel = 0;
          let currentList = tocList;
          const listStack = [tocList];
          
          headings.forEach((heading, index) => {
            const level = parseInt(heading.tagName.charAt(1));
            const id = heading.id || `heading-${index}`;
            
            // Ensure heading has an ID
            if (!heading.id) {
              heading.id = id;
            }
            
            // Create list item
            const listItem = document.createElement('li');
            const link = document.createElement('a');
            link.href = `#${id}`;
            link.textContent = heading.textContent.trim();
            link.addEventListener('click', function(e) {
              e.preventDefault();
              const targetElement = document.getElementById(id);
              if (targetElement) {
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                // Close TOC after clicking
                floatingToc.classList.remove('toc-open');
              }
            });
            
            listItem.appendChild(link);
            
            // Handle nesting
            if (level > currentLevel) {
              // Go deeper
              for (let i = currentLevel; i < level; i++) {
                const newList = document.createElement('ul');
                currentList.appendChild(newList);
                listStack.push(newList);
                currentList = newList;
              }
            } else if (level < currentLevel) {
              // Go shallower
              for (let i = currentLevel; i > level; i--) {
                listStack.pop();
                currentList = listStack[listStack.length - 1];
              }
            }
            
            currentList.appendChild(listItem);
            currentLevel = level;
          });
          
          tocNav.appendChild(tocList);
        }
        
        // Generate the TOC
        generateTOC();
        
        // Handle close button
        if (tocClose) {
          tocClose.addEventListener('click', function() {
            floatingToc.classList.remove('toc-open');
          });
        }
        
        // Handle click on icon to toggle
        const tocIcon = document.querySelector('.toc-icon');
        if (tocIcon) {
          tocIcon.addEventListener('click', function() {
            floatingToc.classList.toggle('toc-open');
          });
        }
        
        // Active section highlighting
        function updateActiveSection() {
          const headings = document.querySelectorAll('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6');
          const tocLinks = tocNav.querySelectorAll('a');
          
          // Remove active class from all links
          tocLinks.forEach(link => link.classList.remove('active'));
          
          // Find the current section
          let currentHeading = null;
          const scrollPosition = window.scrollY + 100; // Offset for better UX
          
          for (let i = headings.length - 1; i >= 0; i--) {
            const heading = headings[i];
            const headingTop = heading.offsetTop;
            
            if (headingTop <= scrollPosition) {
              currentHeading = heading;
              break;
            }
          }
          
          // Add active class to current section
          if (currentHeading) {
            const activeLink = tocNav.querySelector(`a[href="#${currentHeading.id}"]`);
            if (activeLink) {
              activeLink.classList.add('active');
            }
          }
        }
        
        // Update active section on scroll
        let scrollTimeout;
        window.addEventListener('scroll', function() {
          if (scrollTimeout) {
            clearTimeout(scrollTimeout);
          }
          scrollTimeout = setTimeout(updateActiveSection, 10);
        });
        
        // Initial update
        updateActiveSection();
      } else if (floatingToc && !isSubStudyPage) {
        // Hide floating TOC on main study page
        floatingToc.style.display = 'none';
      }
      
      // Legacy TOC functionality (for existing markdown TOCs)
      const toc = document.querySelector('#markdown-toc');
      if (toc) {
        // Hide the floating TOC if there's already a markdown TOC
        if (floatingToc) {
          floatingToc.style.display = 'none';
        }
        
        // Create TOC container with header
        const tocContainer = document.createElement('div');
        tocContainer.className = 'toc-container';
        tocContainer.style.cssText = `
          background: #f8fafc;
          border: 1px solid #e5e7eb;
          border-radius: 8px;
          padding: 16px;
          margin: 20px 0;
          position: relative;
        `;
        
        // Add TOC header
        const tocHeader = document.createElement('h3');
        tocHeader.textContent = 'Table of Contents';
        tocHeader.style.cssText = `
          margin: 0 0 12px 0;
          font-size: 16px;
          font-weight: 600;
          color: #374151;
        `;
        
        // Add back to top button
        const backToTopBtn = document.createElement('button');
        backToTopBtn.textContent = '↑ Top';
        backToTopBtn.style.cssText = `
          position: absolute;
          top: 12px;
          right: 12px;
          background: #ffffff;
          border: 1px solid #d1d5db;
          border-radius: 6px;
          padding: 4px 8px;
          font-size: 12px;
          cursor: pointer;
          color: #6b7280;
          transition: all 0.2s ease;
        `;
        
        // Add hover effect for back to top button
        backToTopBtn.addEventListener('mouseenter', function() {
          this.style.background = '#f3f4f6';
          this.style.color = '#374151';
        });
        
        backToTopBtn.addEventListener('mouseleave', function() {
          this.style.background = '#ffffff';
          this.style.color = '#6b7280';
        });
        
        // Back to top functionality
        backToTopBtn.addEventListener('click', function() {
          window.scrollTo({ top: 0, behavior: 'smooth' });
        });
        
        // Style the TOC list
        toc.style.cssText = `
          margin: 0;
          padding: 0;
          font-size: 14px;
          line-height: 1.5;
        `;
        
        // Insert header and button into container
        tocContainer.appendChild(tocHeader);
        tocContainer.appendChild(backToTopBtn);
        tocContainer.appendChild(toc);
        
        // Replace the original TOC with the new container
        toc.parentNode.insertBefore(tocContainer, toc);
        tocContainer.appendChild(toc);
        
        // Add smooth scrolling to TOC links
        const tocLinks = toc.querySelectorAll('a');
        tocLinks.forEach(link => {
          link.addEventListener('click', function(e) {
            e.preventDefault();
            const targetId = this.getAttribute('href').substring(1);
            const targetElement = document.getElementById(targetId);
            if (targetElement) {
              targetElement.scrollIntoView({ behavior: 'smooth' });
            }
          });
        });
      }
    });
  </script>
</body>
</html>
