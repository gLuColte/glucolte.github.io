<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Hourglass Design · glucolte</title>
  <meta name="description" content="notes • principles • systems">
  <link rel="stylesheet" href="/assets/style.css">
  <link rel="stylesheet" href="/assets/study.css">
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/favicon.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Hourglass Design | glucolte</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Hourglass Design" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="notes • principles • systems" />
<meta property="og:description" content="notes • principles • systems" />
<link rel="canonical" href="http://localhost:4000/study/systemDesignHourglass" />
<meta property="og:url" content="http://localhost:4000/study/systemDesignHourglass" />
<meta property="og:site_name" content="glucolte" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Hourglass Design" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"notes • principles • systems","headline":"Hourglass Design","url":"http://localhost:4000/study/systemDesignHourglass"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
  <header class="site-header">
    <a class="brand" href="/">glucolte</a>
    <nav class="nav">
      <a href="/">home</a>
      <a href="/principles">principles</a>
      <a href="/rules">rules</a>
      <a href="/stretches">stretches</a>
      <a href="/study/">study</a>
      <a href="/projects/">projects</a>
      <a href="/setup/">setup</a>
    </nav>
    <button id="dark-mode-toggle" class="dark-mode-toggle" aria-label="Toggle dark mode">
      <svg class="sun-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="5"></circle>
        <line x1="12" y1="1" x2="12" y2="3"></line>
        <line x1="12" y1="21" x2="12" y2="23"></line>
        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
        <line x1="1" y1="12" x2="3" y2="12"></line>
        <line x1="21" y1="12" x2="23" y2="12"></line>
        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
      </svg>
      <svg class="moon-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
      </svg>
    </button>
  </header>

  <main class="container">
    <article class="content">
      <h2 id="-hour-glass">🧠 “Hour Glass”</h2>

<blockquote>
  <p>An iterative, decision-driven guide to building scalable and reliable systems.
In a way you are transforming the data and make it “what the clients” want to see</p>
</blockquote>

<hr />

<h3 id="1--source-data-origin--ingress">1. 🟪 Source (Data Origin &amp; Ingress)</h3>

<p><strong>Goal</strong>: Identify the nature, rate, and reliability of data entering the system.</p>

<table>
  <thead>
    <tr>
      <th>Critical Question</th>
      <th>Impact on Design</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>How many sources, and what type (IoT, user, system)?</td>
      <td>Determines protocol and scale: MQTT/Kafka for IoT, REST for users</td>
    </tr>
    <tr>
      <td>Is the source push or pull?</td>
      <td>Push → queue/broker needed. Pull → periodic scheduler or polling logic.</td>
    </tr>
    <tr>
      <td>How frequent is the data (ms, sec, min)?</td>
      <td>Sub-second → stream system<br />Low-freq → batch/job</td>
    </tr>
    <tr>
      <td>Can the source apply compute (pre-filter)?</td>
      <td>Yes → reduce load and noise<br />No → all logic must be server-side</td>
    </tr>
    <tr>
      <td>Is each source uniquely identifiable?</td>
      <td>Yes → partitioning/sharding<br />No → risk of duplication or tracking complexity</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="2--type-schema-format-encoding">2. 🟩 Type (Schema, Format, Encoding)</h3>

<p><strong>Goal</strong>: Determine how the data is structured and what formats affect storage/querying.</p>

<table>
  <thead>
    <tr>
      <th>Critical Question</th>
      <th>Impact on Design</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Is schema known and enforced?</td>
      <td>Yes → SQL or schema registry (Avro/Protobuf)<br />No → NoSQL or S3</td>
    </tr>
    <tr>
      <td>Is the payload narrow (few fields) or wide (many fields)?</td>
      <td>Narrow → Time-series DB<br />Wide → OLAP column store</td>
    </tr>
    <tr>
      <td>Do you need compact storage or human-readable?</td>
      <td>Compact → Protobuf, Avro<br />Readable → JSON, CSV</td>
    </tr>
    <tr>
      <td>Are values nested or flat?</td>
      <td>Nested → NoSQL/JSONB<br />Flat → SQL</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="3--storage-scale-structure-and-retention">3. 🟥 Storage (Scale, Structure, and Retention)</h3>

<p><strong>Goal</strong>: Pick the right engine based on size, write pattern, and query behavior.</p>

<table>
  <thead>
    <tr>
      <th>Critical Question</th>
      <th>Impact on Design</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>What’s the expected daily volume and retention duration?</td>
      <td>High volume or long retention → Cold storage or tiered design (S3 + DB)</td>
    </tr>
    <tr>
      <td>Are writes frequent (hot) or infrequent (cold)?</td>
      <td>Hot → Streaming DB or Append log<br />Cold → SQL with indices</td>
    </tr>
    <tr>
      <td>Is data mutable or immutable?</td>
      <td>Mutable → SQL, versioning<br />Immutable → Append-only, event stores</td>
    </tr>
    <tr>
      <td>Do queries require joins or time-based filters?</td>
      <td>Joins → SQL<br />Time-filtering → Time-series or partitioned DB</td>
    </tr>
    <tr>
      <td>What consistency level is required?</td>
      <td>Strong → SQL<br />Eventual → NoSQL or object storage</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="4--access-pattern-read-behavior--consumers">4. 🟨 Access Pattern (Read Behavior &amp; Consumers)</h3>

<p><strong>Goal</strong>: Understand <strong>how data is queried</strong>, to shape indexing and compute needs.</p>

<table>
  <thead>
    <tr>
      <th>Critical Question</th>
      <th>Impact on Design</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Are reads real-time, periodic, or ad-hoc?</td>
      <td>Real-time → Cache or precompute<br />Ad-hoc → OLAP or query planner</td>
    </tr>
    <tr>
      <td>Do consumers read by ID, time range, or search?</td>
      <td>ID → Key-value<br />Time → TSDB<br />Search → Inverted index/Elastic</td>
    </tr>
    <tr>
      <td>Is access global or scoped (by user/region)?</td>
      <td>Scoped → Partitioned tables or row-level access</td>
    </tr>
    <tr>
      <td>Do consumers expect computed summaries?</td>
      <td>Yes → Pre-aggregated views, OLAP tables, materialized views</td>
    </tr>
  </tbody>
</table>

<p>Note for ingestion:</p>

<table>
  <thead>
    <tr>
      <th>Use Case</th>
      <th>Best Option</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>&lt; 1K messages/sec, low fan-out</td>
      <td>SQS/SNS</td>
    </tr>
    <tr>
      <td>1K–10K messages/sec, occasional fan-out</td>
      <td>Kinesis</td>
    </tr>
    <tr>
      <td>&gt;10K messages/sec, multi-consumer, replayable</td>
      <td>Kafka/Kinesis</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="5--api-interface--access-protocols">5. 🟧 API (Interface &amp; Access Protocols)</h3>

<p><strong>Goal</strong>: Choose interface method based on interaction style and latency needs.</p>

<table>
  <thead>
    <tr>
      <th>Critical Question</th>
      <th>Impact on Design</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Are responses user-triggered or system-triggered?</td>
      <td>User → REST/GraphQL<br />System → Webhook, Kafka, MQTT</td>
    </tr>
    <tr>
      <td>Is real-time push required?</td>
      <td>Yes → WebSocket, SSE, MQTT<br />No → REST polling</td>
    </tr>
    <tr>
      <td>Can responses be precomputed?</td>
      <td>Yes → Redis/materialized views<br />No → On-demand DB or Lambda</td>
    </tr>
    <tr>
      <td>Do clients need batch/massive downloads?</td>
      <td>Yes → Async job + link<br />No → Paginated API</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="6--frontend--client-needs">6. 🟦 Frontend / Client Needs</h3>

<p><strong>Goal</strong>: Understand client-side data behavior, rendering, and interactivity.</p>

<table>
  <thead>
    <tr>
      <th>Critical Question</th>
      <th>Impact on Design</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Does the UI require low-latency/live updates?</td>
      <td>Yes → Push via WebSocket/SSE or fast polling</td>
    </tr>
    <tr>
      <td>Does the client render large lists/maps/feeds?</td>
      <td>Yes → Use pagination, infinite scroll, viewport filtering</td>
    </tr>
    <tr>
      <td>Is there advanced filtering or search?</td>
      <td>Yes → Use client-friendly search engines (Typesense, Meilisearch, etc.)</td>
    </tr>
    <tr>
      <td>Do users expect offline access or sync?</td>
      <td>Yes → Service Workers + LocalStorage / IndexedDB</td>
    </tr>
    <tr>
      <td>Are client views customized per user/role?</td>
      <td>Yes → Personalization and RBAC filtering at query-level</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="7--security-auth-privacy-protection">7. 🔐 Security (Auth, Privacy, Protection)</h3>

<p><strong>Goal</strong>: Define minimum protection and tenant isolation.</p>

<table>
  <thead>
    <tr>
      <th>Critical Question</th>
      <th>Impact on Design</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Who can access the data and how?</td>
      <td>Public → Read-only APIs + WAF<br />Private → Auth with JWT/API Key</td>
    </tr>
    <tr>
      <td>Does data belong to specific users/orgs?</td>
      <td>Yes → Row-level security or schema-per-tenant</td>
    </tr>
    <tr>
      <td>Is access logged and monitored?</td>
      <td>Yes → Append-only audit trail or log forwarding</td>
    </tr>
    <tr>
      <td>Do you need protection from abuse?</td>
      <td>Yes → Throttling, WAF, API gateway, CAPTCHA</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="8--scalability-throughput--growth">8. 📈 Scalability (Throughput &amp; Growth)</h3>

<p><strong>Goal</strong>: Forecast data/traffic growth and proactively plan for scale-out.</p>

<table>
  <thead>
    <tr>
      <th>Critical Question</th>
      <th>Impact on Design</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Is data or traffic expected to grow linearly or exponentially?</td>
      <td>Exponential → Shard early, avoid monoliths</td>
    </tr>
    <tr>
      <td>Is the workload CPU, memory, or I/O bound?</td>
      <td>CPU → Worker scale<br />I/O → Queue or backpressure<br />Memory → Cache or batching</td>
    </tr>
    <tr>
      <td>Can the system be horizontally scaled easily?</td>
      <td>Yes → Stateless microservices, partitioned DBs, autoscaling nodes</td>
    </tr>
    <tr>
      <td>Are there natural partitioning keys?</td>
      <td>Yes → Device ID, region, tenant → enables scalable sharding</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="9--reliability--fault-tolerance">9. 🔁 Reliability &amp; Fault Tolerance</h3>

<p><strong>Goal</strong>: Ensure continuity of service and graceful degradation.</p>

<table>
  <thead>
    <tr>
      <th>Critical Question</th>
      <th>Impact on Design</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>What’s the impact of a failed service/component?</td>
      <td>High → Use retries, failover, fallback, circuit breakers</td>
    </tr>
    <tr>
      <td>Can events be retried safely?</td>
      <td>Yes → Idempotency keys or sequence markers</td>
    </tr>
    <tr>
      <td>Is durability more important than availability?</td>
      <td>Yes → Synchronous replication, WAL, backups</td>
    </tr>
    <tr>
      <td>How are dependent services isolated?</td>
      <td>Queues, bulkheads, rate limits, timeouts</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="10--observability-monitoring-logging-tracing">10. 🪵 Observability (Monitoring, Logging, Tracing)</h3>

<p><strong>Goal</strong>: Expose system behavior and enable root-cause analysis.</p>

<table>
  <thead>
    <tr>
      <th>Critical Question</th>
      <th>Impact on Design</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Do you need alerts on abnormal behavior?</td>
      <td>Yes → Metric thresholds, anomaly detection, dead man’s switch</td>
    </tr>
    <tr>
      <td>Can you trace requests across systems?</td>
      <td>Yes → Correlation IDs, OpenTelemetry, X-Ray</td>
    </tr>
    <tr>
      <td>Is structured logging important?</td>
      <td>Yes → Use centralized log collector (Loki, ELK, Datadog)</td>
    </tr>
    <tr>
      <td>Are business-level metrics required?</td>
      <td>Yes → Emit custom app metrics, not just infra metrics</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="11--deployment--infrastructure">11. 🚀 Deployment &amp; Infrastructure</h3>

<p><strong>Goal</strong>: Define environment, rollout strategy, and deployment control.</p>

<table>
  <thead>
    <tr>
      <th>Critical Question</th>
      <th>Impact on Design</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Is this cloud-native, hybrid, or on-prem?</td>
      <td>Cloud → Use managed services<br />Hybrid/on-prem → Consider container orchestration</td>
    </tr>
    <tr>
      <td>Is multi-region a hard requirement?</td>
      <td>Yes → Global DNS, active-active setup, replication strategy</td>
    </tr>
    <tr>
      <td>Is IaC and CI/CD expected?</td>
      <td>Yes → Use Terraform/CDK, GitHub Actions/ArgoCD for pipelines</td>
    </tr>
    <tr>
      <td>How fast do changes need to deploy?</td>
      <td>Fast → Canary releases, feature flags, rollback support</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="scenario-1-realtime-temperature-monitoring-with-iot-sensors">Scenario 1: Realtime Temperature Monitoring with IoT Sensors</h2>

<p>Design a system that collects temperature data from 1 million IoT devices across NSW and publishes:</p>

<ul>
  <li>A real-time pixelated temperature heatmap (~10s latency).</li>
  <li>A historical dashboard with daily/weekly/monthly min/max temperatures per region.</li>
  <li>Historical retention: 6 months.</li>
</ul>

<h3 id="1-source">1. <strong>Source</strong></h3>

<p><strong>What produces the data?</strong></p>

<ul>
  <li><strong>1M IoT devices</strong> deployed across NSW</li>
  <li>Each emits a temperature reading every <strong>10 seconds</strong></li>
  <li>
    <p>Format:</p>

    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"device_id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"abc123"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"timestamp"</span><span class="p">:</span><span class="w"> </span><span class="mi">1723049840</span><span class="p">,</span><span class="w">
  </span><span class="nl">"temperature"</span><span class="p">:</span><span class="w"> </span><span class="mf">26.5</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
  </li>
</ul>

<p><strong>Protocol Chosen</strong>: <code class="language-plaintext highlighter-rouge">MQTT</code></p>

<p><strong>Why</strong>: Lightweight, supports millions of persistent low-power clients, ideal for IoT telemetry.</p>

<hr />

<h3 id="2-type">2. <strong>Type</strong></h3>

<p><strong>What kind of data?</strong></p>

<ul>
  <li><strong>Structured, time-series</strong></li>
  <li>Schema is <strong>fixed</strong> and simple</li>
  <li>JSON at ingest, but stored in optimized binary</li>
</ul>

<hr />

<h3 id="3-storage">3. <strong>Storage</strong></h3>

<p><strong>How is the data stored, and what format?</strong></p>

<h4 id="a-real-time-table">a. <strong>Real-Time Table</strong></h4>

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Size</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>device_id</td>
      <td>UInt32</td>
      <td>4B</td>
    </tr>
    <tr>
      <td>temp</td>
      <td>Float</td>
      <td>4B</td>
    </tr>
    <tr>
      <td>last_updated</td>
      <td>UnixTS</td>
      <td>8B</td>
    </tr>
    <tr>
      <td>Total</td>
      <td> </td>
      <td><strong>16B</strong> per device</td>
    </tr>
  </tbody>
</table>

<p>→ <code class="language-plaintext highlighter-rouge">1M devices * 16B = 16 MB</code> (not GB!)</p>

<h4 id="b-historical-data">b. <strong>Historical Data</strong></h4>

<p>For each sensor:</p>

<ul>
  <li>Store <strong>daily min/max</strong> → 2 floats + 2 timestamps
→ 16B per day → <code class="language-plaintext highlighter-rouge">1M * 180 days * 16B = 2.88 GB</code></li>
</ul>

<p>Add device metadata table:</p>

<ul>
  <li>device_id, uuid, lat, long → 20B × 1M → <strong>~20 MB</strong></li>
</ul>

<h4 id="-final-estimation">✅ Final Estimation:</h4>

<table>
  <thead>
    <tr>
      <th>Table</th>
      <th>Estimated Size</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Realtime Table</td>
      <td>~16 MB</td>
    </tr>
    <tr>
      <td>Daily Table</td>
      <td>~2.88 GB</td>
    </tr>
    <tr>
      <td>Weekly/Monthly</td>
      <td>Aggregated</td>
    </tr>
    <tr>
      <td>Device Metadata</td>
      <td>~20 MB</td>
    </tr>
    <tr>
      <td><strong>Total</strong></td>
      <td><strong>~3.5 GB</strong></td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="4-preprocessing--compute">4. <strong>Preprocessing / Compute</strong></h3>

<p><strong>What processing is done pre-store or during ingestion?</strong></p>

<ul>
  <li>Real-time table: <strong>UPDATE on each incoming reading</strong></li>
  <li>Daily table: compare reading to current min/max → update if necessary</li>
  <li>Weekly/monthly: daily aggregation jobs (batch via scheduled job)</li>
</ul>

<p><strong>Tech Suggestion</strong>:</p>

<ul>
  <li>AWS Lambda or ECS service for MQTT message processing</li>
  <li>Use <code class="language-plaintext highlighter-rouge">Redis</code> for fast in-memory compare/write for real-time updates</li>
  <li>Then batch-write to TimescaleDB / Postgres</li>
</ul>

<hr />

<h3 id="5-api-data-interface">5. <strong>API (Data Interface)</strong></h3>

<p><strong>How does the frontend consume the data?</strong></p>

<ul>
  <li>
    <p><strong>Realtime map</strong>:</p>

    <ul>
      <li>Uses <strong>REST API</strong> with client polling every 10 seconds</li>
      <li>Endpoint hits <code class="language-plaintext highlighter-rouge">realtime_table</code></li>
    </ul>
  </li>
  <li>
    <p><strong>Historical dashboard</strong>:</p>

    <ul>
      <li>REST endpoint to query <code class="language-plaintext highlighter-rouge">daily_table</code>, <code class="language-plaintext highlighter-rouge">weekly_table</code></li>
    </ul>
  </li>
</ul>

<p><strong>Why polling over WebSocket?</strong></p>

<ul>
  <li>Map is pixelated &amp; low-resolution, not per-device → avoid 1M WebSocket updates</li>
  <li>100 users/hour is low load</li>
  <li>Polling at 10s interval is simpler, cheaper to maintain, and sufficient</li>
</ul>

<hr />

<h3 id="6-client--presentation">6. <strong>Client / Presentation</strong></h3>

<p><strong>What are the frontend requirements?</strong></p>

<ul>
  <li>Web map view: grid overlay updated every 10s</li>
  <li>Historical dashboard with calendar filter</li>
  <li>No user authentication</li>
</ul>

<hr />

<h3 id="7-security">7. <strong>Security</strong></h3>

<ul>
  <li>No login needed, but:
    <ul>
      <li>Throttle API to avoid DoS (e.g., CloudFront + WAF)</li>
    </ul>
  </li>
  <li>Edge - MQTT broker authentication with certs</li>
</ul>

<hr />

<h3 id="8-scalability">8. <strong>Scalability</strong></h3>

<ul>
  <li>Write-heavy system (1M writes every 10s = ~100K writes/sec)</li>
  <li>Use <strong>Kafka</strong> or <strong>Kinesis</strong> as buffer between MQTT and DB</li>
  <li>DB partitioned on <code class="language-plaintext highlighter-rouge">device_id</code> and time</li>
  <li>Stateless API → auto-scalable</li>
</ul>

<hr />

<h3 id="9-reliability">9. <strong>Reliability</strong></h3>

<ul>
  <li>MQTT → At Least Once delivery</li>
  <li>Ingest pipeline retry logic</li>
  <li>If device fails → last_seen timestamp in DB</li>
  <li>If aggregation job fails → re-run from daily table</li>
</ul>

<hr />

<h3 id="10-observability">10. <strong>Observability</strong></h3>

<ul>
  <li>
    <p>Metrics:</p>

    <ul>
      <li>MQTT message rate</li>
      <li>Write latency</li>
      <li>Failed writes</li>
      <li>Last_seen_age per sensor</li>
    </ul>
  </li>
  <li>
    <p>Logs:</p>

    <ul>
      <li>Ingestion pipeline</li>
      <li>API access logs</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="11-environment--infra">11. <strong>Environment / Infra</strong></h3>

<ul>
  <li>
    <p>Cloud-native (AWS):</p>

    <ul>
      <li><strong>MQTT</strong>: AWS IoT Core or EMQX</li>
      <li><strong>Buffer</strong>: Kinesis or Kafka</li>
      <li><strong>Processing</strong>: ECS, Fargate, or Lambda</li>
      <li><strong>Storage</strong>: PostgreSQL + TimescaleDB</li>
      <li><strong>API</strong>: FastAPI or Flask on Fargate</li>
      <li><strong>Infra</strong>: IaC with Terraform/CDK</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="summary-table">Summary Table</h3>

<table>
  <thead>
    <tr>
      <th>Block</th>
      <th>Design Choice</th>
      <th>Justification</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Source</td>
      <td>MQTT sensors</td>
      <td>Lightweight, IoT standard</td>
    </tr>
    <tr>
      <td>Type</td>
      <td>Fixed JSON schema</td>
      <td>Efficient parsing</td>
    </tr>
    <tr>
      <td>Storage</td>
      <td>PostgreSQL + Timescale</td>
      <td>Time-series optimized</td>
    </tr>
    <tr>
      <td>Compute</td>
      <td>Real-time update + daily aggregation jobs</td>
      <td>Low-latency + batch</td>
    </tr>
    <tr>
      <td>API</td>
      <td>REST (polling every 10s)</td>
      <td>Simpler infra, 100 users only</td>
    </tr>
    <tr>
      <td>Client</td>
      <td>Grid map + calendar dashboard</td>
      <td>Low interaction</td>
    </tr>
    <tr>
      <td>Security</td>
      <td>Public API with WAF + MQTT certs</td>
      <td>Lightweight protection</td>
    </tr>
    <tr>
      <td>Scalability</td>
      <td>Kafka → TimescaleDB</td>
      <td>Decouples writes, horizontal scale</td>
    </tr>
    <tr>
      <td>Reliability</td>
      <td>Retry + health checks + last seen tracking</td>
      <td>Graceful failure handling</td>
    </tr>
    <tr>
      <td>Observability</td>
      <td>Metrics + alerts + logs</td>
      <td>Easy monitoring</td>
    </tr>
    <tr>
      <td>Environment</td>
      <td>AWS IoT Core, ECS, Terraform</td>
      <td>Modular &amp; reproducible</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="scenario-2-twitter-platform">Scenario 2: Twitter Platform</h2>

<h2 id="scenario-3-ecommerce-platform">Scenario 3: eCommerce Platform</h2>

    </article>
  </main>

  <!-- Floating Table of Contents -->
  <div id="floating-toc" class="floating-toc">
    <div class="toc-icon">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="8" y1="6" x2="21" y2="6"></line>
        <line x1="8" y1="12" x2="21" y2="12"></line>
        <line x1="8" y1="18" x2="21" y2="18"></line>
        <line x1="3" y1="6" x2="3.01" y2="6"></line>
        <line x1="3" y1="12" x2="3.01" y2="12"></line>
        <line x1="3" y1="18" x2="3.01" y2="18"></line>
      </svg>
    </div>
    <div class="toc-content">
      <div class="toc-header">
        <span>Contents</span>
        <button class="toc-close" aria-label="Close table of contents">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <nav class="toc-nav" id="toc-nav">
        <!-- Generated by JavaScript -->
      </nav>
    </div>
  </div>

  <footer class="site-footer">
    <span>© 2025 glucolte • </span>
    <a href="https://github.com/gLuColte/glucolte.github.io">source</a>
  </footer>

  <script>
    // Dark mode functionality
    function initDarkMode() {
      const toggle = document.getElementById('dark-mode-toggle');
      const body = document.body;
      
      // Check for saved theme preference or default to light mode
      const savedTheme = localStorage.getItem('theme');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      
      if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
        body.setAttribute('data-theme', 'dark');
      }
      
      // Toggle dark mode
      if (toggle) {
        toggle.addEventListener('click', function() {
          const currentTheme = body.getAttribute('data-theme');
          const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
          
          body.setAttribute('data-theme', newTheme);
          localStorage.setItem('theme', newTheme);
        });
      }
    }
    
    // Initialize dark mode immediately to prevent flash
    initDarkMode();
    
    // Initialize highlight.js and floating TOC after the DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      hljs.highlightAll();
      
      // Floating TOC functionality - only show on sub-study pages
      const floatingToc = document.getElementById('floating-toc');
      const tocNav = document.getElementById('toc-nav');
      const tocClose = document.querySelector('.toc-close');
      
      // Check if we're on a sub-study page (not the main study index)
      const isSubStudyPage = window.location.pathname !== '/study/' && 
                            window.location.pathname !== '/study' && 
                            window.location.pathname.startsWith('/study/');
      
      if (floatingToc && tocNav && isSubStudyPage) {
        // Generate TOC from headings
        function generateTOC() {
          const headings = document.querySelectorAll('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6');
          if (headings.length === 0) {
            floatingToc.style.display = 'none';
            return;
          }
          
          const tocList = document.createElement('ul');
          let currentLevel = 0;
          let currentList = tocList;
          const listStack = [tocList];
          
          headings.forEach((heading, index) => {
            const level = parseInt(heading.tagName.charAt(1));
            const id = heading.id || `heading-${index}`;
            
            // Ensure heading has an ID
            if (!heading.id) {
              heading.id = id;
            }
            
            // Create list item
            const listItem = document.createElement('li');
            const link = document.createElement('a');
            link.href = `#${id}`;
            link.textContent = heading.textContent.trim();
            link.addEventListener('click', function(e) {
              e.preventDefault();
              const targetElement = document.getElementById(id);
              if (targetElement) {
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                // Close TOC after clicking
                floatingToc.classList.remove('toc-open');
              }
            });
            
            listItem.appendChild(link);
            
            // Handle nesting
            if (level > currentLevel) {
              // Go deeper
              for (let i = currentLevel; i < level; i++) {
                const newList = document.createElement('ul');
                currentList.appendChild(newList);
                listStack.push(newList);
                currentList = newList;
              }
            } else if (level < currentLevel) {
              // Go shallower
              for (let i = currentLevel; i > level; i--) {
                listStack.pop();
                currentList = listStack[listStack.length - 1];
              }
            }
            
            currentList.appendChild(listItem);
            currentLevel = level;
          });
          
          tocNav.appendChild(tocList);
        }
        
        // Generate the TOC
        generateTOC();
        
        // Handle close button
        if (tocClose) {
          tocClose.addEventListener('click', function() {
            floatingToc.classList.remove('toc-open');
          });
        }
        
        // Handle click on icon to toggle
        const tocIcon = document.querySelector('.toc-icon');
        if (tocIcon) {
          tocIcon.addEventListener('click', function() {
            floatingToc.classList.toggle('toc-open');
          });
        }
        
        // Active section highlighting
        function updateActiveSection() {
          const headings = document.querySelectorAll('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6');
          const tocLinks = tocNav.querySelectorAll('a');
          
          // Remove active class from all links
          tocLinks.forEach(link => link.classList.remove('active'));
          
          // Find the current section
          let currentHeading = null;
          const scrollPosition = window.scrollY + 100; // Offset for better UX
          
          for (let i = headings.length - 1; i >= 0; i--) {
            const heading = headings[i];
            const headingTop = heading.offsetTop;
            
            if (headingTop <= scrollPosition) {
              currentHeading = heading;
              break;
            }
          }
          
          // Add active class to current section
          if (currentHeading) {
            const activeLink = tocNav.querySelector(`a[href="#${currentHeading.id}"]`);
            if (activeLink) {
              activeLink.classList.add('active');
            }
          }
        }
        
        // Update active section on scroll
        let scrollTimeout;
        window.addEventListener('scroll', function() {
          if (scrollTimeout) {
            clearTimeout(scrollTimeout);
          }
          scrollTimeout = setTimeout(updateActiveSection, 10);
        });
        
        // Initial update
        updateActiveSection();
      } else if (floatingToc && !isSubStudyPage) {
        // Hide floating TOC on main study page
        floatingToc.style.display = 'none';
      }
      
      // Legacy TOC functionality (for existing markdown TOCs)
      const toc = document.querySelector('#markdown-toc');
      if (toc) {
        // Hide the floating TOC if there's already a markdown TOC
        if (floatingToc) {
          floatingToc.style.display = 'none';
        }
        
        // Create TOC container with header
        const tocContainer = document.createElement('div');
        tocContainer.className = 'toc-container';
        tocContainer.style.cssText = `
          background: #f8fafc;
          border: 1px solid #e5e7eb;
          border-radius: 8px;
          padding: 16px;
          margin: 20px 0;
          position: relative;
        `;
        
        // Add TOC header
        const tocHeader = document.createElement('h3');
        tocHeader.textContent = 'Table of Contents';
        tocHeader.style.cssText = `
          margin: 0 0 12px 0;
          font-size: 16px;
          font-weight: 600;
          color: #374151;
        `;
        
        // Add back to top button
        const backToTopBtn = document.createElement('button');
        backToTopBtn.textContent = '↑ Top';
        backToTopBtn.style.cssText = `
          position: absolute;
          top: 12px;
          right: 12px;
          background: #ffffff;
          border: 1px solid #d1d5db;
          border-radius: 6px;
          padding: 4px 8px;
          font-size: 12px;
          cursor: pointer;
          color: #6b7280;
          transition: all 0.2s ease;
        `;
        
        // Add hover effect for back to top button
        backToTopBtn.addEventListener('mouseenter', function() {
          this.style.background = '#f3f4f6';
          this.style.color = '#374151';
        });
        
        backToTopBtn.addEventListener('mouseleave', function() {
          this.style.background = '#ffffff';
          this.style.color = '#6b7280';
        });
        
        // Back to top functionality
        backToTopBtn.addEventListener('click', function() {
          window.scrollTo({ top: 0, behavior: 'smooth' });
        });
        
        // Style the TOC list
        toc.style.cssText = `
          margin: 0;
          padding: 0;
          font-size: 14px;
          line-height: 1.5;
        `;
        
        // Insert header and button into container
        tocContainer.appendChild(tocHeader);
        tocContainer.appendChild(backToTopBtn);
        tocContainer.appendChild(toc);
        
        // Replace the original TOC with the new container
        toc.parentNode.insertBefore(tocContainer, toc);
        tocContainer.appendChild(toc);
        
        // Add smooth scrolling to TOC links
        const tocLinks = toc.querySelectorAll('a');
        tocLinks.forEach(link => {
          link.addEventListener('click', function(e) {
            e.preventDefault();
            const targetId = this.getAttribute('href').substring(1);
            const targetElement = document.getElementById(targetId);
            if (targetElement) {
              targetElement.scrollIntoView({ behavior: 'smooth' });
            }
          });
        });
      }
    });
  </script>
</body>
</html>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    document.querySelectorAll(".diagram-caption").forEach(caption => {
      const snippetId = caption.getAttribute("data-snippet-id");
      const snippet = document.getElementById(snippetId);
      if (snippet) {
        caption.setAttribute("data-tooltip", snippet.textContent.trim());
      }
    });
  });
  </script>
  