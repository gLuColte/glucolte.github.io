<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Hourglass Design · glucolte</title>
  <meta name="description" content="notes • principles • systems">
  <link rel="stylesheet" href="/assets/style.css">
  <link rel="stylesheet" href="/assets/study.css">
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/favicon.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Hourglass Design | glucolte</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Hourglass Design" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="notes • principles • systems" />
<meta property="og:description" content="notes • principles • systems" />
<link rel="canonical" href="http://localhost:4000/study/systemDesignHourglass" />
<meta property="og:url" content="http://localhost:4000/study/systemDesignHourglass" />
<meta property="og:site_name" content="glucolte" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Hourglass Design" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"notes • principles • systems","headline":"Hourglass Design","url":"http://localhost:4000/study/systemDesignHourglass"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
  <header class="site-header">
  <a class="brand" href="/">glucolte</a>
  <nav class="nav">
    <a href="/principles">principles</a>
    <a href="/rules">rules</a>
    <a href="/stretches">stretches</a>
    <a href="/study/">study</a>
    <a href="/projects/">projects</a>
    <a href="/setup/">setup</a>
  </nav>
  <button id="dark-mode-toggle" class="dark-mode-toggle" aria-label="Toggle dark mode">
    <svg class="sun-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
    <svg class="moon-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
    </svg>
  </button>
</header>


  <main class="container">
    <article class="content">
      <h1 id="hour-glass">Hourglass Design</h1>

<p>An iterative, decision-driven guide to building scalable and reliable systems.<br />
The process transforms raw data into the <strong>shape that clients and consumers require</strong>.</p>

<hr />

<h3 id="section-1-source-data-origin-ingress">1. Source (Data Origin &amp; Ingress)</h3>

<p><strong>Goal</strong>: Identify the nature, rate, and reliability of incoming data.</p>

<table class="study-table">
<thead>
<tr>
<th>Critical Question</th>
<th>Impact on Design</th>
</tr>
</thead>
<tbody>
<tr>
<td>How many sources, and what type (IoT, user, system)?</td>
<td>Determines protocol and scale: MQTT/Kafka for IoT, REST for users</td>
</tr>
<tr>
<td>Is the source push or pull?</td>
<td>Push → queue/broker required<br />Pull → scheduler or polling logic</td>
</tr>
<tr>
<td>How frequent is the data?</td>
<td>Sub-second → streaming system<br />Low-frequency → batch jobs</td>
</tr>
<tr>
<td>Can the source apply pre-compute or filtering?</td>
<td>Yes → reduce load and noise<br />No → all filtering must be server-side</td>
</tr>
<tr>
<td>Is each source uniquely identifiable?</td>
<td>Yes → partitioning/sharding<br />No → risk of duplication or tracking issues</td>
</tr>
</tbody>
</table>

<hr />

<h3 id="section-2-type-schema-format-encoding">2. Type (Schema, Format, Encoding)</h3>

<p><strong>Goal</strong>: Define how data is structured and encoded for storage and querying.</p>

<table class="study-table">
<thead>
<tr>
<th>Critical Question</th>
<th>Impact on Design</th>
</tr>
</thead>
<tbody>
<tr>
<td>Is schema known and enforced?</td>
<td>Yes → SQL or schema registry (Avro/Protobuf)<br />No → NoSQL or S3 object storage</td>
</tr>
<tr>
<td>Is the payload narrow or wide?</td>
<td>Narrow → Time-series DB<br />Wide → OLAP columnar store</td>
</tr>
<tr>
<td>Do you need compact storage or human-readable?</td>
<td>Compact → Protobuf, Avro<br />Readable → JSON, CSV</td>
</tr>
<tr>
<td>Are values nested or flat?</td>
<td>Nested → NoSQL/JSONB<br />Flat → SQL</td>
</tr>
</tbody>
</table>

<hr />

<h3 id="section-3-storage-scale-structure-retention">3. Storage (Scale, Structure, Retention)</h3>

<p><strong>Goal</strong>: Choose the right storage engine based on size, retention, and query patterns.</p>

<table class="study-table">
<thead>
<tr>
<th>Critical Question</th>
<th>Impact on Design</th>
</tr>
</thead>
<tbody>
<tr>
<td>What’s the expected daily volume and retention?</td>
<td>High volume or long retention → Cold storage or tiered design (S3 + DB)</td>
</tr>
<tr>
<td>Are writes frequent or infrequent?</td>
<td>Hot → Streaming DB or append log<br />Cold → SQL with indices</td>
</tr>
<tr>
<td>Is data mutable or immutable?</td>
<td>Mutable → SQL, versioning<br />Immutable → Append-only, event store</td>
</tr>
<tr>
<td>Do queries require joins or time-based filters?</td>
<td>Joins → SQL<br />Time filtering → Time-series DB or partitioning</td>
</tr>
<tr>
<td>What consistency level is required?</td>
<td>Strong → SQL<br />Eventual → NoSQL or object storage</td>
</tr>
</tbody>
</table>

<hr />

<h3 id="section-4-access-pattern-read-behavior-consumers">4. Access Pattern (Read Behavior &amp; Consumers)</h3>

<p><strong>Goal</strong>: Understand how data will be queried and consumed.</p>

<table class="study-table">
<thead>
<tr>
<th>Critical Question</th>
<th>Impact on Design</th>
</tr>
</thead>
<tbody>
<tr>
<td>Are reads real-time, periodic, or ad-hoc?</td>
<td>Real-time → Cache or precompute<br />Ad-hoc → OLAP or query planner</td>
</tr>
<tr>
<td>Do consumers read by ID, time, or search?</td>
<td>ID → Key-value<br />Time → Time-series DB<br />Search → Inverted index (Elasticsearch)</td>
</tr>
<tr>
<td>Is access global or scoped (user/region)?</td>
<td>Scoped → Partitioned tables or row-level access</td>
</tr>
<tr>
<td>Do consumers expect summaries/aggregates?</td>
<td>Yes → Pre-aggregated views or OLAP materialization</td>
</tr>
</tbody>
</table>

<p><strong>Ingestion Guideline</strong>:</p>

<table class="study-table">
<thead>
<tr>
<th>Use Case</th>
<th>Best Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt; 1K messages/sec, low fan-out</td>
<td>SQS/SNS</td>
</tr>
<tr>
<td>1K–10K messages/sec, occasional fan-out</td>
<td>Kinesis</td>
</tr>
<tr>
<td>&gt;10K messages/sec, multi-consumer, replayable</td>
<td>Kafka or Kinesis</td>
</tr>
</tbody>
</table>

<hr />

<h3 id="section-5-api-interface-access-protocols">5. API (Interface &amp; Access Protocols)</h3>

<p><strong>Goal</strong>: Select interaction method and latency model.</p>

<table class="study-table">
<thead>
<tr>
<th>Critical Question</th>
<th>Impact on Design</th>
</tr>
</thead>
<tbody>
<tr>
<td>Are responses user- or system-triggered?</td>
<td>User → REST/GraphQL<br />System → Webhook, Kafka, MQTT</td>
</tr>
<tr>
<td>Is real-time push required?</td>
<td>Yes → WebSocket, SSE, MQTT<br />No → REST polling</td>
</tr>
<tr>
<td>Can responses be precomputed?</td>
<td>Yes → Redis, materialized views<br />No → On-demand compute</td>
</tr>
<tr>
<td>Do clients need batch or large downloads?</td>
<td>Yes → Async job + signed URL<br />No → Paginated API</td>
</tr>
</tbody>
</table>

<hr />

<h3 id="section-6-frontend-client-needs">6. Frontend / Client Needs</h3>

<p><strong>Goal</strong>: Ensure smooth rendering and interactive experience.</p>

<table class="study-table">
<thead>
<tr>
<th>Critical Question</th>
<th>Impact on Design</th>
</tr>
</thead>
<tbody>
<tr>
<td>Does the UI need low-latency/live updates?</td>
<td>Yes → Push (WebSocket/SSE) or fast polling</td>
</tr>
<tr>
<td>Does client render large lists/maps?</td>
<td>Yes → Pagination, infinite scroll, viewport filtering</td>
</tr>
<tr>
<td>Is advanced filtering or search required?</td>
<td>Yes → Search engines (Typesense, Meilisearch, Elasticsearch)</td>
</tr>
<tr>
<td>Is offline access required?</td>
<td>Yes → Service Workers + IndexedDB/LocalStorage</td>
</tr>
<tr>
<td>Are views personalized per user/role?</td>
<td>Yes → RBAC and query-level filters</td>
</tr>
</tbody>
</table>

<hr />

<h3 id="section-7-security-auth-privacy-protection">7. Security (Auth, Privacy, Protection)</h3>

<p><strong>Goal</strong>: Define minimum protection and tenant isolation.</p>

<table class="study-table">
<thead>
<tr>
<th>Critical Question</th>
<th>Impact on Design</th>
</tr>
</thead>
<tbody>
<tr>
<td>Who can access the data?</td>
<td>Public → Read-only APIs + WAF<br />Private → Auth (JWT/API Key, IAM)</td>
</tr>
<tr>
<td>Does data belong to specific users/orgs?</td>
<td>Yes → Row-level security or tenant-specific schemas</td>
</tr>
<tr>
<td>Is access logged/monitored?</td>
<td>Yes → Append-only audit trail, log forwarding</td>
</tr>
<tr>
<td>Do you need abuse protection?</td>
<td>Yes → Throttling, WAF, API Gateway, CAPTCHA</td>
</tr>
</tbody>
</table>

<hr />

<h3 id="section-8-scalability-throughput-growth">8. Scalability (Throughput &amp; Growth)</h3>

<p><strong>Goal</strong>: Forecast growth and plan scale-out.</p>

<table class="study-table">
<thead>
<tr>
<th>Critical Question</th>
<th>Impact on Design</th>
</tr>
</thead>
<tbody>
<tr>
<td>Is growth linear or exponential?</td>
<td>Exponential → Plan early sharding, avoid monoliths</td>
</tr>
<tr>
<td>Is workload CPU, memory, or I/O bound?</td>
<td>CPU → Worker scaling<br />I/O → Queue or backpressure<br />Memory → Cache or batching</td>
</tr>
<tr>
<td>Can the system scale horizontally?</td>
<td>Yes → Stateless microservices, partitioned DBs</td>
</tr>
<tr>
<td>Are there natural partition keys?</td>
<td>Yes → Device ID, region, tenant → scalable sharding</td>
</tr>
</tbody>
</table>

<hr />

<h3 id="section-9-reliability-fault-tolerance">9. Reliability &amp; Fault Tolerance</h3>

<p><strong>Goal</strong>: Ensure continuity of service and graceful degradation.</p>

<table class="study-table">
<thead>
<tr>
<th>Critical Question</th>
<th>Impact on Design</th>
</tr>
</thead>
<tbody>
<tr>
<td>What is the impact of a failed service/component?</td>
<td>High → Retries, failover, fallback, circuit breakers</td>
</tr>
<tr>
<td>Can events be retried safely?</td>
<td>Yes → Idempotency keys, sequence markers</td>
</tr>
<tr>
<td>Is durability more important than availability?</td>
<td>Yes → Sync replication, WAL, backups</td>
</tr>
<tr>
<td>How are dependencies isolated?</td>
<td>Queues, bulkheads, rate limits, timeouts</td>
</tr>
</tbody>
</table>

<hr />

<h3 id="section-10-observability-monitoring-logging-tracing">10. Observability (Monitoring, Logging, Tracing)</h3>

<p><strong>Goal</strong>: Enable root-cause analysis and system visibility.</p>

<table class="study-table">
<thead>
<tr>
<th>Critical Question</th>
<th>Impact on Design</th>
</tr>
</thead>
<tbody>
<tr>
<td>Do you need alerts on abnormal behavior?</td>
<td>Yes → Metrics, anomaly detection, dead man’s switch</td>
</tr>
<tr>
<td>Can you trace requests across systems?</td>
<td>Yes → Correlation IDs, OpenTelemetry, AWS X-Ray</td>
</tr>
<tr>
<td>Is structured logging important?</td>
<td>Yes → Central log collector (Loki, ELK, Datadog)</td>
</tr>
<tr>
<td>Are business-level metrics needed?</td>
<td>Yes → Emit custom application KPIs</td>
</tr>
</tbody>
</table>

<hr />

<h3 id="section-11-deployment-infrastructure">11. Deployment &amp; Infrastructure</h3>

<p><strong>Goal</strong>: Define environment and rollout strategy.</p>

<table class="study-table">
<thead>
<tr>
<th>Critical Question</th>
<th>Impact on Design</th>
</tr>
</thead>
<tbody>
<tr>
<td>Is it cloud-native, hybrid, or on-prem?</td>
<td>Cloud → Use managed services<br />Hybrid → Consider containers, orchestration</td>
</tr>
<tr>
<td>Is multi-region required?</td>
<td>Yes → Global DNS, active-active, replication</td>
</tr>
<tr>
<td>Is IaC/CI/CD expected?</td>
<td>Yes → Terraform/CDK, pipelines (GitHub Actions, ArgoCD)</td>
</tr>
<tr>
<td>How fast must changes deploy?</td>
<td>Fast → Canary releases, feature flags, rollback support</td>
</tr>
</tbody>
</table>

<h1 id="system-design-scenarios">System Design Scenarios</h1>

<p>These scenarios illustrate how to apply the <strong>Hourglass Design Method</strong> to real-world systems, from IoT to social platforms to eCommerce.<br />
Each table follows the same structure: <strong>Block → Design Choice → Justification</strong>.</p>

<hr />

<h2 id="scenario-1-realtime-temperature-monitoring-iot-sensors">Scenario 1: Realtime Temperature Monitoring (IoT Sensors)</h2>

<p><strong>Goal</strong>: Build a system for <strong>1M IoT devices</strong> reporting temperature every 10s across NSW.</p>
<ul>
  <li><strong>Realtime heatmap</strong> (~10s latency)</li>
  <li><strong>Historical dashboard</strong> (daily/weekly/monthly)</li>
  <li><strong>Retention</strong>: 6 months</li>
</ul>

<table class="study-table">
<thead>
<tr>
<th>Block</th>
<th>Design Choice</th>
<th>Justification</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Source</strong></td>
<td>MQTT protocol, 1M IoT devices<br />JSON payload: <code>{ device_id, timestamp, temperature }</code></td>
<td>MQTT is lightweight, supports millions of persistent low-power clients</td>
</tr>
<tr>
<td><strong>Type</strong></td>
<td>Structured time-series, fixed schema<br />JSON at ingest → binary at storage</td>
<td>Efficient parsing and optimized storage</td>
</tr>
<tr>
<td><strong>Storage</strong></td>
<td>Realtime table (~16 MB)<br />Daily aggregation (~2.9 GB / 180 days)<br />Metadata (~20 MB)<br /><strong>Total ≈ 3.5 GB</strong></td>
<td>Tiered storage: hot (real-time) vs cold (aggregates)</td>
</tr>
<tr>
<td><strong>Preprocessing / Compute</strong></td>
<td>Realtime updates per reading<br />Daily min/max aggregation<br />Redis for fast compare<br />Batch writes → TimescaleDB</td>
<td>Low latency ingest + efficient aggregation</td>
</tr>
<tr>
<td><strong>API</strong></td>
<td>REST polling every 10s (map)<br />REST queries (historical)</td>
<td>Polling is simple, cost-efficient for low concurrency</td>
</tr>
<tr>
<td><strong>Client</strong></td>
<td>Web map grid updated every 10s<br />Historical dashboard with calendar filter</td>
<td>Lightweight visualization for end users</td>
</tr>
<tr>
<td><strong>Security</strong></td>
<td>No login<br />API throttling (CloudFront + WAF)<br />MQTT cert-based auth</td>
<td>Basic protection, open data model</td>
</tr>
<tr>
<td><strong>Scalability</strong></td>
<td>~100K writes/sec<br />Kafka/Kinesis buffer<br />Partition DB by device_id + time<br />Stateless API, autoscaling</td>
<td>Horizontal scalability and decoupling</td>
</tr>
<tr>
<td><strong>Reliability</strong></td>
<td>MQTT at-least-once<br />Retry pipeline<br />Re-runnable daily jobs</td>
<td>Ensures data completeness under failure</td>
</tr>
<tr>
<td><strong>Observability</strong></td>
<td>Metrics: ingest rate, write latency, last_seen<br />Logs: ingestion + API</td>
<td>Full visibility into data pipeline health</td>
</tr>
<tr>
<td><strong>Infrastructure</strong></td>
<td>AWS IoT Core or EMQX → Kinesis/Kafka → ECS/Fargate → TimescaleDB<br />IaC: Terraform/CDK</td>
<td>Cloud-native, modular, reproducible</td>
</tr>
</tbody>
</table>

<hr />

<h2 id="scenario-2-twitter-like-microblogging-platform">Scenario 2: Twitter-like Microblogging Platform</h2>

<p><strong>Goal</strong>: Design a social platform similar to Twitter.</p>
<ul>
  <li><strong>Realtime feed updates</strong></li>
  <li><strong>Millions of posts/day</strong></li>
  <li><strong>Support search, hashtags, user timelines</strong></li>
</ul>

<table class="study-table">
<thead>
<tr>
<th>Block</th>
<th>Design Choice</th>
<th>Justification</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Source</strong></td>
<td>User posts (tweets), likes, follows<br />Ingest via REST API + WebSockets</td>
<td>REST for write operations; WebSocket for live updates</td>
</tr>
<tr>
<td><strong>Type</strong></td>
<td>JSON payloads (id, user_id, timestamp, text, media_url)<br />Hashtags/mentions indexed</td>
<td>Schema is semi-structured but consistent enough for indexing</td>
</tr>
<tr>
<td><strong>Storage</strong></td>
<td>OLTP DB (Postgres/CockroachDB) for metadata<br />Object store (S3) for media<br />ElasticSearch for search/index</td>
<td>Separate transactional vs. search workloads</td>
</tr>
<tr>
<td><strong>Preprocessing / Compute</strong></td>
<td>Fanout service builds timelines<br />Kafka for async event distribution</td>
<td>Decouples writes from personalized feed building</td>
</tr>
<tr>
<td><strong>API</strong></td>
<td>REST (post, follow)<br />WebSocket/GraphQL (feed updates)</td>
<td>REST reliable for writes; streaming API for low-latency feeds</td>
</tr>
<tr>
<td><strong>Client</strong></td>
<td>Web + mobile apps<br />Infinite scroll timeline, notifications</td>
<td>Optimized UX for engagement</td>
</tr>
<tr>
<td><strong>Security</strong></td>
<td>OAuth2 login<br />Rate limiting (API Gateway)<br />WAF for spam</td>
<td>Standard identity + abuse protection</td>
</tr>
<tr>
<td><strong>Scalability</strong></td>
<td>Sharded user/tweet DB<br />CDN for media<br />Async fanout to caches</td>
<td>Ensures horizontal scale to millions of users</td>
</tr>
<tr>
<td><strong>Reliability</strong></td>
<td>Durable Kafka log<br />Retry for writes<br />Timeline cache fallback</td>
<td>Feed always eventually consistent</td>
</tr>
<tr>
<td><strong>Observability</strong></td>
<td>Metrics: post latency, fanout lag<br />Logs: auth, API, feed delivery</td>
<td>Critical for SLO monitoring</td>
</tr>
<tr>
<td><strong>Infrastructure</strong></td>
<td>AWS: API Gateway + Lambda/ECS, DynamoDB/Postgres, S3, ElasticSearch</td>
<td>Mix of serverless + managed DB for scale</td>
</tr>
</tbody>
</table>

<hr />

<h2 id="scenario-3-ecommerce-platform">Scenario 3: eCommerce Platform</h2>

<p><strong>Goal</strong>: Design a modern eCommerce system.</p>
<ul>
  <li><strong>Product catalog, cart, checkout</strong></li>
  <li><strong>User accounts, payments</strong></li>
  <li><strong>Scalable search + inventory</strong></li>
</ul>

<table class="study-table">
<thead>
<tr>
<th>Block</th>
<th>Design Choice</th>
<th>Justification</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Source</strong></td>
<td>Users browsing, adding to cart, checkout actions<br />External payment gateway callbacks</td>
<td>Standard REST ingestion with webhook integration</td>
</tr>
<tr>
<td><strong>Type</strong></td>
<td>Structured JSON for users/products<br />Catalog with categories, variants</td>
<td>Strong schema required for payments + orders</td>
</tr>
<tr>
<td><strong>Storage</strong></td>
<td>RDBMS (Aurora/MySQL) for orders/payments<br />DynamoDB for cart sessions<br />S3 for product media</td>
<td>Transactional consistency for payments; NoSQL for ephemeral cart</td>
</tr>
<tr>
<td><strong>Preprocessing / Compute</strong></td>
<td>Inventory service decrements stock<br />Async order events via SNS/SQS</td>
<td>Event-driven ensures reliable order flow</td>
</tr>
<tr>
<td><strong>API</strong></td>
<td>REST (catalog, cart, order)<br />GraphQL (flexible queries for product search)</td>
<td>REST for critical workflows; GraphQL for frontend flexibility</td>
</tr>
<tr>
<td><strong>Client</strong></td>
<td>Web + mobile storefront<br />Search, cart, checkout flows</td>
<td>Responsive UX, optimized conversions</td>
</tr>
<tr>
<td><strong>Security</strong></td>
<td>OAuth2 login, MFA for admin<br />PCI-DSS compliant payment handling<br />WAF + Shield</td>
<td>Protects sensitive user/payment data</td>
</tr>
<tr>
<td><strong>Scalability</strong></td>
<td>Autoscaling ALB/NLB<br />ElasticSearch for catalog search<br />CDN for static assets</td>
<td>Handles traffic spikes during sales</td>
</tr>
<tr>
<td><strong>Reliability</strong></td>
<td>Multi-AZ RDS<br />Order queue with DLQ<br />Event replay for payments</td>
<td>Ensures orders are never lost</td>
</tr>
<tr>
<td><strong>Observability</strong></td>
<td>Metrics: checkout latency, error rate<br />Logs: API + payment gateway</td>
<td>Monitors user impact and failures</td>
</tr>
<tr>
<td><strong>Infrastructure</strong></td>
<td>AWS: ALB + ECS, Aurora, DynamoDB, S3, ElasticSearch, CloudFront</td>
<td>Mix of managed + serverless services for resilience</td>
</tr>
</tbody>
</table>

<hr />

<h3 id="scenario-a-short-url">Scenario 4: Short URL Service (URL Shortener)</h3>

<p><strong>Goal</strong>: Map long URLs to short codes with <strong>low latency</strong>, <strong>high write QPS</strong>, and <strong>massive read QPS</strong>.</p>
<ul>
  <li><strong>Create</strong> short code, <strong>redirect</strong> instantly</li>
  <li><strong>Unique codes</strong>, collision-resistant</li>
  <li><strong>Analytics</strong> (clicks, geo, referrer)</li>
</ul>

<table class="study-table">
<thead>
<tr>
<th>Block</th>
<th>Design Choice</th>
<th>Justification</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Source</strong></td>
<td>REST API: <code>POST /shorten</code>, <code>GET /{code}</code></td>
<td>Simple CRUD over HTTPS; easy client integration</td>
</tr>
<tr>
<td><strong>Type</strong></td>
<td>JSON: <code>{ long_url, owner_id, ttl }</code></td>
<td>Minimal schema for fast validation and storage</td>
</tr>
<tr>
<td><strong>Storage</strong></td>
<td>DynamoDB (PK=code) for mapping; S3 for logs</td>
<td>Single-digit ms reads; elastic scale; cheap analytics storage</td>
</tr>
<tr>
<td><strong>Preprocessing / Compute</strong></td>
<td>Code gen via base62/ULID; optional custom alias; async analytics (Kinesis)</td>
<td>Collision avoidance; decouple hot path from analytics</td>
</tr>
<tr>
<td><strong>API</strong></td>
<td>REST + 301/302 redirect; rate-limits per owner</td>
<td>Browser-native redirect semantics; abuse protection</td>
</tr>
<tr>
<td><strong>Client</strong></td>
<td>Simple web console + CLI; QR export</td>
<td>Low-friction creation and sharing</td>
</tr>
<tr>
<td><strong>Security</strong></td>
<td>Auth (API keys/OAuth); domain allowlist; malware scanning</td>
<td>Prevents phishing/abuse; protects brand domains</td>
</tr>
<tr>
<td><strong>Scalability</strong></td>
<td>CloudFront → Lambda@Edge redirect cache; hot keys sharded</td>
<td>Edge-cached redirects minimize origin load/latency</td>
</tr>
<tr>
<td><strong>Reliability</strong></td>
<td>Multi-Region table (global tables); DLQ for failed writes</td>
<td>Regional failover; durable retry</td>
</tr>
<tr>
<td><strong>Observability</strong></td>
<td>Metrics: p50/p99 redirect latency, 4xx/5xx; click streams</td>
<td>Track UX and abuse; support analytics</td>
</tr>
<tr>
<td><strong>Infrastructure</strong></td>
<td>API Gateway + Lambda, DynamoDB, Kinesis, S3, CloudFront, WAF</td>
<td>Serverless, cost-efficient at any scale</td>
</tr>
</tbody>
</table>

<hr />

<h3 id="scenario-b-search-engine">Scenario 5: Search Engine (Vertical Site/Search Service)</h3>

<p><strong>Goal</strong>: Index documents/webpages and provide <strong>full-text search</strong> with <strong>filters</strong>, <strong>ranking</strong>, and <strong>autosuggest</strong>.</p>
<ul>
  <li><strong>Ingest &amp; crawl</strong> sources</li>
  <li><strong>Index</strong> fields + vectors</li>
  <li><strong>Query</strong>: keyword + semantic, filters, facets</li>
</ul>

<table class="study-table">
<thead>
<tr>
<th>Block</th>
<th>Design Choice</th>
<th>Justification</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Source</strong></td>
<td>Crawler / webhooks / batch uploads (S3)</td>
<td>Multiple ingestion modes for coverage and freshness</td>
</tr>
<tr>
<td><strong>Type</strong></td>
<td>JSON docs: title, body, facets, embedding</td>
<td>Supports keyword and vector (semantic) search</td>
</tr>
<tr>
<td><strong>Storage</strong></td>
<td>OpenSearch/Elastic (inverted index) + vector index; S3 cold store</td>
<td>Hybrid BM25 + ANN; cheap archive</td>
</tr>
<tr>
<td><strong>Preprocessing / Compute</strong></td>
<td>ETL: clean, dedupe, tokenize, embed; incremental indexing</td>
<td>Higher relevance; fast refresh with partial updates</td>
</tr>
<tr>
<td><strong>API</strong></td>
<td>Search REST: q, filters, sort; autosuggest endpoint</td>
<td>Standard search UX; low-latency responses</td>
</tr>
<tr>
<td><strong>Client</strong></td>
<td>Web UI: search box, facets, highlighting; pagination</td>
<td>Discoverability and relevance feedback</td>
</tr>
<tr>
<td><strong>Security</strong></td>
<td>Signed requests; per-tenant filter; index-level RBAC</td>
<td>Isolation and least privilege</td>
</tr>
<tr>
<td><strong>Scalability</strong></td>
<td>Sharded indexes; warm replicas; query cache/CDN for hot queries</td>
<td>Throughput and low tail latency</td>
</tr>
<tr>
<td><strong>Reliability</strong></td>
<td>Multi-AZ cluster; snapshot to S3; blue/green index swaps</td>
<td>Safe reindex; fast recovery</td>
</tr>
<tr>
<td><strong>Observability</strong></td>
<td>Metrics: QPS, p99, recall@k/CTR; slow logs; relevancy dashboards</td>
<td>Quality and performance tuning</td>
</tr>
<tr>
<td><strong>Infrastructure</strong></td>
<td>ECS/EKS crawlers, Lambda ETL, OpenSearch, S3, API Gateway, CloudFront</td>
<td>Managed search + serverless ETL</td>
</tr>
</tbody>
</table>

<hr />

<h3 id="scenario-c-ride-sharing">Scenario 6: Ride-Sharing (Dispatch &amp; Matching)</h3>

<p><strong>Goal</strong>: Match <strong>riders ↔ drivers</strong> in real time with <strong>ETA estimates</strong>, <strong>pricing</strong>, and <strong>tracking</strong>.</p>
<ul>
  <li><strong>High write</strong> (location updates) + <strong>low-latency reads</strong> (nearby drivers)</li>
  <li><strong>Geo-index</strong> + <strong>surge pricing</strong></li>
  <li><strong>Trip lifecycle</strong> events</li>
</ul>

<table class="study-table">
<thead>
<tr>
<th>Block</th>
<th>Design Choice</th>
<th>Justification</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Source</strong></td>
<td>Mobile apps (drivers/riders) → gRPC/HTTP + WebSocket</td>
<td>Bi-directional updates; efficient on mobile</td>
</tr>
<tr>
<td><strong>Type</strong></td>
<td>JSON/Protobuf: lat/lon, speed, status; trip events</td>
<td>Compact on-wire; structured for stream processing</td>
</tr>
<tr>
<td><strong>Storage</strong></td>
<td>Redis/KeyDB (geo sets) for live locations; Postgres for trips/payments; S3 for telemetry</td>
<td>Fast geo-nearby; durable transactional store</td>
</tr>
<tr>
<td><strong>Preprocessing / Compute</strong></td>
<td>Stream (Kafka): location smoothing, ETA calc, surge pricing; ML for ETA/dispatch</td>
<td>Low-latency decisions; adaptive pricing</td>
</tr>
<tr>
<td><strong>API</strong></td>
<td>REST: request/cancel trip, quote; WebSocket: live driver ETA/track</td>
<td>Seamless UX for requests + realtime updates</td>
</tr>
<tr>
<td><strong>Client</strong></td>
<td>Mobile map with live driver markers; push notifications</td>
<td>High-frequency updates with low battery impact</td>
</tr>
<tr>
<td><strong>Security</strong></td>
<td>JWT auth; signed location updates; fraud detection rules</td>
<td>Protects users and platform integrity</td>
</tr>
<tr>
<td><strong>Scalability</strong></td>
<td>Region-sharded dispatch; partition by city/zone; edge caches for maps/tiles</td>
<td>Reduces cross-region chatter; scales horizontally</td>
</tr>
<tr>
<td><strong>Reliability</strong></td>
<td>Leader election per region; idempotent trip ops; DLQs for events</td>
<td>Failover and consistent trip lifecycle</td>
</tr>
<tr>
<td><strong>Observability</strong></td>
<td>Metrics: match time, cancel rate, ETA error; traces for dispatch path</td>
<td>Operational and model quality monitoring</td>
</tr>
<tr>
<td><strong>Infrastructure</strong></td>
<td>API Gateway + ECS/EKS, Redis Geo, Kafka, Postgres/Aurora, S3, CloudFront, Pinpoint/SNS</td>
<td>Mix of in-memory geo + durable stores</td>
</tr>
</tbody>
</table>

    </article>
  </main>

  <div id="imageModal" class="image-modal">
  <div class="modal-content">
    <span class="modal-close">&times;</span>
    <button class="modal-nav modal-prev">&#8249;</button>
    <button class="modal-nav modal-next">&#8250;</button>
    <img id="modalImage" src="" alt="">
    <div id="modalCaption"></div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const modal = document.getElementById('imageModal');
  const modalImg = document.getElementById('modalImage');
  const modalCaption = document.getElementById('modalCaption');
  const modalClose = document.querySelector('.modal-close');
  const modalPrev = document.querySelector('.modal-prev');
  const modalNext = document.querySelector('.modal-next');

  const SCALE_STEP = 0.2;
  const MIN_SCALE = 1;
  const MAX_SCALE = 3;

  let modalImages = [];
  let currentIndex = -1;
  let currentScale = MIN_SCALE;
  let translateX = 0;
  let translateY = 0;
  let isDragging = false;
  let isTouchDragging = false;
  let isPinching = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let pinchStartDistance = 0;
  let pinchStartScale = MIN_SCALE;
  let transitionTimeout;

  function refreshModalImages() {
    modalImages = Array.from(document.querySelectorAll('.modal-trigger'));
  }

  function applyTransform(withTransition = false) {
    if (currentScale <= MIN_SCALE) {
      currentScale = MIN_SCALE;
      translateX = 0;
      translateY = 0;
    }

    if (transitionTimeout) {
      clearTimeout(transitionTimeout);
      transitionTimeout = null;
    }

    modalImg.style.transition = withTransition ? 'transform 0.15s ease' : 'none';
    modalImg.style.transform = `translate(${translateX}px, ${translateY}px) scale(${currentScale})`;
    modalImg.style.cursor = currentScale > MIN_SCALE
      ? (isDragging || isTouchDragging ? 'grabbing' : 'grab')
      : 'auto';

    if (withTransition) {
      transitionTimeout = setTimeout(() => {
        modalImg.style.transition = 'none';
      }, 160);
    }
  }

  function resetTransform() {
    currentScale = MIN_SCALE;
    translateX = 0;
    translateY = 0;
    applyTransform(false);
  }

  function getDistance(touch1, touch2) {
    return Math.hypot(
      touch1.clientX - touch2.clientX,
      touch1.clientY - touch2.clientY
    );
  }

  function openModalAtIndex(index) {
    refreshModalImages();

    if (!modalImages.length) {
      return;
    }

    if (index < 0) {
      index = modalImages.length - 1;
    } else if (index >= modalImages.length) {
      index = 0;
    }

    const target = modalImages[index];
    if (!target) {
      return;
    }

    currentIndex = index;
    const src = target.dataset.modalSrc || target.src;
    const caption = target.getAttribute('data-caption') || target.alt;

    modalImg.src = src;
    modalCaption.textContent = caption || '';
    modal.classList.add('show');
    document.body.style.overflow = 'hidden';
    resetTransform();
  }

  function closeModal() {
    if (!modal.classList.contains('show')) {
      return;
    }
    modal.classList.remove('show');
    document.body.style.overflow = '';
    currentIndex = -1;
    isDragging = false;
    isTouchDragging = false;
    isPinching = false;
    resetTransform();
  }

  refreshModalImages();

  modalImg.addEventListener('dragstart', event => event.preventDefault());

  document.addEventListener('click', event => {
    const trigger = event.target.closest('.modal-trigger');
    if (!trigger) {
      return;
    }

    event.preventDefault();
    refreshModalImages();
    const index = modalImages.indexOf(trigger);
    openModalAtIndex(index > -1 ? index : 0);
  });

  modalClose?.addEventListener('click', closeModal);

  modal.addEventListener('click', event => {
    if (event.target === modal) {
      closeModal();
    }
  });

  document.addEventListener('keydown', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    switch (event.key) {
      case 'Escape':
        closeModal();
        break;
      case 'ArrowLeft':
        event.preventDefault();
        openModalAtIndex(currentIndex - 1);
        break;
      case 'ArrowRight':
        event.preventDefault();
        openModalAtIndex(currentIndex + 1);
        break;
      case '+':
      case '=':
        event.preventDefault();
        currentScale = Math.min(MAX_SCALE, currentScale + SCALE_STEP);
        applyTransform(true);
        break;
      case '-':
        event.preventDefault();
        currentScale = Math.max(MIN_SCALE, currentScale - SCALE_STEP);
        applyTransform(true);
        break;
      case '0':
        event.preventDefault();
        resetTransform();
        applyTransform(true);
        break;
      default:
        break;
    }
  });

  modal.addEventListener('wheel', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    event.preventDefault();
    const delta = event.deltaY > 0 ? -SCALE_STEP : SCALE_STEP;
    const nextScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, currentScale + delta));

    if (nextScale === currentScale) {
      return;
    }

    currentScale = nextScale;
    applyTransform(true);
  }, { passive: false });

  if (modalPrev) {
    modalPrev.addEventListener('click', event => {
      event.preventDefault();
      if (currentIndex === -1) {
        return;
      }
      openModalAtIndex(currentIndex - 1);
    });
  }

  if (modalNext) {
    modalNext.addEventListener('click', event => {
      event.preventDefault();
      if (currentIndex === -1) {
        return;
      }
      openModalAtIndex(currentIndex + 1);
    });
  }

  modalImg.addEventListener('mousedown', event => {
    if (!modal.classList.contains('show') || currentScale <= MIN_SCALE) {
      return;
    }

    event.preventDefault();
    isDragging = true;
    dragStartX = event.clientX;
    dragStartY = event.clientY;
    modalImg.style.cursor = 'grabbing';
  });

  document.addEventListener('mousemove', event => {
    if (!isDragging) {
      return;
    }

    event.preventDefault();
    translateX += event.clientX - dragStartX;
    translateY += event.clientY - dragStartY;
    dragStartX = event.clientX;
    dragStartY = event.clientY;
    applyTransform(false);
  });

  document.addEventListener('mouseup', () => {
    if (!isDragging) {
      return;
    }
    isDragging = false;
    modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
  });

  modalImg.addEventListener('touchstart', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (event.touches.length === 1 && currentScale > MIN_SCALE) {
      event.preventDefault();
      isTouchDragging = true;
      dragStartX = event.touches[0].clientX;
      dragStartY = event.touches[0].clientY;
      modalImg.style.cursor = 'grabbing';
    } else if (event.touches.length === 2) {
      event.preventDefault();
      isTouchDragging = false;
      isPinching = true;
      pinchStartDistance = getDistance(event.touches[0], event.touches[1]);
      pinchStartScale = currentScale;
      modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
    }
  }, { passive: false });

  modalImg.addEventListener('touchmove', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (isPinching && event.touches.length === 2) {
      event.preventDefault();
      const distance = getDistance(event.touches[0], event.touches[1]);
      if (pinchStartDistance > 0) {
        const scaleRatio = distance / pinchStartDistance;
        currentScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, pinchStartScale * scaleRatio));
        applyTransform(false);
      }
    } else if (isTouchDragging && event.touches.length === 1) {
      event.preventDefault();
      translateX += event.touches[0].clientX - dragStartX;
      translateY += event.touches[0].clientY - dragStartY;
      dragStartX = event.touches[0].clientX;
      dragStartY = event.touches[0].clientY;
      applyTransform(false);
    }
  }, { passive: false });

  modalImg.addEventListener('touchend', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (event.touches.length === 0) {
      isTouchDragging = false;
      modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
    }

    if (event.touches.length < 2) {
      isPinching = false;
      pinchStartDistance = 0;
      pinchStartScale = currentScale;
    }
  });

  modalImg.addEventListener('touchcancel', () => {
    if (!modal.classList.contains('show')) {
      return;
    }

    isTouchDragging = false;
    isPinching = false;
    pinchStartDistance = 0;
    pinchStartScale = currentScale;
    modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
  });

  modal.addEventListener('touchend', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (event.target === modal && event.changedTouches.length === 1 && !isTouchDragging && !isPinching) {
      closeModal();
    }
  }, { passive: true });
});
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('[data-snippet-id]').forEach(caption => {
    const snippetId = caption.getAttribute('data-snippet-id');
    const snippetElement = document.getElementById(snippetId);

    if (snippetElement) {
      const content = snippetElement.textContent.replace(/"/g, '&quot;');
      caption.setAttribute('data-tooltip', content);
      caption.classList.add('diagram-caption');
    }
  });
});
</script>


  <!-- Floating Table of Contents -->
  <div id="floating-toc" class="floating-toc">
    <div class="toc-icon">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="8" y1="6" x2="21" y2="6"></line>
        <line x1="8" y1="12" x2="21" y2="12"></line>
        <line x1="8" y1="18" x2="21" y2="18"></line>
        <line x1="3" y1="6" x2="3.01" y2="6"></line>
        <line x1="3" y1="12" x2="3.01" y2="12"></line>
        <line x1="3" y1="18" x2="3.01" y2="18"></line>
      </svg>
    </div>
    <div class="toc-content">
      <div class="toc-header">
        <span>Contents</span>
        <button class="toc-close" aria-label="Close table of contents">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <nav class="toc-nav" id="toc-nav">
        <!-- Generated by JavaScript -->
      </nav>
    </div>
  </div>

  <footer class="site-footer">
    <span>© 2025 glucolte • </span>
    <a href="https://github.com/gLuColte/glucolte.github.io">source</a>
  </footer>

  <script>
    // Dark mode functionality
    function initDarkMode() {
      const toggle = document.getElementById('dark-mode-toggle');
      const body = document.body;
      
      // Check for saved theme preference or default to light mode
      const savedTheme = localStorage.getItem('theme');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      
      if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
        body.setAttribute('data-theme', 'dark');
      }
      
      // Toggle dark mode
      if (toggle) {
        toggle.addEventListener('click', function() {
          const currentTheme = body.getAttribute('data-theme');
          const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
          
          body.setAttribute('data-theme', newTheme);
          localStorage.setItem('theme', newTheme);
        });
      }
    }
    
    // Initialize dark mode immediately to prevent flash
    initDarkMode();
    
    // Initialize highlight.js and floating TOC after the DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      hljs.highlightAll();
      
      // Floating TOC functionality - only show on sub-study pages
      const floatingToc = document.getElementById('floating-toc');
      const tocNav = document.getElementById('toc-nav');
      const tocClose = document.querySelector('.toc-close');
      
      // Check if we're on a sub-study page (not the main study index)
      const isSubStudyPage = window.location.pathname !== '/study/' && 
                            window.location.pathname !== '/study' && 
                            window.location.pathname.startsWith('/study/');
      
      if (floatingToc && tocNav && isSubStudyPage) {
        // Generate TOC from headings
        function generateTOC() {
          const headings = document.querySelectorAll('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6');
          if (headings.length === 0) {
            floatingToc.style.display = 'none';
            return;
          }
          
          const tocList = document.createElement('ul');
          let currentLevel = 0;
          let currentList = tocList;
          const listStack = [tocList];
          
          headings.forEach((heading, index) => {
            const level = parseInt(heading.tagName.charAt(1));
            const id = heading.id || `heading-${index}`;
            
            // Ensure heading has an ID
            if (!heading.id) {
              heading.id = id;
            }
            
            // Create list item
            const listItem = document.createElement('li');
            const link = document.createElement('a');
            link.href = `#${id}`;
            link.textContent = heading.textContent.trim();
            link.addEventListener('click', function(e) {
              e.preventDefault();
              const targetElement = document.getElementById(id);
              if (targetElement) {
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                // Close TOC after clicking
                floatingToc.classList.remove('toc-open');
              }
            });
            
            listItem.appendChild(link);
            
            // Handle nesting
            if (level > currentLevel) {
              // Go deeper
              for (let i = currentLevel; i < level; i++) {
                const newList = document.createElement('ul');
                currentList.appendChild(newList);
                listStack.push(newList);
                currentList = newList;
              }
            } else if (level < currentLevel) {
              // Go shallower
              for (let i = currentLevel; i > level; i--) {
                listStack.pop();
                currentList = listStack[listStack.length - 1];
              }
            }
            
            currentList.appendChild(listItem);
            currentLevel = level;
          });
          
          tocNav.appendChild(tocList);
        }
        
        // Generate the TOC
        generateTOC();
        
        // Handle close button
        if (tocClose) {
          tocClose.addEventListener('click', function() {
            floatingToc.classList.remove('toc-open');
          });
        }
        
        // Handle click on icon to toggle
        const tocIcon = document.querySelector('.toc-icon');
        if (tocIcon) {
          tocIcon.addEventListener('click', function() {
            floatingToc.classList.toggle('toc-open');
          });
        }
        
        // Active section highlighting
        function updateActiveSection() {
          const headings = document.querySelectorAll('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6');
          const tocLinks = tocNav.querySelectorAll('a');
          
          // Remove active class from all links
          tocLinks.forEach(link => link.classList.remove('active'));
          
          // Find the current section
          let currentHeading = null;
          const scrollPosition = window.scrollY + 100; // Offset for better UX
          
          for (let i = headings.length - 1; i >= 0; i--) {
            const heading = headings[i];
            const headingTop = heading.offsetTop;
            
            if (headingTop <= scrollPosition) {
              currentHeading = heading;
              break;
            }
          }
          
          // Add active class to current section
          if (currentHeading) {
            const activeLink = tocNav.querySelector(`a[href="#${currentHeading.id}"]`);
            if (activeLink) {
              activeLink.classList.add('active');
            }
          }
        }
        
        // Update active section on scroll
        let scrollTimeout;
        window.addEventListener('scroll', function() {
          if (scrollTimeout) {
            clearTimeout(scrollTimeout);
          }
          scrollTimeout = setTimeout(updateActiveSection, 10);
        });
        
        // Initial update
        updateActiveSection();
      } else if (floatingToc && !isSubStudyPage) {
        // Hide floating TOC on main study page
        floatingToc.style.display = 'none';
      }
      
      // Legacy TOC functionality (for existing markdown TOCs)
      const toc = document.querySelector('#markdown-toc');
      if (toc) {
        // Hide the floating TOC if there's already a markdown TOC
        if (floatingToc) {
          floatingToc.style.display = 'none';
        }
        
        // Create TOC container with header
        const tocContainer = document.createElement('div');
        tocContainer.className = 'toc-container';
        tocContainer.style.cssText = `
          background: #f8fafc;
          border: 1px solid #e5e7eb;
          border-radius: 8px;
          padding: 16px;
          margin: 20px 0;
          position: relative;
        `;
        
        // Add TOC header
        const tocHeader = document.createElement('h3');
        tocHeader.textContent = 'Table of Contents';
        tocHeader.style.cssText = `
          margin: 0 0 12px 0;
          font-size: 16px;
          font-weight: 600;
          color: #374151;
        `;
        
        // Add back to top button
        const backToTopBtn = document.createElement('button');
        backToTopBtn.textContent = '↑ Top';
        backToTopBtn.style.cssText = `
          position: absolute;
          top: 12px;
          right: 12px;
          background: #ffffff;
          border: 1px solid #d1d5db;
          border-radius: 6px;
          padding: 4px 8px;
          font-size: 12px;
          cursor: pointer;
          color: #6b7280;
          transition: all 0.2s ease;
        `;
        
        // Add hover effect for back to top button
        backToTopBtn.addEventListener('mouseenter', function() {
          this.style.background = '#f3f4f6';
          this.style.color = '#374151';
        });
        
        backToTopBtn.addEventListener('mouseleave', function() {
          this.style.background = '#ffffff';
          this.style.color = '#6b7280';
        });
        
        // Back to top functionality
        backToTopBtn.addEventListener('click', function() {
          window.scrollTo({ top: 0, behavior: 'smooth' });
        });
        
        // Style the TOC list
        toc.style.cssText = `
          margin: 0;
          padding: 0;
          font-size: 14px;
          line-height: 1.5;
        `;
        
        // Insert header and button into container
        tocContainer.appendChild(tocHeader);
        tocContainer.appendChild(backToTopBtn);
        tocContainer.appendChild(toc);
        
        // Replace the original TOC with the new container
        toc.parentNode.insertBefore(tocContainer, toc);
        tocContainer.appendChild(toc);
        
        // Add smooth scrolling to TOC links
        const tocLinks = toc.querySelectorAll('a');
        tocLinks.forEach(link => {
          link.addEventListener('click', function(e) {
            e.preventDefault();
            const targetId = this.getAttribute('href').substring(1);
            const targetElement = document.getElementById(targetId);
            if (targetElement) {
              targetElement.scrollIntoView({ behavior: 'smooth' });
            }
          });
        });
      }
    });
  </script>
</body>
</html>
