<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>AWS Caching Services Â· glucolte</title>
  <meta name="description" content="notes â€¢ principles â€¢ systems">
  <link rel="stylesheet" href="/assets/style.css">
  <link rel="stylesheet" href="/assets/study.css">
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/favicon.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>AWS Caching Services | glucolte</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="AWS Caching Services" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="notes â€¢ principles â€¢ systems" />
<meta property="og:description" content="notes â€¢ principles â€¢ systems" />
<link rel="canonical" href="http://localhost:4000/study/infrastructureAWSCaching" />
<meta property="og:url" content="http://localhost:4000/study/infrastructureAWSCaching" />
<meta property="og:site_name" content="glucolte" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="AWS Caching Services" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"notes â€¢ principles â€¢ systems","headline":"AWS Caching Services","url":"http://localhost:4000/study/infrastructureAWSCaching"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
  <header class="site-header">
  <a class="brand" href="/">glucolte</a>
  <nav class="nav">
    <a href="/principles">principles</a>
    <a href="/rules">rules</a>
    <a href="/stretches">stretches</a>
    <a href="/study/">study</a>
    <a href="/projects/">projects</a>
    <a href="/setup/">setup</a>
  </nav>
  <button id="dark-mode-toggle" class="dark-mode-toggle" aria-label="Toggle dark mode">
    <svg class="sun-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
    <svg class="moon-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
    </svg>
  </button>
</header>


  <main class="container">
    <article class="content">
      <h2 id="section-1-amazon-cloudfront">1. Amazon CloudFront</h2>

<p>Global CDN that accelerates downloads by caching objects at edge locations (PoPs) backed by regional edge caches before reaching the origin (S3, ALB, MediaPackage, custom HTTP endpoints).</p>

<div class="image-wrapper">
  <img src="./assets/cloudfront_private_content.png" alt="cloudfront-private-content" class="modal-trigger" data-caption="ðŸ§© CloudFront signed-cookie flow" />
  <div class="image-caption">ðŸ§© CloudFront signed-cookie flow</div>
  <script type="text/plain" id="cloudfront-private-content">
@startuml
title CloudFront Private Content via Signed Cookies

actor Viewer
participant CloudFront
participant APIGateway as "API Gateway"
participant Lambda as "Lambda Signer"
database S3 as "Private S3 Buckets"

== Request signed cookie ==
Viewer -> APIGateway: GET /signed-cookie?resource=/images/*
APIGateway -> Lambda: Invoke Signer(resource, viewer session)
Lambda -> Lambda: Validate session\nCreate signed policy (path, expiry, IP)
Lambda --> APIGateway: Return signed cookies
APIGateway --> Viewer: 200 OK + Set-Cookie (CloudFront-Policy,\nSignature, Key-Pair-Id)

note right of Viewer
Browser stores signed cookies:
 - CloudFront-Policy
 - CloudFront-Signature
 - CloudFront-Key-Pair-Id
end note

== Access private image ==
Viewer -> CloudFront: GET /images/photo.jpg (with signed cookies)
CloudFront -> CloudFront: Validate signature, expiry, policy
alt Cookie valid
  CloudFront -> S3: GET /images/photo.jpg (via OAC/OAI)
  S3 --> CloudFront: 200 OK (object)
  CloudFront --> Viewer: 200 OK (cached at edge)
else Cookie invalid or expired
  CloudFront --> Viewer: 403 Forbidden
end

== Optional refresh ==
Viewer -> APIGateway: GET /refresh-cookie
APIGateway -> Lambda: Invoke Signer(refresh)
Lambda --> APIGateway: Return new signed cookies
APIGateway --> Viewer: 200 OK + new Set-Cookie
@enduml
  </script>
</div>

<h3 id="section-1-1-cloudfront-security">1.1 Private Content &amp; Security</h3>

<ul>
  <li><strong>Origin Access Control (OAC)</strong> â€“ recommended successor to Origin Access Identity. Grants CloudFront a unique IAM principal to read private S3 buckets; attach the generated policy to S3.</li>
  <li><strong>Custom origins</strong> â€“ restrict access using secret headers or Web Application Firewall (WAF) IP sets (CloudFront IP ranges). OAC/OAI not supported with ALB/EC2 origins.</li>
  <li><strong>Private content</strong> â€“ require signed URLs or signed cookies per behavior. Trusted key groups provide flexible signer management. Combine with API Gateway/Lambda to issue short-lived cookies after auth.</li>
  <li><strong>Geo restriction</strong> â€“ built-in country-level allow/deny lists using geo-IP databases. For finer control, front CloudFront with an authorization service that issues signed URLs.</li>
  <li><strong>Field-level encryption</strong> â€“ encrypt sensitive form fields at the edge so only designated backends can decrypt payloads, even after CloudFront forwards over HTTPS.</li>
  <li><strong>TLS/SNI handshake</strong> â€“ when a viewer connects over HTTPS, CloudFront presents the certificate associated with your alternate domain name. Server Name Indication (SNI) allows multiple certs per IP, so viewers include the hostname in the TLS ClientHello before encryption. For legacy clients lacking SNI, use dedicated IP distributions. Between CloudFront and the origin, a second TLS session is negotiated using the originâ€™s cert; custom origins must present a cert from a trusted public CA.</li>
</ul>

<div class="image-wrapper">
  <img src="./assets/cloudfront_sni.png" alt="cloudfront-sni" class="modal-trigger" data-caption="ðŸ§© CloudFront SNI flow" />
  <div class="image-caption">ðŸ§© CloudFront SNI flow</div>
  <script type="text/plain" id="cloudfront-sni">
@startuml
autonumber
title CloudFront Multi-SSL / SNI TLS Flow

actor Browser as B
participant "CloudFront Edge Location" as CF
collections "Certificate Store\n(ACM / Trusted CA certs)" as CERTS
participant "Origin (S3 / ALB / EC2 / On-Prem)" as O

== Viewer TLS Handshake (Browser â†’ CloudFront) ==

note over B
Browser initiates HTTPS request
https://www.example.com
end note

B -> CF: ClientHello + SNI = "www.example.com"

note over CF
CloudFront supports multiple certificates
on the SAME edge location
using **SNI (Server Name Indication)**.
end note

CF -> CERTS: Select certificate matching SNI
CERTS --> CF: Correct certificate returned

CF --> B: ServerHello + Certificate + TLS handshake complete

note over B,CF
TLS session established (viewer protocol).
Browser only uses cert matching the hostname.
end note


== Request Handling ==

B -> CF: HTTPS Request (GET /index.html)

alt Cache HIT
    CF --> B: Cached response
else Cache MISS
    note over CF
    CF must talk to the origin using
    a separate connection + SSL validation
    end note

    == Origin TLS Handshake (CF â†’ Origin) ==

    CF -> O: HTTPS request (Origin Protocol Policy)

    note right of O
    Origin must present a valid certificate.
    â€¢ S3: native AWS-managed cert
    â€¢ ALB: ACM certificate allowed
    â€¢ EC2/on-prem: must be CA-issued
    â€¢ No self-signed certs allowed
    end note

    O --> CF: TLS handshake complete
    O --> CF: HTTPS Response (content)
end

CF --> B: HTTP Response (cached or fresh content)

@enduml
  </script>
</div>

<h3 id="section-1-2-cloudfront-architecture">1.2 Distribution Building Blocks</h3>

<ul>
  <li><strong>Origins</strong> â€“ S3 bucket, ALB, MediaStore, MediaPackage, or any publicly reachable HTTP server. Each origin can be tied to one or more cache behaviors.</li>
  <li><strong>Cache behaviors</strong> â€“ routing rules based on path patterns (<code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">img/*</code>, etc.) mapping viewers to specific origins, viewer/origin protocols, headers, cookies, and query strings.</li>
  <li><strong>Edge â†’ Regional edge cache â†’ Origin flow</strong> â€“ if the edge server misses, it checks the regional cache before touching the origin, reducing load.</li>
  <li><strong>Viewer vs Origin protocol</strong> â€“ choose HTTP/HTTPS per side; enforce minimum TLS versions for custom origins. ACM certificates (issued in <code class="language-plaintext highlighter-rouge">us-east-1</code>) cover alternate domain names.</li>
</ul>

<h3 id="section-1-3-cloudfront-caching">1.3 Caching Controls</h3>

<ul>
  <li><strong>TTL defaults</strong> â€“ 24 hours unless overridden. Cache keys include object name, optional query strings, cookies, and headers.</li>
  <li><strong>HTTP directives</strong> â€“ <code class="language-plaintext highlighter-rouge">Cache-Control: max-age</code>, <code class="language-plaintext highlighter-rouge">s-maxage</code>, and <code class="language-plaintext highlighter-rouge">Expires</code> headers override cache lifetime. Minimum and maximum TTLs can be enforced per behavior.</li>
  <li><strong>Invalidations</strong> â€“ manually expire objects before TTL (wildcards allowed). Versioned object names (<code class="language-plaintext highlighter-rouge">app_v42.js</code>) avoid invalidation charges.</li>
  <li><strong>Cache hit ratio</strong> â€“ higher hit ratios reduce origin load; forward only the headers/cookies/query strings required by the application to keep cache keys compact.</li>
</ul>

<h3 id="section-1-4-lambda-edge">1.4 Lambda@Edge</h3>

<ul>
  <li>Lightweight Node.js/Python Lambda functions deployed to edge locations.</li>
  <li>Hook points: viewer request, viewer response, origin request, origin response. Viewer triggers limited to 128 MB memory/5s; origin triggers up to 30s.</li>
  <li>Use cases: A/B testing, device-based redirects, origin migration, header normalization, country-based content.</li>
</ul>

<hr />

<h2 id="section-2-amazon-elasticache">2. Amazon ElastiCache</h2>

<p>Managed in-memory caching service offering Redis and Memcached clusters to offload read-heavy workloads, session data, and transient state from databases.</p>

<h3 id="section-2-1-cache-general">2.1 General Characteristics</h3>

<ul>
  <li><strong>Purpose</strong> â€“ sub-millisecond access to hot data, reducing pressure on RDS/DynamoDB and enabling stateless app tiers.</li>
  <li><strong>Integration</strong> â€“ requires application logic to <code class="language-plaintext highlighter-rouge">GET</code>/<code class="language-plaintext highlighter-rouge">SET</code> cache entries, invalidate data, and fall back to the database.</li>
  <li><strong>Engine choices</strong>:
    <ul>
      <li><strong>Memcached</strong> â€“ simple key/value store, multi-threaded, no replication, no persistence. Scale by sharding data across nodes.</li>
      <li><strong>Redis</strong> â€“ richer data types (lists, sets, sorted sets, bitmaps), replication, Multi-AZ failover, snapshots/backups, pub/sub, Lua scripts, transactions.</li>
    </ul>
  </li>
  <li><strong>Security/ops</strong> â€“ subnet groups place cache nodes in specific AZs; security groups restrict clients. Enable encryption in-transit/at-rest and AUTH tokens (Redis AUTH) for production. Use parameter groups to tune eviction policy (<code class="language-plaintext highlighter-rouge">allkeys-lru</code>, <code class="language-plaintext highlighter-rouge">volatile-ttl</code>, etc.).</li>
</ul>

<h3 id="section-2-2-memcached-redis">2.2 Memcached vs Redis</h3>

<table class="study-table">
<thead>
<tr>
<th>Feature</th>
<th>Memcached</th>
<th>Redis</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Data types</strong></td>
<td>Strings only.</td>
<td>Strings, lists, hashes, sets, sorted sets, bitmaps, geospatial.</td>
</tr>
<tr>
<td><strong>Replication/HA</strong></td>
<td>None (client-side sharding only).</td>
<td>Multi-AZ replication with automatic failover.</td>
</tr>
<tr>
<td><strong>Persistence</strong></td>
<td>None.</td>
<td>Snapshots + append-only file (AOF) backups.</td>
</tr>
<tr>
<td><strong>Threading</strong></td>
<td>Multi-threaded per node.</td>
<td>Single-threaded per shard (cluster handles parallelism).</td>
</tr>
<tr>
<td><strong>Use cases</strong></td>
<td>Simple caches, horizontal sharding, minimal features.</td>
<td>Leaderboards, session stores, distributed locks, queues, richer data processing.</td>
</tr>
</tbody>
</table>

<hr />

<h2 id="section-3-related">3. Related Concepts</h2>

<ul>
  <li><strong>CloudFront + API integrations</strong> â€“ combine private origins, WAF, and signed URLs/cookies for authenticated content distribution.</li>
  <li><strong>Caching guidance</strong> â€“ forward only the request properties that affect object variation (headers, cookies, query strings) to maximize cache hit ratio.</li>
  <li><strong>Origin security</strong> â€“ use OAC for S3, custom headers for ALB/EC2, and ACM certificates for HTTPS-only flows.</li>
  <li><strong>Dynamic sites</strong> â€“ CloudFront accelerates static assets and proxies dynamic requests, but you still need compute (ALB/EC2/ECS/Lambda) behind it; S3 static hosting is not enough for read/write applications.</li>
</ul>

<hr />

    </article>
  </main>

  <div id="imageModal" class="image-modal">
  <div class="modal-content">
    <span class="modal-close">&times;</span>
    <button class="modal-nav modal-prev">&#8249;</button>
    <button class="modal-nav modal-next">&#8250;</button>
    <img id="modalImage" src="" alt="">
    <div id="modalCaption"></div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const modal = document.getElementById('imageModal');
  const modalImg = document.getElementById('modalImage');
  const modalCaption = document.getElementById('modalCaption');
  const modalClose = document.querySelector('.modal-close');
  const modalPrev = document.querySelector('.modal-prev');
  const modalNext = document.querySelector('.modal-next');

  const SCALE_STEP = 0.2;
  const MIN_SCALE = 1;
  const MAX_SCALE = 3;

  let modalImages = [];
  let currentIndex = -1;
  let currentScale = MIN_SCALE;
  let translateX = 0;
  let translateY = 0;
  let isDragging = false;
  let isTouchDragging = false;
  let isPinching = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let pinchStartDistance = 0;
  let pinchStartScale = MIN_SCALE;
  let transitionTimeout;

  function refreshModalImages() {
    modalImages = Array.from(document.querySelectorAll('.modal-trigger'));
  }

  function applyTransform(withTransition = false) {
    if (currentScale <= MIN_SCALE) {
      currentScale = MIN_SCALE;
      translateX = 0;
      translateY = 0;
    }

    if (transitionTimeout) {
      clearTimeout(transitionTimeout);
      transitionTimeout = null;
    }

    modalImg.style.transition = withTransition ? 'transform 0.15s ease' : 'none';
    modalImg.style.transform = `translate(${translateX}px, ${translateY}px) scale(${currentScale})`;
    modalImg.style.cursor = currentScale > MIN_SCALE
      ? (isDragging || isTouchDragging ? 'grabbing' : 'grab')
      : 'auto';

    if (withTransition) {
      transitionTimeout = setTimeout(() => {
        modalImg.style.transition = 'none';
      }, 160);
    }
  }

  function resetTransform() {
    currentScale = MIN_SCALE;
    translateX = 0;
    translateY = 0;
    applyTransform(false);
  }

  function getDistance(touch1, touch2) {
    return Math.hypot(
      touch1.clientX - touch2.clientX,
      touch1.clientY - touch2.clientY
    );
  }

  function openModalAtIndex(index) {
    refreshModalImages();

    if (!modalImages.length) {
      return;
    }

    if (index < 0) {
      index = modalImages.length - 1;
    } else if (index >= modalImages.length) {
      index = 0;
    }

    const target = modalImages[index];
    if (!target) {
      return;
    }

    currentIndex = index;
    const src = target.dataset.modalSrc || target.src;
    const caption = target.getAttribute('data-caption') || target.alt;

    modalImg.src = src;
    modalCaption.textContent = caption || '';
    modal.classList.add('show');
    document.body.style.overflow = 'hidden';
    resetTransform();
  }

  function closeModal() {
    if (!modal.classList.contains('show')) {
      return;
    }
    modal.classList.remove('show');
    document.body.style.overflow = '';
    currentIndex = -1;
    isDragging = false;
    isTouchDragging = false;
    isPinching = false;
    resetTransform();
  }

  refreshModalImages();

  modalImg.addEventListener('dragstart', event => event.preventDefault());

  document.addEventListener('click', event => {
    const trigger = event.target.closest('.modal-trigger');
    if (!trigger) {
      return;
    }

    event.preventDefault();
    refreshModalImages();
    const index = modalImages.indexOf(trigger);
    openModalAtIndex(index > -1 ? index : 0);
  });

  modalClose?.addEventListener('click', closeModal);

  modal.addEventListener('click', event => {
    if (event.target === modal) {
      closeModal();
    }
  });

  document.addEventListener('keydown', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    switch (event.key) {
      case 'Escape':
        closeModal();
        break;
      case 'ArrowLeft':
        event.preventDefault();
        openModalAtIndex(currentIndex - 1);
        break;
      case 'ArrowRight':
        event.preventDefault();
        openModalAtIndex(currentIndex + 1);
        break;
      case '+':
      case '=':
        event.preventDefault();
        currentScale = Math.min(MAX_SCALE, currentScale + SCALE_STEP);
        applyTransform(true);
        break;
      case '-':
        event.preventDefault();
        currentScale = Math.max(MIN_SCALE, currentScale - SCALE_STEP);
        applyTransform(true);
        break;
      case '0':
        event.preventDefault();
        resetTransform();
        applyTransform(true);
        break;
      default:
        break;
    }
  });

  modal.addEventListener('wheel', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    event.preventDefault();
    const delta = event.deltaY > 0 ? -SCALE_STEP : SCALE_STEP;
    const nextScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, currentScale + delta));

    if (nextScale === currentScale) {
      return;
    }

    currentScale = nextScale;
    applyTransform(true);
  }, { passive: false });

  if (modalPrev) {
    modalPrev.addEventListener('click', event => {
      event.preventDefault();
      if (currentIndex === -1) {
        return;
      }
      openModalAtIndex(currentIndex - 1);
    });
  }

  if (modalNext) {
    modalNext.addEventListener('click', event => {
      event.preventDefault();
      if (currentIndex === -1) {
        return;
      }
      openModalAtIndex(currentIndex + 1);
    });
  }

  modalImg.addEventListener('mousedown', event => {
    if (!modal.classList.contains('show') || currentScale <= MIN_SCALE) {
      return;
    }

    event.preventDefault();
    isDragging = true;
    dragStartX = event.clientX;
    dragStartY = event.clientY;
    modalImg.style.cursor = 'grabbing';
  });

  document.addEventListener('mousemove', event => {
    if (!isDragging) {
      return;
    }

    event.preventDefault();
    translateX += event.clientX - dragStartX;
    translateY += event.clientY - dragStartY;
    dragStartX = event.clientX;
    dragStartY = event.clientY;
    applyTransform(false);
  });

  document.addEventListener('mouseup', () => {
    if (!isDragging) {
      return;
    }
    isDragging = false;
    modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
  });

  modalImg.addEventListener('touchstart', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (event.touches.length === 1 && currentScale > MIN_SCALE) {
      event.preventDefault();
      isTouchDragging = true;
      dragStartX = event.touches[0].clientX;
      dragStartY = event.touches[0].clientY;
      modalImg.style.cursor = 'grabbing';
    } else if (event.touches.length === 2) {
      event.preventDefault();
      isTouchDragging = false;
      isPinching = true;
      pinchStartDistance = getDistance(event.touches[0], event.touches[1]);
      pinchStartScale = currentScale;
      modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
    }
  }, { passive: false });

  modalImg.addEventListener('touchmove', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (isPinching && event.touches.length === 2) {
      event.preventDefault();
      const distance = getDistance(event.touches[0], event.touches[1]);
      if (pinchStartDistance > 0) {
        const scaleRatio = distance / pinchStartDistance;
        currentScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, pinchStartScale * scaleRatio));
        applyTransform(false);
      }
    } else if (isTouchDragging && event.touches.length === 1) {
      event.preventDefault();
      translateX += event.touches[0].clientX - dragStartX;
      translateY += event.touches[0].clientY - dragStartY;
      dragStartX = event.touches[0].clientX;
      dragStartY = event.touches[0].clientY;
      applyTransform(false);
    }
  }, { passive: false });

  modalImg.addEventListener('touchend', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (event.touches.length === 0) {
      isTouchDragging = false;
      modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
    }

    if (event.touches.length < 2) {
      isPinching = false;
      pinchStartDistance = 0;
      pinchStartScale = currentScale;
    }
  });

  modalImg.addEventListener('touchcancel', () => {
    if (!modal.classList.contains('show')) {
      return;
    }

    isTouchDragging = false;
    isPinching = false;
    pinchStartDistance = 0;
    pinchStartScale = currentScale;
    modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
  });

  modal.addEventListener('touchend', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (event.target === modal && event.changedTouches.length === 1 && !isTouchDragging && !isPinching) {
      closeModal();
    }
  }, { passive: true });
});
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('[data-snippet-id]').forEach(caption => {
    const snippetId = caption.getAttribute('data-snippet-id');
    const snippetElement = document.getElementById(snippetId);

    if (snippetElement) {
      const content = snippetElement.textContent.replace(/"/g, '&quot;');
      caption.setAttribute('data-tooltip', content);
      caption.classList.add('diagram-caption');
    }
  });
});
</script>


  <!-- Floating Table of Contents -->
  <div id="floating-toc" class="floating-toc">
    <div class="toc-icon">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="8" y1="6" x2="21" y2="6"></line>
        <line x1="8" y1="12" x2="21" y2="12"></line>
        <line x1="8" y1="18" x2="21" y2="18"></line>
        <line x1="3" y1="6" x2="3.01" y2="6"></line>
        <line x1="3" y1="12" x2="3.01" y2="12"></line>
        <line x1="3" y1="18" x2="3.01" y2="18"></line>
      </svg>
    </div>
    <div class="toc-content">
      <div class="toc-header">
        <span>Contents</span>
        <button class="toc-close" aria-label="Close table of contents">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <nav class="toc-nav" id="toc-nav">
        <!-- Generated by JavaScript -->
      </nav>
    </div>
  </div>

  <footer class="site-footer">
    <span>Â© 2026 glucolte â€¢ </span>
    <a href="https://github.com/gLuColte/glucolte.github.io">source</a>
  </footer>

  <script>
    // Dark mode functionality
    function initDarkMode() {
      const toggle = document.getElementById('dark-mode-toggle');
      const body = document.body;
      
      // Check for saved theme preference or default to light mode
      const savedTheme = localStorage.getItem('theme');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      
      if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
        body.setAttribute('data-theme', 'dark');
      }
      
      // Toggle dark mode
      if (toggle) {
        toggle.addEventListener('click', function() {
          const currentTheme = body.getAttribute('data-theme');
          const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
          
          body.setAttribute('data-theme', newTheme);
          localStorage.setItem('theme', newTheme);
        });
      }
    }
    
    // Initialize dark mode immediately to prevent flash
    initDarkMode();
    
    // Initialize highlight.js and floating TOC after the DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      hljs.highlightAll();
      
      // Floating TOC functionality - only show on sub-study pages
      const floatingToc = document.getElementById('floating-toc');
      const tocNav = document.getElementById('toc-nav');
      const tocClose = document.querySelector('.toc-close');
      
      // Check if we're on a sub-study page (not the main study index)
      const isSubStudyPage = window.location.pathname !== '/study/' && 
                            window.location.pathname !== '/study' && 
                            window.location.pathname.startsWith('/study/');
      
      if (floatingToc && tocNav && isSubStudyPage) {
        // Generate TOC from headings
        function generateTOC() {
          const headings = document.querySelectorAll('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6');
          if (headings.length === 0) {
            floatingToc.style.display = 'none';
            return;
          }
          
          const tocList = document.createElement('ul');
          let currentLevel = 0;
          let currentList = tocList;
          const listStack = [tocList];
          
          headings.forEach((heading, index) => {
            const level = parseInt(heading.tagName.charAt(1));
            const id = heading.id || `heading-${index}`;
            
            // Ensure heading has an ID
            if (!heading.id) {
              heading.id = id;
            }
            
            // Create list item
            const listItem = document.createElement('li');
            const link = document.createElement('a');
            link.href = `#${id}`;
            link.textContent = heading.textContent.trim();
            link.addEventListener('click', function(e) {
              e.preventDefault();
              const targetElement = document.getElementById(id);
              if (targetElement) {
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                // Close TOC after clicking
                floatingToc.classList.remove('toc-open');
              }
            });
            
            listItem.appendChild(link);
            
            // Handle nesting
            if (level > currentLevel) {
              // Go deeper
              for (let i = currentLevel; i < level; i++) {
                const newList = document.createElement('ul');
                currentList.appendChild(newList);
                listStack.push(newList);
                currentList = newList;
              }
            } else if (level < currentLevel) {
              // Go shallower
              for (let i = currentLevel; i > level; i--) {
                listStack.pop();
                currentList = listStack[listStack.length - 1];
              }
            }
            
            currentList.appendChild(listItem);
            currentLevel = level;
          });
          
          tocNav.appendChild(tocList);
        }
        
        // Generate the TOC
        generateTOC();
        
        // Handle close button
        if (tocClose) {
          tocClose.addEventListener('click', function() {
            floatingToc.classList.remove('toc-open');
          });
        }
        
        // Handle click on icon to toggle
        const tocIcon = document.querySelector('.toc-icon');
        if (tocIcon) {
          tocIcon.addEventListener('click', function() {
            floatingToc.classList.toggle('toc-open');
          });
        }
        
        // Active section highlighting
        function updateActiveSection() {
          const headings = document.querySelectorAll('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6');
          const tocLinks = tocNav.querySelectorAll('a');
          
          // Remove active class from all links
          tocLinks.forEach(link => link.classList.remove('active'));
          
          // Find the current section
          let currentHeading = null;
          const scrollPosition = window.scrollY + 100; // Offset for better UX
          
          for (let i = headings.length - 1; i >= 0; i--) {
            const heading = headings[i];
            const headingTop = heading.offsetTop;
            
            if (headingTop <= scrollPosition) {
              currentHeading = heading;
              break;
            }
          }
          
          // Add active class to current section
          if (currentHeading) {
            const activeLink = tocNav.querySelector(`a[href="#${currentHeading.id}"]`);
            if (activeLink) {
              activeLink.classList.add('active');
            }
          }
        }
        
        // Update active section on scroll
        let scrollTimeout;
        window.addEventListener('scroll', function() {
          if (scrollTimeout) {
            clearTimeout(scrollTimeout);
          }
          scrollTimeout = setTimeout(updateActiveSection, 10);
        });
        
        // Initial update
        updateActiveSection();
      } else if (floatingToc && !isSubStudyPage) {
        // Hide floating TOC on main study page
        floatingToc.style.display = 'none';
      }
      
      // Legacy TOC functionality (for existing markdown TOCs)
      const toc = document.querySelector('#markdown-toc');
      if (toc) {
        // Hide the floating TOC if there's already a markdown TOC
        if (floatingToc) {
          floatingToc.style.display = 'none';
        }
        
        // Create TOC container with header
        const tocContainer = document.createElement('div');
        tocContainer.className = 'toc-container';
        tocContainer.style.cssText = `
          background: #f8fafc;
          border: 1px solid #e5e7eb;
          border-radius: 8px;
          padding: 16px;
          margin: 20px 0;
          position: relative;
        `;
        
        // Add TOC header
        const tocHeader = document.createElement('h3');
        tocHeader.textContent = 'Table of Contents';
        tocHeader.style.cssText = `
          margin: 0 0 12px 0;
          font-size: 16px;
          font-weight: 600;
          color: #374151;
        `;
        
        // Add back to top button
        const backToTopBtn = document.createElement('button');
        backToTopBtn.textContent = 'â†‘ Top';
        backToTopBtn.style.cssText = `
          position: absolute;
          top: 12px;
          right: 12px;
          background: #ffffff;
          border: 1px solid #d1d5db;
          border-radius: 6px;
          padding: 4px 8px;
          font-size: 12px;
          cursor: pointer;
          color: #6b7280;
          transition: all 0.2s ease;
        `;
        
        // Add hover effect for back to top button
        backToTopBtn.addEventListener('mouseenter', function() {
          this.style.background = '#f3f4f6';
          this.style.color = '#374151';
        });
        
        backToTopBtn.addEventListener('mouseleave', function() {
          this.style.background = '#ffffff';
          this.style.color = '#6b7280';
        });
        
        // Back to top functionality
        backToTopBtn.addEventListener('click', function() {
          window.scrollTo({ top: 0, behavior: 'smooth' });
        });
        
        // Style the TOC list
        toc.style.cssText = `
          margin: 0;
          padding: 0;
          font-size: 14px;
          line-height: 1.5;
        `;
        
        // Insert header and button into container
        tocContainer.appendChild(tocHeader);
        tocContainer.appendChild(backToTopBtn);
        tocContainer.appendChild(toc);
        
        // Replace the original TOC with the new container
        toc.parentNode.insertBefore(tocContainer, toc);
        tocContainer.appendChild(toc);
        
        // Add smooth scrolling to TOC links
        const tocLinks = toc.querySelectorAll('a');
        tocLinks.forEach(link => {
          link.addEventListener('click', function(e) {
            e.preventDefault();
            const targetId = this.getAttribute('href').substring(1);
            const targetElement = document.getElementById(targetId);
            if (targetElement) {
              targetElement.scrollIntoView({ behavior: 'smooth' });
            }
          });
        });
      }
    });
  </script>
</body>
</html>
