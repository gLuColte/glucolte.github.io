<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Compute, Scaling &amp; Load Balancing ¬∑ glucolte</title>
  <meta name="description" content="notes ‚Ä¢ principles ‚Ä¢ systems">
  <link rel="stylesheet" href="/assets/style.css">
  <link rel="stylesheet" href="/assets/study.css">
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/favicon.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Compute, Scaling &amp; Load Balancing | glucolte</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Compute, Scaling &amp; Load Balancing" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="notes ‚Ä¢ principles ‚Ä¢ systems" />
<meta property="og:description" content="notes ‚Ä¢ principles ‚Ä¢ systems" />
<link rel="canonical" href="http://localhost:4000/study/tmp_awsProStudyCompute.html" />
<meta property="og:url" content="http://localhost:4000/study/tmp_awsProStudyCompute.html" />
<meta property="og:site_name" content="glucolte" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Compute, Scaling &amp; Load Balancing" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"notes ‚Ä¢ principles ‚Ä¢ systems","headline":"Compute, Scaling &amp; Load Balancing","url":"http://localhost:4000/study/tmp_awsProStudyCompute.html"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
  <header class="site-header">
  <a class="brand" href="/">glucolte</a>
  <nav class="nav">
    <a href="/principles">principles</a>
    <a href="/rules">rules</a>
    <a href="/stretches">stretches</a>
    <a href="/study/">study</a>
    <a href="/projects/">projects</a>
    <a href="/setup/">setup</a>
  </nav>
  <button id="dark-mode-toggle" class="dark-mode-toggle" aria-label="Toggle dark mode">
    <svg class="sun-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
    <svg class="moon-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
    </svg>
  </button>
</header>


  <main class="container">
    <article class="content">
      
<h1 id="compute-scaling--load-balancing">Compute, Scaling &amp; Load Balancing</h1>

<p>Regional and Global AWS Architecture</p>
<ul>
  <li>Global Service Location &amp; Delivery</li>
  <li>CDN</li>
  <li>Global Health Checks &amp; Failover</li>
  <li>Regional etnry point</li>
  <li>Scaling and resilient</li>
</ul>

<p><img src="./Screenshot%20regional-gloal-intro.png" alt="regional and global intro" /></p>

<h2 id="ec2-purchase-options">EC2 Purchase Options</h2>
<ul>
  <li>On Demand - Instance
    <ul>
      <li>Shared Hardware with other customers</li>
      <li>Per Second billing</li>
      <li>Situation:
        <ul>
          <li>Default</li>
          <li>No Reservation</li>
          <li>Short Term workloads</li>
          <li>Unkown workloads</li>
          <li>No Interruption</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Spot - Instance
    <ul>
      <li>Shared Hardware with Customers</li>
      <li>Per Second Billing</li>
      <li>Cheapest Solution</li>
      <li>Selling unused EC2 Host Capacity for discount up to 90%</li>
      <li>Situation:
        <ul>
          <li>Never use for workload that can‚Äôt tolerate interruptions</li>
          <li>Non time critical, can be re run busty</li>
          <li>Stateless workfloads</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Reserved - Instance
    <ul>
      <li>Reduced per second Billing</li>
      <li>Unused reservation still billed</li>
      <li>Lock per AZ</li>
      <li>Partial coverage of larger instance</li>
      <li>‚ÄúYou commit to AWS you will use a period of time‚Äù
        <ul>
          <li>1 year or 3 years</li>
          <li>All Upfront(Greatest discount) vs Partial upfront (Partial upfront, lower /s) vs No Upfront (Reduced per second billing)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Dedicated Host
    <ul>
      <li>Strict Hardware restriction</li>
      <li>Physical Host</li>
      <li>No instance charges</li>
      <li>You need to manage the dedicated host capacity</li>
      <li>You can allocated Instance on the Hosts, until it runs out
  e.g. r5 2 socket and 48 CORES</li>
      <li>Situation
        <ul>
          <li>You might have software that is licensed based on Socket/Cores</li>
        </ul>
      </li>
      <li>Host Affinity Feature
        <ul>
          <li>Linking instances to certain Host 
  (Meaning you can‚Äôt pull up another host)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Dedicated Instance
    <ul>
      <li>Hardware trscition, but don‚Äôt want to manage capacity (you dont pay for unused resource)</li>
      <li>Middle ground</li>
      <li>You don‚Äôt own, or share the host.</li>
      <li>Extra Charges for instances</li>
      <li>But hardware dedicated</li>
    </ul>
  </li>
</ul>

<p><img src="./Screenshot%20ec2_purchaser_option.png" alt="EC2 Launch type" /></p>

<h2 id="reserved-instances">Reserved Instances</h2>

<p>Scheduled Reserved Instances</p>
<ul>
  <li>Schedules for long term usage which doesn‚Äôt run constantly
    <ul>
      <li>e.g. Batch Processing daily for 5 hours, starting at 23:00</li>
    </ul>
  </li>
  <li>Block an hour at a period of day/week/month to process</li>
  <li>Doesn‚Äôt support all instance type or region</li>
  <li>1,200 hours per year and 1 year MINIMUM CONTRACT</li>
</ul>

<p>Capactiy Reservations</p>
<ul>
  <li>Regional Reservation provides a billing discount for valid instances launched in any AZ in that region
    <ul>
      <li>Dont reserver capacity within an AZ</li>
    </ul>
  </li>
  <li>Zonal Reservation, one AZ billing discounts and capacity reservation
    <ul>
      <li>Locked in 1 az only</li>
    </ul>
  </li>
  <li>On Demand capacity reservation
    <ul>
      <li>Can be booked to ensure you always have access to capacity in an AZ when you need it, but at full on demand price</li>
      <li>No term apply</li>
    </ul>
  </li>
  <li>No 1 or 3 year reservation</li>
</ul>

<p>EC2 Saving Plans</p>
<ul>
  <li>A hourly commitement for a year or 3 year</li>
  <li>Reservation of general compute $ amounts
    <ul>
      <li>$ 20 per hour for 3 years</li>
    </ul>
  </li>
  <li>or a specific EC2 Savings plan</li>
  <li>EC2/Fargate/Lambda
    <ul>
      <li>Products have an on-demand rate and a saving plan rate</li>
    </ul>
  </li>
</ul>

<h3 id="-ec2-charging--capacity-options-taxi-edition">üöï EC2 Charging &amp; Capacity Options (Taxi Edition)</h3>

<table>
  <thead>
    <tr>
      <th>Plan</th>
      <th>What it means (simple)</th>
      <th>Taxi analogy üöñ</th>
      <th>Commitment</th>
      <th>Capacity guaranteed?</th>
      <th>Discount vs On-Demand</th>
      <th>When to use it</th>
      <th>How you pay</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>On-Demand</strong></td>
      <td>Use EC2 anytime, no contract.</td>
      <td>üöï <em>You hail a taxi when you need one.</em> Pay per ride; if it‚Äôs busy, you might wait.</td>
      <td>None</td>
      <td>‚ùå No</td>
      <td>‚ùå None</td>
      <td>Testing, unpredictable, or short-term workloads.</td>
      <td>Pay full price only when running.</td>
    </tr>
    <tr>
      <td><strong>Savings Plan</strong></td>
      <td>Promise to spend a fixed $/hr for 1‚Äì3 yrs; AWS gives flexible discounts.</td>
      <td>üöï <em>You sign a deal to always spend $X/hour on taxis ‚Äî any taxi, any route ‚Äî cheaper rides.</em></td>
      <td>1‚Äì3 yrs</td>
      <td>‚ùå No</td>
      <td>‚úÖ Up to ~70%</td>
      <td>Continuous usage but flexible instance types/regions.</td>
      <td>Discounted hourly billing based on commitment.</td>
    </tr>
    <tr>
      <td><strong>Reserved Instance (RI)</strong></td>
      <td>Lock a specific instance type &amp; region for 1‚Äì3 yrs to save more.</td>
      <td>üöï <em>You rent one taxi full-time for a year ‚Äî cheaper rate, but you can‚Äôt swap cars easily.</em></td>
      <td>1‚Äì3 yrs</td>
      <td>‚ùå No (‚úÖ only for Zonal RI)</td>
      <td>‚úÖ Up to ~70%</td>
      <td>Predictable workloads running 24√ó7.</td>
      <td>Pay upfront or monthly.</td>
    </tr>
    <tr>
      <td><strong>Scheduled RI</strong></td>
      <td>Reserve instances for recurring time windows (e.g. weekdays 9‚Äì5).</td>
      <td>üöï <em>You pre-book the same taxi every weekday morning and evening ‚Äî guaranteed and cheaper.</em></td>
      <td>1 yr</td>
      <td>‚úÖ Yes (during that window)</td>
      <td>‚úÖ Discounted</td>
      <td>Workloads with fixed daily/weekly schedules.</td>
      <td>Pay for reserved time slots only.</td>
    </tr>
    <tr>
      <td><strong>Capacity Reservation</strong></td>
      <td>Tell AWS ‚Äúkeep these servers ready now in this AZ‚Äù; cancel anytime.</td>
      <td>üöï <em>You tell the driver: keep the taxi running while I run into a store ‚Äî guaranteed it‚Äôs waiting, meter‚Äôs running.</em></td>
      <td>Until cancelled</td>
      <td>‚úÖ Yes</td>
      <td>‚ùå None (can pair with RI/Savings Plan)</td>
      <td>Critical workloads needing guaranteed start (DR, finance, healthcare).</td>
      <td>Pay On-Demand price even if idle.</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="-dedicated-options-private-car-edition">üöó Dedicated Options (Private Car Edition)</h3>

<table>
  <thead>
    <tr>
      <th>Option</th>
      <th>What it means</th>
      <th>Car analogy üöó</th>
      <th>Capacity guaranteed?</th>
      <th>Discount?</th>
      <th>When to use it</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Dedicated Instance</strong></td>
      <td>Your EC2 runs on hardware <strong>not shared</strong> with anyone else (AWS still manages it).</td>
      <td>üöò <em>A private taxi ‚Äî only you ride in it, but the company still owns and maintains the car.</em></td>
      <td>‚úÖ Yes (for isolation)</td>
      <td>‚ùå None</td>
      <td>When you need compliance isolation but don‚Äôt need full host control.</td>
    </tr>
    <tr>
      <td><strong>Dedicated Host</strong></td>
      <td>You rent the entire physical server ‚Äî full control &amp; visibility.</td>
      <td>üöô <em>You buy or lease the whole car ‚Äî you decide who drives, can use your own license plates (BYOL).</em></td>
      <td>‚úÖ Yes</td>
      <td>‚úÖ (with RI or SP)</td>
      <td>For strict compliance or bring-your-own-license scenarios.</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="ec2-networking">EC2 Networking</h2>
<ul>
  <li>ENI (Note ENI is created independently to EC2)
    <ul>
      <li>Primary/Secondary (you can have 1 or more secondary - large instances)
        <ul>
          <li>Primary NEVER change</li>
          <li>Dynamic allocated and its ENI‚Äôs entire lifetime, can not be changed</li>
          <li>Allocated IPv4 based on Subnet‚Äôs CIDR</li>
        </ul>
      </li>
      <li>Can only be in an AZ
  e.g. you have 2 subnet in 1 AZ, and then you can assign 2 ENI in each Subnet (for different SG/NACL configuration)
  YOU CAN NOT assign across AZs</li>
      <li>If you tick Public
        <ul>
          <li>Then 1 public IP will be assigned, and its dynamic</li>
        </ul>
      </li>
      <li>You can allocate 1 Elastiv IP per Pricate Ipv4
        <ul>
          <li>EIP does association</li>
          <li>EIP is charged when it is allocated</li>
        </ul>
      </li>
      <li>Ipv6 can be assigned 1 or more</li>
      <li>1 mac address for ENI (Software Licensing usage)</li>
      <li>1 or more SG</li>
      <li>SRC/DST Check
        <ul>
          <li>drops Packet if the SRC/DST address isnt ON that interface</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="bootstrapping-vs-ami-baking">Bootstrapping vs AMI Baking</h2>

<ul>
  <li>Application server contains 3 main steps usually in sequence:
    <ol>
      <li>Base Deps/App (VERY SLOT and VERY Generic)</li>
      <li>App Updates (NOT FAST and Generic)</li>
      <li>App Configuration (FAST and UNIQUE)</li>
    </ol>
  </li>
  <li>Step 1 Optimication (Can use combination of following)
    <ul>
      <li>User Data
        <ul>
          <li>Install of additional things when an instance is launched</li>
          <li>For:
            <ul>
              <li>Customized for e.g. Region</li>
            </ul>
          </li>
          <li>Cons:
            <ul>
              <li>Still take some time</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>AMI Baking
        <ul>
          <li>Create a dedicated AMI for yourself</li>
          <li>For:
            <ul>
              <li>Most time consuming operation that does not change much</li>
            </ul>
          </li>
          <li>Cons:
            <ul>
              <li>Harder to adjust</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Step 2 Optimciation</li>
  <li>Step 3 Optimization
    <ul>
      <li>Need to make it flexible, e.g. region/custom specific (Parameter Store)</li>
    </ul>
  </li>
</ul>

<h2 id="elastic-load-balancer">Elastic Load Balancer</h2>
<ul>
  <li>ELB can go across AZs
    <ul>
      <li>Loosen the coupling between Tiers (Web/Application/DB)</li>
      <li>Then you can scale your different tiers</li>
    </ul>
  </li>
  <li>Architecture
    <ul>
      <li>Configured to run in 2+ AZs, each run in a subnet</li>
      <li>Each ELB is configured with an A record DNS name point at 1+ ELB Nodes (or listeners)</li>
      <li>If Internet Facing
        <ul>
          <li>Node have Public IPs</li>
          <li>EC2 DO NOT have to be public Facing to be zoned to (as long as it is in the same Subnet)</li>
        </ul>
      </li>
      <li>If Internal Facing
        <ul>
          <li>Node have Pricate IPs</li>
        </ul>
      </li>
      <li>Nodes are configured with Listeners which accept traffic on a port and protocol and communicate with targets on a port and protocol</li>
      <li>8+ free IPs per subnet and a /27 or larger subnet to allow for scale</li>
    </ul>
  </li>
</ul>

<p><img src="./Screenshot%202025-10-05%20at%2022.29.01.png" alt="ELB" /></p>

<p>Here is the flow:</p>
<ol>
  <li>Client connects to the ELB DNS name (e.g. myapp-1234.ap-southeast-2.elb.amazonaws.com).</li>
  <li>DNS resolves that name to one of the ELB‚Äôs IPs, which belongs to a load balancer node in a specific Availability Zone (AZ).</li>
  <li>Traffic lands on that listener IP inside the subnet (the ELB node for that AZ).</li>
  <li>The listener checks:
‚Ä¢	The protocol (HTTP, HTTPS, TCP, etc.)
‚Ä¢	The port (e.g., 80, 443)
‚Ä¢	Any rules (e.g., host-based, path-based, or redirect)</li>
  <li>The listener forwards the request (over the private VPC network) to a target group.</li>
  <li>A target (such as an EC2 instance) in that group is chosen based on the load-balancing algorithm.</li>
  <li>The target‚Äôs ENI (private IP) receives the request and processes it.</li>
  <li>The response is sent back through the ELB node to the client.</li>
  <li>The ELB continuously:
‚Ä¢	Performs health checks on all targets.
‚Ä¢	Manages session stickiness (if enabled).
‚Ä¢	Ensures even load distribution across healthy targets.</li>
</ol>

<ul>
  <li>Cross Cont Load Balancing
    <ul>
      <li>Let‚Äôs say you have ZOne A with 4 instance, Zone B with 1 instance</li>
      <li>Load balancing is done on ‚ÄúZOne Level‚Äù
        <ul>
          <li>meaning 50% traffic goes to each zone</li>
          <li>That means Zone B has 1 instance dealing with 50 %</li>
        </ul>
      </li>
      <li>Cross Load balancing is allowing Zone B Node to distribute traffic to Zone A
<img src="./Screenshot%202025-10-05%20at%2022.39.28.png" alt="Cross ZOne Load" /></li>
    </ul>
  </li>
</ul>

<h3 id="user-session-state">User Session State</h3>
<ul>
  <li>Piece of Server Side Information
    <ul>
      <li>Persist while you interact with that application</li>
      <li>e.g. Shopping Cart, Workflow Position, Login State</li>
    </ul>
  </li>
  <li>Usually stored:
    <ul>
      <li>Server</li>
      <li>Externally e.g. Redis/Memcache
        <ul>
          <li>(Your Servers become serverless)</li>
          <li>every request or click might hit a different server</li>
          <li>No disruption and better scaling</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="types-of-elb">Types of ELB</h3>
<ul>
  <li>V1 is to be Avoided
    <ul>
      <li>Classic Load Balancer
        <ul>
          <li>Not really Layer 7, lack Features</li>
          <li>Only support 1 SSL per CLB
            <ul>
              <li>Becuase SNI is not supported</li>
              <li>(Security Network Interface)</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>V2 is preferred (SUPPORT SNI)
    <ul>
      <li>Network Load Balancer
        <ul>
          <li>For non HTTP/HTTPS connections
            <ul>
              <li>No Visibility on HTTP/HTTPS -&gt; No Headers, cookies or session stickeness</li>
            </ul>
          </li>
          <li>TCP/TLS and UDP</li>
          <li>Millions of RPs, 25% of ALB Latency</li>
          <li>Health Check are just
            <ul>
              <li>ICMP/TCP Handshake</li>
            </ul>
          </li>
          <li>Can have static IPs for whitelisting</li>
          <li>UNBROKEN ENCRYPTION - basically forward TCP to instances</li>
        </ul>
      </li>
      <li>Application Load Balacner
        <ul>
          <li>True Layer 7
            <ul>
              <li>Can understand content type, cookies, custom headers..etc</li>
              <li>Hence can use multiple domain as different rules</li>
            </ul>
          </li>
          <li>HTTP/s/Websocket
            <ul>
              <li>DOEST NOT SUPPORT SMTP/SSH/GAMING..etc</li>
              <li>NO TCP/UDP/TLS Listeners</li>
            </ul>
          </li>
          <li>HTTPS
            <ul>
              <li>Support multiple SSL</li>
              <li>Terminated on ALB ALWAYS</li>
              <li>a new unencrypted connection is made to the application</li>
            </ul>
          </li>
          <li>Can perform Application Health Check</li>
          <li>Can Setup Rules based on Priority Order
            <ul>
              <li>e.g. Rule Condition on header, and Actions for that rule</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="./Screenshot%202025-10-05%20at%2022.53.32.png" alt="v1 and v2 Load Balancer" /></p>

<h3 id="session-stickness">Session Stickness</h3>
<ul>
  <li>without stickness
    <ul>
      <li>User are directed to instance based on load distribution</li>
    </ul>
  </li>
  <li>With Stickness
    <ul>
      <li>‚ÄúAWSALB‚Äù Cookie is introduced in your session
        <ul>
          <li>Last for 1 second to 7 days (max)</li>
        </ul>
      </li>
      <li>This cookie ensures the SAME backend instance is used</li>
      <li>A new cookie is added:
        <ul>
          <li>if Instance changed</li>
          <li>if Expired</li>
        </ul>
      </li>
      <li>Can cause un-even load distribution</li>
      <li>Used usually when external cache is not allowed</li>
    </ul>
  </li>
</ul>

<h2 id="auto-scaling-group">Auto Scaling Group</h2>
<ul>
  <li>Automatic Scaling and Self Healing for EC2</li>
  <li>Launch Templates/Configurations
    <ul>
      <li>Templates</li>
      <li>Configuraitons</li>
    </ul>
  </li>
  <li>Paramters:
    <ul>
      <li>Minimum Capacity</li>
      <li>Desired Capacity</li>
      <li>Maximum Capacity</li>
    </ul>
  </li>
  <li>Sacling Policies - Defines how you ‚Äúprovision‚Äù or ‚Äúterminate‚Äù
    <ul>
      <li>Manual</li>
      <li>Scheduled Scaling - e.g. time based</li>
      <li>Dynamic Scaling (Need CloudWatch Metrics)
        <ul>
          <li>Simple Scaling - ‚ÄúCPU above 50% +1, Below 50% -1‚Äù</li>
          <li>Stepped Scaling - More granular, e.g. Bigger +/- based on difference +50% = +1, +60%=+2, +80%=+5</li>
          <li>Target Tracking - Desired Aggregated CPU = 40 %</li>
        </ul>
      </li>
      <li>Cooldown Periods
        <ul>
          <li>Avoid rapid Scaling</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Monitors EC2
    <ul>
      <li>EC2 instance check</li>
    </ul>
  </li>
  <li>Keep running instances at the DESIRED CAPACITY by provisioning or terminating instances through Scaling Policies</li>
  <li>Constraints
    <ul>
      <li>Can only be in VPC (across multiple subnets)</li>
    </ul>
  </li>
  <li>Self Healing Procedure
    <ol>
      <li>ASG detects failure</li>
      <li>ASG starts a EC2</li>
      <li>EC2 is ready</li>
      <li>ASG replace the EC2</li>
    </ol>
  </li>
  <li>Scaling Procedure
    <ul>
      <li>Notes:
        <ul>
          <li>Launch and Terniate - SUSPEND and RESUME</li>
          <li>AddToLoadBalancer - add to LB on Launch</li>
          <li>AlarmNotification - accept notifcation from CW</li>
          <li>AZ REbalance - Balances instance evenly across all of the AZs</li>
          <li>HealthCheck - instance health checks on/ooff</li>
          <li>Replace Unhealthy - Terminate unhealthy</li>
          <li>Scheduled Actions - Schedule Scaling</li>
          <li>Standby - use to keep warm
      0. Scale out event detected
      1. Pending
  1.a Pending Wait
  1.b Pending Proceed
      2. In Service</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="asg-with-load-balancers">ASG with Load Balancers</h3>
<ul>
  <li>Configured to integrate with Target Group (1+ Instances)</li>
  <li>ASG instances are automatically added to or removed from the Target Group</li>
  <li>ASG can use Load balancer health checks rather than EC2 status checks</li>
  <li>This way you are not tied to an instance but Target Group</li>
</ul>

<h3 id="asg-lifecycles-hooks">ASG LifeCycles Hooks</h3>
<ul>
  <li>Custom Actions on instanace during ASG Actions
    <ul>
      <li>instance launch or instance terminate transitions</li>
    </ul>
  </li>
  <li>Instance are paused within the flow‚Ä¶they wait
    <ul>
      <li>until a timeout (then either continue or abandon)</li>
      <li>or you resume the ASG proces CompleteLifeCycleAction</li>
      <li>usually with EventBridge</li>
    </ul>
  </li>
  <li>This is specifically when you need to scale in or out NOT when failure occurs
    <ul>
      <li>this adds Wait and Proceed states to PENDING/TERMINATING</li>
      <li>Allowing you to add extra steps or process to take
  e.g. load or backup data/logs</li>
    </ul>
  </li>
</ul>

    </article>
  </main>

  <div id="imageModal" class="image-modal">
  <div class="modal-content">
    <span class="modal-close">&times;</span>
    <button class="modal-nav modal-prev">&#8249;</button>
    <button class="modal-nav modal-next">&#8250;</button>
    <img id="modalImage" src="" alt="">
    <div id="modalCaption"></div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const modal = document.getElementById('imageModal');
  const modalImg = document.getElementById('modalImage');
  const modalCaption = document.getElementById('modalCaption');
  const modalClose = document.querySelector('.modal-close');
  const modalPrev = document.querySelector('.modal-prev');
  const modalNext = document.querySelector('.modal-next');

  const SCALE_STEP = 0.2;
  const MIN_SCALE = 1;
  const MAX_SCALE = 3;

  let modalImages = [];
  let currentIndex = -1;
  let currentScale = MIN_SCALE;
  let translateX = 0;
  let translateY = 0;
  let isDragging = false;
  let isTouchDragging = false;
  let isPinching = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let pinchStartDistance = 0;
  let pinchStartScale = MIN_SCALE;
  let transitionTimeout;

  function refreshModalImages() {
    modalImages = Array.from(document.querySelectorAll('.modal-trigger'));
  }

  function applyTransform(withTransition = false) {
    if (currentScale <= MIN_SCALE) {
      currentScale = MIN_SCALE;
      translateX = 0;
      translateY = 0;
    }

    if (transitionTimeout) {
      clearTimeout(transitionTimeout);
      transitionTimeout = null;
    }

    modalImg.style.transition = withTransition ? 'transform 0.15s ease' : 'none';
    modalImg.style.transform = `translate(${translateX}px, ${translateY}px) scale(${currentScale})`;
    modalImg.style.cursor = currentScale > MIN_SCALE
      ? (isDragging || isTouchDragging ? 'grabbing' : 'grab')
      : 'auto';

    if (withTransition) {
      transitionTimeout = setTimeout(() => {
        modalImg.style.transition = 'none';
      }, 160);
    }
  }

  function resetTransform() {
    currentScale = MIN_SCALE;
    translateX = 0;
    translateY = 0;
    applyTransform(false);
  }

  function getDistance(touch1, touch2) {
    return Math.hypot(
      touch1.clientX - touch2.clientX,
      touch1.clientY - touch2.clientY
    );
  }

  function openModalAtIndex(index) {
    refreshModalImages();

    if (!modalImages.length) {
      return;
    }

    if (index < 0) {
      index = modalImages.length - 1;
    } else if (index >= modalImages.length) {
      index = 0;
    }

    const target = modalImages[index];
    if (!target) {
      return;
    }

    currentIndex = index;
    const src = target.dataset.modalSrc || target.src;
    const caption = target.getAttribute('data-caption') || target.alt;

    modalImg.src = src;
    modalCaption.textContent = caption || '';
    modal.classList.add('show');
    document.body.style.overflow = 'hidden';
    resetTransform();
  }

  function closeModal() {
    if (!modal.classList.contains('show')) {
      return;
    }
    modal.classList.remove('show');
    document.body.style.overflow = '';
    currentIndex = -1;
    isDragging = false;
    isTouchDragging = false;
    isPinching = false;
    resetTransform();
  }

  refreshModalImages();

  modalImg.addEventListener('dragstart', event => event.preventDefault());

  document.addEventListener('click', event => {
    const trigger = event.target.closest('.modal-trigger');
    if (!trigger) {
      return;
    }

    event.preventDefault();
    refreshModalImages();
    const index = modalImages.indexOf(trigger);
    openModalAtIndex(index > -1 ? index : 0);
  });

  modalClose?.addEventListener('click', closeModal);

  modal.addEventListener('click', event => {
    if (event.target === modal) {
      closeModal();
    }
  });

  document.addEventListener('keydown', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    switch (event.key) {
      case 'Escape':
        closeModal();
        break;
      case 'ArrowLeft':
        event.preventDefault();
        openModalAtIndex(currentIndex - 1);
        break;
      case 'ArrowRight':
        event.preventDefault();
        openModalAtIndex(currentIndex + 1);
        break;
      case '+':
      case '=':
        event.preventDefault();
        currentScale = Math.min(MAX_SCALE, currentScale + SCALE_STEP);
        applyTransform(true);
        break;
      case '-':
        event.preventDefault();
        currentScale = Math.max(MIN_SCALE, currentScale - SCALE_STEP);
        applyTransform(true);
        break;
      case '0':
        event.preventDefault();
        resetTransform();
        applyTransform(true);
        break;
      default:
        break;
    }
  });

  modal.addEventListener('wheel', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    event.preventDefault();
    const delta = event.deltaY > 0 ? -SCALE_STEP : SCALE_STEP;
    const nextScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, currentScale + delta));

    if (nextScale === currentScale) {
      return;
    }

    currentScale = nextScale;
    applyTransform(true);
  }, { passive: false });

  if (modalPrev) {
    modalPrev.addEventListener('click', event => {
      event.preventDefault();
      if (currentIndex === -1) {
        return;
      }
      openModalAtIndex(currentIndex - 1);
    });
  }

  if (modalNext) {
    modalNext.addEventListener('click', event => {
      event.preventDefault();
      if (currentIndex === -1) {
        return;
      }
      openModalAtIndex(currentIndex + 1);
    });
  }

  modalImg.addEventListener('mousedown', event => {
    if (!modal.classList.contains('show') || currentScale <= MIN_SCALE) {
      return;
    }

    event.preventDefault();
    isDragging = true;
    dragStartX = event.clientX;
    dragStartY = event.clientY;
    modalImg.style.cursor = 'grabbing';
  });

  document.addEventListener('mousemove', event => {
    if (!isDragging) {
      return;
    }

    event.preventDefault();
    translateX += event.clientX - dragStartX;
    translateY += event.clientY - dragStartY;
    dragStartX = event.clientX;
    dragStartY = event.clientY;
    applyTransform(false);
  });

  document.addEventListener('mouseup', () => {
    if (!isDragging) {
      return;
    }
    isDragging = false;
    modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
  });

  modalImg.addEventListener('touchstart', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (event.touches.length === 1 && currentScale > MIN_SCALE) {
      event.preventDefault();
      isTouchDragging = true;
      dragStartX = event.touches[0].clientX;
      dragStartY = event.touches[0].clientY;
      modalImg.style.cursor = 'grabbing';
    } else if (event.touches.length === 2) {
      event.preventDefault();
      isTouchDragging = false;
      isPinching = true;
      pinchStartDistance = getDistance(event.touches[0], event.touches[1]);
      pinchStartScale = currentScale;
      modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
    }
  }, { passive: false });

  modalImg.addEventListener('touchmove', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (isPinching && event.touches.length === 2) {
      event.preventDefault();
      const distance = getDistance(event.touches[0], event.touches[1]);
      if (pinchStartDistance > 0) {
        const scaleRatio = distance / pinchStartDistance;
        currentScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, pinchStartScale * scaleRatio));
        applyTransform(false);
      }
    } else if (isTouchDragging && event.touches.length === 1) {
      event.preventDefault();
      translateX += event.touches[0].clientX - dragStartX;
      translateY += event.touches[0].clientY - dragStartY;
      dragStartX = event.touches[0].clientX;
      dragStartY = event.touches[0].clientY;
      applyTransform(false);
    }
  }, { passive: false });

  modalImg.addEventListener('touchend', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (event.touches.length === 0) {
      isTouchDragging = false;
      modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
    }

    if (event.touches.length < 2) {
      isPinching = false;
      pinchStartDistance = 0;
      pinchStartScale = currentScale;
    }
  });

  modalImg.addEventListener('touchcancel', () => {
    if (!modal.classList.contains('show')) {
      return;
    }

    isTouchDragging = false;
    isPinching = false;
    pinchStartDistance = 0;
    pinchStartScale = currentScale;
    modalImg.style.cursor = currentScale > MIN_SCALE ? 'grab' : 'auto';
  });

  modal.addEventListener('touchend', event => {
    if (!modal.classList.contains('show')) {
      return;
    }

    if (event.target === modal && event.changedTouches.length === 1 && !isTouchDragging && !isPinching) {
      closeModal();
    }
  }, { passive: true });
});
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('[data-snippet-id]').forEach(caption => {
    const snippetId = caption.getAttribute('data-snippet-id');
    const snippetElement = document.getElementById(snippetId);

    if (snippetElement) {
      const content = snippetElement.textContent.replace(/"/g, '&quot;');
      caption.setAttribute('data-tooltip', content);
      caption.classList.add('diagram-caption');
    }
  });
});
</script>


  <!-- Floating Table of Contents -->
  <div id="floating-toc" class="floating-toc">
    <div class="toc-icon">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="8" y1="6" x2="21" y2="6"></line>
        <line x1="8" y1="12" x2="21" y2="12"></line>
        <line x1="8" y1="18" x2="21" y2="18"></line>
        <line x1="3" y1="6" x2="3.01" y2="6"></line>
        <line x1="3" y1="12" x2="3.01" y2="12"></line>
        <line x1="3" y1="18" x2="3.01" y2="18"></line>
      </svg>
    </div>
    <div class="toc-content">
      <div class="toc-header">
        <span>Contents</span>
        <button class="toc-close" aria-label="Close table of contents">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <nav class="toc-nav" id="toc-nav">
        <!-- Generated by JavaScript -->
      </nav>
    </div>
  </div>

  <footer class="site-footer">
    <span>¬© 2025 glucolte ‚Ä¢ </span>
    <a href="https://github.com/gLuColte/glucolte.github.io">source</a>
  </footer>

  <script>
    // Dark mode functionality
    function initDarkMode() {
      const toggle = document.getElementById('dark-mode-toggle');
      const body = document.body;
      
      // Check for saved theme preference or default to light mode
      const savedTheme = localStorage.getItem('theme');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      
      if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
        body.setAttribute('data-theme', 'dark');
      }
      
      // Toggle dark mode
      if (toggle) {
        toggle.addEventListener('click', function() {
          const currentTheme = body.getAttribute('data-theme');
          const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
          
          body.setAttribute('data-theme', newTheme);
          localStorage.setItem('theme', newTheme);
        });
      }
    }
    
    // Initialize dark mode immediately to prevent flash
    initDarkMode();
    
    // Initialize highlight.js and floating TOC after the DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      hljs.highlightAll();
      
      // Floating TOC functionality - only show on sub-study pages
      const floatingToc = document.getElementById('floating-toc');
      const tocNav = document.getElementById('toc-nav');
      const tocClose = document.querySelector('.toc-close');
      
      // Check if we're on a sub-study page (not the main study index)
      const isSubStudyPage = window.location.pathname !== '/study/' && 
                            window.location.pathname !== '/study' && 
                            window.location.pathname.startsWith('/study/');
      
      if (floatingToc && tocNav && isSubStudyPage) {
        // Generate TOC from headings
        function generateTOC() {
          const headings = document.querySelectorAll('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6');
          if (headings.length === 0) {
            floatingToc.style.display = 'none';
            return;
          }
          
          const tocList = document.createElement('ul');
          let currentLevel = 0;
          let currentList = tocList;
          const listStack = [tocList];
          
          headings.forEach((heading, index) => {
            const level = parseInt(heading.tagName.charAt(1));
            const id = heading.id || `heading-${index}`;
            
            // Ensure heading has an ID
            if (!heading.id) {
              heading.id = id;
            }
            
            // Create list item
            const listItem = document.createElement('li');
            const link = document.createElement('a');
            link.href = `#${id}`;
            link.textContent = heading.textContent.trim();
            link.addEventListener('click', function(e) {
              e.preventDefault();
              const targetElement = document.getElementById(id);
              if (targetElement) {
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                // Close TOC after clicking
                floatingToc.classList.remove('toc-open');
              }
            });
            
            listItem.appendChild(link);
            
            // Handle nesting
            if (level > currentLevel) {
              // Go deeper
              for (let i = currentLevel; i < level; i++) {
                const newList = document.createElement('ul');
                currentList.appendChild(newList);
                listStack.push(newList);
                currentList = newList;
              }
            } else if (level < currentLevel) {
              // Go shallower
              for (let i = currentLevel; i > level; i--) {
                listStack.pop();
                currentList = listStack[listStack.length - 1];
              }
            }
            
            currentList.appendChild(listItem);
            currentLevel = level;
          });
          
          tocNav.appendChild(tocList);
        }
        
        // Generate the TOC
        generateTOC();
        
        // Handle close button
        if (tocClose) {
          tocClose.addEventListener('click', function() {
            floatingToc.classList.remove('toc-open');
          });
        }
        
        // Handle click on icon to toggle
        const tocIcon = document.querySelector('.toc-icon');
        if (tocIcon) {
          tocIcon.addEventListener('click', function() {
            floatingToc.classList.toggle('toc-open');
          });
        }
        
        // Active section highlighting
        function updateActiveSection() {
          const headings = document.querySelectorAll('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6');
          const tocLinks = tocNav.querySelectorAll('a');
          
          // Remove active class from all links
          tocLinks.forEach(link => link.classList.remove('active'));
          
          // Find the current section
          let currentHeading = null;
          const scrollPosition = window.scrollY + 100; // Offset for better UX
          
          for (let i = headings.length - 1; i >= 0; i--) {
            const heading = headings[i];
            const headingTop = heading.offsetTop;
            
            if (headingTop <= scrollPosition) {
              currentHeading = heading;
              break;
            }
          }
          
          // Add active class to current section
          if (currentHeading) {
            const activeLink = tocNav.querySelector(`a[href="#${currentHeading.id}"]`);
            if (activeLink) {
              activeLink.classList.add('active');
            }
          }
        }
        
        // Update active section on scroll
        let scrollTimeout;
        window.addEventListener('scroll', function() {
          if (scrollTimeout) {
            clearTimeout(scrollTimeout);
          }
          scrollTimeout = setTimeout(updateActiveSection, 10);
        });
        
        // Initial update
        updateActiveSection();
      } else if (floatingToc && !isSubStudyPage) {
        // Hide floating TOC on main study page
        floatingToc.style.display = 'none';
      }
      
      // Legacy TOC functionality (for existing markdown TOCs)
      const toc = document.querySelector('#markdown-toc');
      if (toc) {
        // Hide the floating TOC if there's already a markdown TOC
        if (floatingToc) {
          floatingToc.style.display = 'none';
        }
        
        // Create TOC container with header
        const tocContainer = document.createElement('div');
        tocContainer.className = 'toc-container';
        tocContainer.style.cssText = `
          background: #f8fafc;
          border: 1px solid #e5e7eb;
          border-radius: 8px;
          padding: 16px;
          margin: 20px 0;
          position: relative;
        `;
        
        // Add TOC header
        const tocHeader = document.createElement('h3');
        tocHeader.textContent = 'Table of Contents';
        tocHeader.style.cssText = `
          margin: 0 0 12px 0;
          font-size: 16px;
          font-weight: 600;
          color: #374151;
        `;
        
        // Add back to top button
        const backToTopBtn = document.createElement('button');
        backToTopBtn.textContent = '‚Üë Top';
        backToTopBtn.style.cssText = `
          position: absolute;
          top: 12px;
          right: 12px;
          background: #ffffff;
          border: 1px solid #d1d5db;
          border-radius: 6px;
          padding: 4px 8px;
          font-size: 12px;
          cursor: pointer;
          color: #6b7280;
          transition: all 0.2s ease;
        `;
        
        // Add hover effect for back to top button
        backToTopBtn.addEventListener('mouseenter', function() {
          this.style.background = '#f3f4f6';
          this.style.color = '#374151';
        });
        
        backToTopBtn.addEventListener('mouseleave', function() {
          this.style.background = '#ffffff';
          this.style.color = '#6b7280';
        });
        
        // Back to top functionality
        backToTopBtn.addEventListener('click', function() {
          window.scrollTo({ top: 0, behavior: 'smooth' });
        });
        
        // Style the TOC list
        toc.style.cssText = `
          margin: 0;
          padding: 0;
          font-size: 14px;
          line-height: 1.5;
        `;
        
        // Insert header and button into container
        tocContainer.appendChild(tocHeader);
        tocContainer.appendChild(backToTopBtn);
        tocContainer.appendChild(toc);
        
        // Replace the original TOC with the new container
        toc.parentNode.insertBefore(tocContainer, toc);
        tocContainer.appendChild(toc);
        
        // Add smooth scrolling to TOC links
        const tocLinks = toc.querySelectorAll('a');
        tocLinks.forEach(link => {
          link.addEventListener('click', function(e) {
            e.preventDefault();
            const targetId = this.getAttribute('href').substring(1);
            const targetElement = document.getElementById(targetId);
            if (targetElement) {
              targetElement.scrollIntoView({ behavior: 'smooth' });
            }
          });
        });
      }
    });
  </script>
</body>
</html>
